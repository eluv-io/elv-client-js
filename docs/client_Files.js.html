

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="shortcut icon" href="images/favicon.png" >

  <title>
    client/Files.js - Documentation
  </title>

  <script src="scripts/prettify/prettify.js"></script>
  <script src="scripts/prettify/lang-css.js"></script>

  <link type="text/css" rel="stylesheet" href="styles/elv-jsdoc.css">
  <link type="text/css" rel="stylesheet" href="styles/elv-prettify-jsdoc.css">
</head>

<body>
  <div class="layout-container">
    <nav class="nav-container">
      <div class="header">
        <a href="index.html">
          <img class="logo" src="images/logo-dark.png" />
        </a>
        <div class="title">
          Eluvio Javascript Client
        </div>
      </div>
      <div class="nav-content">
        <h3>Classes</h3><ul><li id="ElvClient-nav">
          <div data-name="ElvClient" class="class-link-container"><a class="class-link">ElvClient</a></div><ul class='methods'><h4 class="methodGroupHeader">Constructor</h4><li data-type="method" id="ElvClient-ElvClient-nav"><a href="ElvClient.html" class="method-link">ElvClient</a></li><li data-type="method" id="ElvClient-Configuration-nav"><a href="ElvClient.html#.Configuration" class="method-link">Configuration</a></li><li data-type="method" id="ElvClient-FromConfigurationUrl-nav"><a href="ElvClient.html#.FromConfigurationUrl" class="method-link">FromConfigurationUrl</a></li><li data-type="method" id="ElvClient-FromNetworkName-nav"><a href="ElvClient.html#.FromNetworkName" class="method-link">FromNetworkName</a></li><h4 class="methodGroupHeader">Access Requests</h4><li data-type="method" id="ElvClient-ClearCache-nav"><a href="ElvClient.html#ClearCache" class="method-link">ClearCache</a></li><h4 class="methodGroupHeader">Authorization</h4><li data-type="method" id="ElvClient-CreateFabricToken-nav"><a href="ElvClient.html#CreateFabricToken" class="method-link">CreateFabricToken</a></li><li data-type="method" id="ElvClient-CreateSignedToken-nav"><a href="ElvClient.html#CreateSignedToken" class="method-link">CreateSignedToken</a></li><li data-type="method" id="ElvClient-SetOauthToken-nav"><a href="ElvClient.html#SetOauthToken" class="method-link">SetOauthToken</a></li><li data-type="method" id="ElvClient-SetPolicyAuthorization-nav"><a href="ElvClient.html#SetPolicyAuthorization" class="method-link">SetPolicyAuthorization</a></li><li data-type="method" id="ElvClient-SetSignerFromOauthToken-nav"><a href="ElvClient.html#SetSignerFromOauthToken" class="method-link">SetSignerFromOauthToken</a></li><li data-type="method" id="ElvClient-SetStaticToken-nav"><a href="ElvClient.html#SetStaticToken" class="method-link">SetStaticToken</a></li><h4 class="methodGroupHeader">Miscellaneous</h4><li data-type="method" id="ElvClient-ToggleLogging-nav"><a href="ElvClient.html#ToggleLogging" class="method-link">ToggleLogging</a></li><h4 class="methodGroupHeader">Nodes</h4><li data-type="method" id="ElvClient-NetworkInfo-nav"><a href="ElvClient.html#NetworkInfo" class="method-link">NetworkInfo</a></li><li data-type="method" id="ElvClient-NodeId-nav"><a href="ElvClient.html#NodeId" class="method-link">NodeId</a></li><li data-type="method" id="ElvClient-Nodes-nav"><a href="ElvClient.html#Nodes" class="method-link">Nodes</a></li><li data-type="method" id="ElvClient-ResetRegion-nav"><a href="ElvClient.html#ResetRegion" class="method-link">ResetRegion</a></li><li data-type="method" id="ElvClient-SetNodes-nav"><a href="ElvClient.html#SetNodes" class="method-link">SetNodes</a></li><li data-type="method" id="ElvClient-SpaceNodes-nav"><a href="ElvClient.html#SpaceNodes" class="method-link">SpaceNodes</a></li><li data-type="method" id="ElvClient-UseRegion-nav"><a href="ElvClient.html#UseRegion" class="method-link">UseRegion</a></li><h4 class="methodGroupHeader">Signers</h4><li data-type="method" id="ElvClient-ClearSigner-nav"><a href="ElvClient.html#ClearSigner" class="method-link">ClearSigner</a></li><li data-type="method" id="ElvClient-CreateAccount-nav"><a href="ElvClient.html#CreateAccount" class="method-link">CreateAccount</a></li><li data-type="method" id="ElvClient-CurrentAccountAddress-nav"><a href="ElvClient.html#CurrentAccountAddress" class="method-link">CurrentAccountAddress</a></li><li data-type="method" id="ElvClient-GenerateWallet-nav"><a href="ElvClient.html#GenerateWallet" class="method-link">GenerateWallet</a></li><li data-type="method" id="ElvClient-SetRemoteSigner-nav"><a href="ElvClient.html#SetRemoteSigner" class="method-link">SetRemoteSigner</a></li><li data-type="method" id="ElvClient-SetSigner-nav"><a href="ElvClient.html#SetSigner" class="method-link">SetSigner</a></li><li data-type="method" id="ElvClient-SetSignerFromWeb3Provider-nav"><a href="ElvClient.html#SetSignerFromWeb3Provider" class="method-link">SetSignerFromWeb3Provider</a></li><h4 class="methodGroupHeader">Methods</h4><li data-type="method" id="ElvClient-ClearStaticToken-nav"><a href="ElvClient.html#ClearStaticToken" class="method-link">ClearStaticToken</a></li><li data-type="method" id="ElvClient-DecryptECIES-nav"><a href="ElvClient.html#DecryptECIES" class="method-link">DecryptECIES</a></li><li data-type="method" id="ElvClient-EncryptECIES-nav"><a href="ElvClient.html#EncryptECIES" class="method-link">EncryptECIES</a></li><li data-type="method" id="ElvClient-Request-nav"><a href="ElvClient.html#Request" class="method-link">Request</a></li><li data-type="method" id="ElvClient-Sign-nav"><a href="ElvClient.html#Sign" class="method-link">Sign</a></li></ul></li><li id="ElvWallet-nav">
          <div data-name="ElvWallet" class="class-link-container"><a class="class-link">ElvWallet</a></div><ul class='methods'><h4 class="methodGroupHeader">Constructor</h4><li data-type="method" id="ElvWallet-ElvWallet-nav"><a href="ElvWallet.html" class="method-link">ElvWallet</a></li><h4 class="methodGroupHeader">Methods</h4><li data-type="method" id="ElvWallet-AddAccount-nav"><a href="ElvWallet.html#AddAccount" class="method-link">AddAccount</a></li><li data-type="method" id="ElvWallet-AddAccountFromEncryptedPK-nav"><a href="ElvWallet.html#AddAccountFromEncryptedPK" class="method-link">AddAccountFromEncryptedPK</a></li><li data-type="method" id="ElvWallet-AddAccountFromMnemonic-nav"><a href="ElvWallet.html#AddAccountFromMnemonic" class="method-link">AddAccountFromMnemonic</a></li><li data-type="method" id="ElvWallet-GenerateEncryptedPrivateKey-nav"><a href="ElvWallet.html#GenerateEncryptedPrivateKey" class="method-link">GenerateEncryptedPrivateKey</a></li><li data-type="method" id="ElvWallet-GenerateMnemonic-nav"><a href="ElvWallet.html#GenerateMnemonic" class="method-link">GenerateMnemonic</a></li><li data-type="method" id="ElvWallet-GetAccount-nav"><a href="ElvWallet.html#GetAccount" class="method-link">GetAccount</a></li><li data-type="method" id="ElvWallet-GetAccountBalance-nav"><a href="ElvWallet.html#GetAccountBalance" class="method-link">GetAccountBalance</a></li><li data-type="method" id="ElvWallet-RemoveAccount-nav"><a href="ElvWallet.html#RemoveAccount" class="method-link">RemoveAccount</a></li></ul></li><li id="FrameClient-nav">
          <div data-name="FrameClient" class="class-link-container"><a class="class-link">FrameClient</a></div><ul class='methods'><h4 class="methodGroupHeader">Constructor</h4><li data-type="method" id="FrameClient-FrameClient-nav"><a href="FrameClient.html" class="method-link">FrameClient</a></li><h4 class="methodGroupHeader">Methods</h4><li data-type="method" id="FrameClient-AllowedMethods-nav"><a href="FrameClient.html#AllowedMethods" class="method-link">AllowedMethods</a></li><li data-type="method" id="FrameClient-PassRequest-nav"><a href="FrameClient.html#PassRequest" class="method-link">PassRequest</a></li></ul></li><li id="PermissionsClient-nav">
          <div data-name="PermissionsClient" class="class-link-container"><a class="class-link">PermissionsClient</a></div><ul class='methods'><h4 class="methodGroupHeader">Constructor</h4><li data-type="method" id="PermissionsClient-PermissionsClient-nav"><a href="PermissionsClient.html" class="method-link">PermissionsClient</a></li><h4 class="methodGroupHeader">OfflineDraft</h4><li data-type="method" id="PermissionsClient-CloseOfflineDraft-nav"><a href="PermissionsClient.html#CloseOfflineDraft" class="method-link">CloseOfflineDraft</a></li><li data-type="method" id="PermissionsClient-OpenOfflineDraft-nav"><a href="PermissionsClient.html#OpenOfflineDraft" class="method-link">OpenOfflineDraft</a></li><h4 class="methodGroupHeader">Permissions</h4><li data-type="method" id="PermissionsClient-ItemPermissions-nav"><a href="PermissionsClient.html#ItemPermissions" class="method-link">ItemPermissions</a></li><li data-type="method" id="PermissionsClient-RemovePermission-nav"><a href="PermissionsClient.html#RemovePermission" class="method-link">RemovePermission</a></li><li data-type="method" id="PermissionsClient-RemoveSubjectPermissions-nav"><a href="PermissionsClient.html#RemoveSubjectPermissions" class="method-link">RemoveSubjectPermissions</a></li><li data-type="method" id="PermissionsClient-SetPermission-nav"><a href="PermissionsClient.html#SetPermission" class="method-link">SetPermission</a></li><li data-type="method" id="PermissionsClient-SubjectPermissions-nav"><a href="PermissionsClient.html#SubjectPermissions" class="method-link">SubjectPermissions</a></li><h4 class="methodGroupHeader">Policies</h4><li data-type="method" id="PermissionsClient-CreateItemPolicy-nav"><a href="PermissionsClient.html#CreateItemPolicy" class="method-link">CreateItemPolicy</a></li><li data-type="method" id="PermissionsClient-ItemPolicy-nav"><a href="PermissionsClient.html#ItemPolicy" class="method-link">ItemPolicy</a></li><li data-type="method" id="PermissionsClient-PolicyItems-nav"><a href="PermissionsClient.html#PolicyItems" class="method-link">PolicyItems</a></li><li data-type="method" id="PermissionsClient-RemoveItemPolicy-nav"><a href="PermissionsClient.html#RemoveItemPolicy" class="method-link">RemoveItemPolicy</a></li><h4 class="methodGroupHeader">Profiles</h4><li data-type="method" id="PermissionsClient-ItemProfiles-nav"><a href="PermissionsClient.html#ItemProfiles" class="method-link">ItemProfiles</a></li><li data-type="method" id="PermissionsClient-RemoveProfile-nav"><a href="PermissionsClient.html#RemoveProfile" class="method-link">RemoveProfile</a></li><li data-type="method" id="PermissionsClient-SetProfile-nav"><a href="PermissionsClient.html#SetProfile" class="method-link">SetProfile</a></li></ul></li><li id="UserProfileClient-nav">
          <div data-name="UserProfileClient" class="class-link-container"><a class="class-link">UserProfileClient</a></div><ul class='methods'><h4 class="methodGroupHeader">Constructor</h4><li data-type="method" id="UserProfileClient-UserProfileClient-nav"><a href="UserProfileClient.html" class="method-link">UserProfileClient</a></li><h4 class="methodGroupHeader">Methods</h4><li data-type="method" id="UserProfileClient-AccessLevel-nav"><a href="UserProfileClient.html#AccessLevel" class="method-link">AccessLevel</a></li><li data-type="method" id="UserProfileClient-CollectedTags-nav"><a href="UserProfileClient.html#CollectedTags" class="method-link">CollectedTags</a></li><li data-type="method" id="UserProfileClient-DeleteUserMetadata-nav"><a href="UserProfileClient.html#DeleteUserMetadata" class="method-link">DeleteUserMetadata</a></li><li data-type="method" id="UserProfileClient-MergeUserMetadata-nav"><a href="UserProfileClient.html#MergeUserMetadata" class="method-link">MergeUserMetadata</a></li><li data-type="method" id="UserProfileClient-PublicUserMetadata-nav"><a href="UserProfileClient.html#PublicUserMetadata" class="method-link">PublicUserMetadata</a></li><li data-type="method" id="UserProfileClient-ReplaceUserMetadata-nav"><a href="UserProfileClient.html#ReplaceUserMetadata" class="method-link">ReplaceUserMetadata</a></li><li data-type="method" id="UserProfileClient-SetAccessLevel-nav"><a href="UserProfileClient.html#SetAccessLevel" class="method-link">SetAccessLevel</a></li><li data-type="method" id="UserProfileClient-SetTenantContractId-nav"><a href="UserProfileClient.html#SetTenantContractId" class="method-link">SetTenantContractId</a></li><li data-type="method" id="UserProfileClient-SetTenantId-nav"><a href="UserProfileClient.html#SetTenantId" class="method-link">SetTenantId</a></li><li data-type="method" id="UserProfileClient-SetUserProfileImage-nav"><a href="UserProfileClient.html#SetUserProfileImage" class="method-link">SetUserProfileImage</a></li><li data-type="method" id="UserProfileClient-TenantContractId-nav"><a href="UserProfileClient.html#TenantContractId" class="method-link">TenantContractId</a></li><li data-type="method" id="UserProfileClient-TenantId-nav"><a href="UserProfileClient.html#TenantId" class="method-link">TenantId</a></li><li data-type="method" id="UserProfileClient-UserMetadata-nav"><a href="UserProfileClient.html#UserMetadata" class="method-link">UserMetadata</a></li><li data-type="method" id="UserProfileClient-UserProfileImage-nav"><a href="UserProfileClient.html#UserProfileImage" class="method-link">UserProfileImage</a></li><li data-type="method" id="UserProfileClient-UserWalletAddress-nav"><a href="UserProfileClient.html#UserWalletAddress" class="method-link">UserWalletAddress</a></li><li data-type="method" id="UserProfileClient-UserWalletObjectInfo-nav"><a href="UserProfileClient.html#UserWalletObjectInfo" class="method-link">UserWalletObjectInfo</a></li><li data-type="method" id="UserProfileClient-WalletAddress-nav"><a href="UserProfileClient.html#WalletAddress" class="method-link">WalletAddress</a></li></ul></li></ul><h3>Modules</h3><ul><li id="ElvClient_ABRPublishing-nav">
          <div data-name="ElvClient/ABRPublishing" class="class-link-container"><a class="class-link">ElvClient/ABRPublishing</a></div><ul class='methods'><li data-type="method" id="ElvClient_ABRPublishing-ElvClient/ABRPublishing-nav"><a href="module-ElvClient_ABRPublishing.html" class="method-link">ElvClient/ABRPublishing</a></li><h4 class="methodGroupHeader">ABR Publishing</h4><li data-type="method" id="ElvClient_ABRPublishing-CreateABRMezzanine-nav"><a href="module-ElvClient_ABRPublishing.html#.CreateABRMezzanine" class="method-link">CreateABRMezzanine</a></li><li data-type="method" id="ElvClient_ABRPublishing-CreateProductionMaster-nav"><a href="module-ElvClient_ABRPublishing.html#.CreateProductionMaster" class="method-link">CreateProductionMaster</a></li><li data-type="method" id="ElvClient_ABRPublishing-FinalizeABRMezzanine-nav"><a href="module-ElvClient_ABRPublishing.html#.FinalizeABRMezzanine" class="method-link">FinalizeABRMezzanine</a></li><li data-type="method" id="ElvClient_ABRPublishing-LRODraftInfo-nav"><a href="module-ElvClient_ABRPublishing.html#.LRODraftInfo" class="method-link">LRODraftInfo</a></li><li data-type="method" id="ElvClient_ABRPublishing-LROStatus-nav"><a href="module-ElvClient_ABRPublishing.html#.LROStatus" class="method-link">LROStatus</a></li><li data-type="method" id="ElvClient_ABRPublishing-StartABRMezzanineJobs-nav"><a href="module-ElvClient_ABRPublishing.html#.StartABRMezzanineJobs" class="method-link">StartABRMezzanineJobs</a></li></ul></li><li id="ElvClient_AccessGroups-nav">
          <div data-name="ElvClient/AccessGroups" class="class-link-container"><a class="class-link">ElvClient/AccessGroups</a></div><ul class='methods'><li data-type="method" id="ElvClient_AccessGroups-ElvClient/AccessGroups-nav"><a href="module-ElvClient_AccessGroups.html" class="method-link">ElvClient/AccessGroups</a></li><h4 class="methodGroupHeader">Access Groups</h4><li data-type="method" id="ElvClient_AccessGroups-ListAccessGroups-nav"><a href="module-ElvClient_AccessGroups.html#.ListAccessGroups" class="method-link">ListAccessGroups</a></li><li data-type="method" id="ElvClient_AccessGroups-AccessGroupManagers-nav"><a href="module-ElvClient_AccessGroups.html#.exports.AccessGroupManagers" class="method-link">AccessGroupManagers</a></li><li data-type="method" id="ElvClient_AccessGroups-AccessGroupMembers-nav"><a href="module-ElvClient_AccessGroups.html#.exports.AccessGroupMembers" class="method-link">AccessGroupMembers</a></li><li data-type="method" id="ElvClient_AccessGroups-AccessGroupOwner-nav"><a href="module-ElvClient_AccessGroups.html#.exports.AccessGroupOwner" class="method-link">AccessGroupOwner</a></li><li data-type="method" id="ElvClient_AccessGroups-AddAccessGroupManager-nav"><a href="module-ElvClient_AccessGroups.html#.exports.AddAccessGroupManager" class="method-link">AddAccessGroupManager</a></li><li data-type="method" id="ElvClient_AccessGroups-AddAccessGroupMember-nav"><a href="module-ElvClient_AccessGroups.html#.exports.AddAccessGroupMember" class="method-link">AddAccessGroupMember</a></li><li data-type="method" id="ElvClient_AccessGroups-CreateAccessGroup-nav"><a href="module-ElvClient_AccessGroups.html#.exports.CreateAccessGroup" class="method-link">CreateAccessGroup</a></li><li data-type="method" id="ElvClient_AccessGroups-DeleteAccessGroup-nav"><a href="module-ElvClient_AccessGroups.html#.exports.DeleteAccessGroup" class="method-link">DeleteAccessGroup</a></li><li data-type="method" id="ElvClient_AccessGroups-RemoveAccessGroupManager-nav"><a href="module-ElvClient_AccessGroups.html#.exports.RemoveAccessGroupManager" class="method-link">RemoveAccessGroupManager</a></li><li data-type="method" id="ElvClient_AccessGroups-RemoveAccessGroupMember-nav"><a href="module-ElvClient_AccessGroups.html#.exports.RemoveAccessGroupMember" class="method-link">RemoveAccessGroupMember</a></li><h4 class="methodGroupHeader">Library Access Groups</h4><li data-type="method" id="ElvClient_AccessGroups-AddContentLibraryGroup-nav"><a href="module-ElvClient_AccessGroups.html#.exports.AddContentLibraryGroup" class="method-link">AddContentLibraryGroup</a></li><li data-type="method" id="ElvClient_AccessGroups-ContentLibraryGroupPermissions-nav"><a href="module-ElvClient_AccessGroups.html#.exports.ContentLibraryGroupPermissions" class="method-link">ContentLibraryGroupPermissions</a></li><li data-type="method" id="ElvClient_AccessGroups-RemoveContentLibraryGroup-nav"><a href="module-ElvClient_AccessGroups.html#.exports.RemoveContentLibraryGroup" class="method-link">RemoveContentLibraryGroup</a></li><h4 class="methodGroupHeader">Object Access Groups</h4><li data-type="method" id="ElvClient_AccessGroups-AddContentObjectGroupPermission-nav"><a href="module-ElvClient_AccessGroups.html#.exports.AddContentObjectGroupPermission" class="method-link">AddContentObjectGroupPermission</a></li><li data-type="method" id="ElvClient_AccessGroups-ContentObjectGroupPermissions-nav"><a href="module-ElvClient_AccessGroups.html#.exports.ContentObjectGroupPermissions" class="method-link">ContentObjectGroupPermissions</a></li><li data-type="method" id="ElvClient_AccessGroups-RemoveContentObjectGroupPermission-nav"><a href="module-ElvClient_AccessGroups.html#.exports.RemoveContentObjectGroupPermission" class="method-link">RemoveContentObjectGroupPermission</a></li><h4 class="methodGroupHeader">Methods</h4><li data-type="method" id="ElvClient_AccessGroups-LinkAccessGroupToOauth-nav"><a href="module-ElvClient_AccessGroups.html#.LinkAccessGroupToOauth" class="method-link">LinkAccessGroupToOauth</a></li><li data-type="method" id="ElvClient_AccessGroups-UnlinkAccessGroupFromOauth-nav"><a href="module-ElvClient_AccessGroups.html#.UnlinkAccessGroupFromOauth" class="method-link">UnlinkAccessGroupFromOauth</a></li></ul></li><li id="ElvClient_ContentAccess-nav">
          <div data-name="ElvClient/ContentAccess" class="class-link-container"><a class="class-link">ElvClient/ContentAccess</a></div><ul class='methods'><li data-type="method" id="ElvClient_ContentAccess-ElvClient/ContentAccess-nav"><a href="module-ElvClient_ContentAccess.html" class="method-link">ElvClient/ContentAccess</a></li><h4 class="methodGroupHeader">Access Requests</h4><li data-type="method" id="ElvClient_ContentAccess-AccessInfo-nav"><a href="module-ElvClient_ContentAccess.html#.AccessInfo" class="method-link">AccessInfo</a></li><li data-type="method" id="ElvClient_ContentAccess-AccessRequest-nav"><a href="module-ElvClient_ContentAccess.html#.AccessRequest" class="method-link">AccessRequest</a></li><li data-type="method" id="ElvClient_ContentAccess-AccessType-nav"><a href="module-ElvClient_ContentAccess.html#.AccessType" class="method-link">AccessType</a></li><li data-type="method" id="ElvClient_ContentAccess-ContentObjectAccessComplete-nav"><a href="module-ElvClient_ContentAccess.html#.ContentObjectAccessComplete" class="method-link">ContentObjectAccessComplete</a></li><li data-type="method" id="ElvClient_ContentAccess-FinalizeStateChannelAccess-nav"><a href="module-ElvClient_ContentAccess.html#.FinalizeStateChannelAccess" class="method-link">FinalizeStateChannelAccess</a></li><li data-type="method" id="ElvClient_ContentAccess-GenerateStateChannelToken-nav"><a href="module-ElvClient_ContentAccess.html#.GenerateStateChannelToken" class="method-link">GenerateStateChannelToken</a></li><li data-type="method" id="ElvClient_ContentAccess-SetAuthContext-nav"><a href="module-ElvClient_ContentAccess.html#.SetAuthContext" class="method-link">SetAuthContext</a></li><h4 class="methodGroupHeader">Collections</h4><li data-type="method" id="ElvClient_ContentAccess-Collection-nav"><a href="module-ElvClient_ContentAccess.html#.Collection" class="method-link">Collection</a></li><h4 class="methodGroupHeader">Content Libraries</h4><li data-type="method" id="ElvClient_ContentAccess-ContentLibraries-nav"><a href="module-ElvClient_ContentAccess.html#.ContentLibraries" class="method-link">ContentLibraries</a></li><li data-type="method" id="ElvClient_ContentAccess-ContentLibrary-nav"><a href="module-ElvClient_ContentAccess.html#.ContentLibrary" class="method-link">ContentLibrary</a></li><li data-type="method" id="ElvClient_ContentAccess-ContentLibraryOwner-nav"><a href="module-ElvClient_ContentAccess.html#.ContentLibraryOwner" class="method-link">ContentLibraryOwner</a></li><li data-type="method" id="ElvClient_ContentAccess-LibraryContentTypes-nav"><a href="module-ElvClient_ContentAccess.html#.LibraryContentTypes" class="method-link">LibraryContentTypes</a></li><h4 class="methodGroupHeader">Content Objects</h4><li data-type="method" id="ElvClient_ContentAccess-AssetMetadata-nav"><a href="module-ElvClient_ContentAccess.html#.AssetMetadata" class="method-link">AssetMetadata</a></li><li data-type="method" id="ElvClient_ContentAccess-ContentObject-nav"><a href="module-ElvClient_ContentAccess.html#.ContentObject" class="method-link">ContentObject</a></li><li data-type="method" id="ElvClient_ContentAccess-ContentObjectLibraryId-nav"><a href="module-ElvClient_ContentAccess.html#.ContentObjectLibraryId" class="method-link">ContentObjectLibraryId</a></li><li data-type="method" id="ElvClient_ContentAccess-ContentObjectOwner-nav"><a href="module-ElvClient_ContentAccess.html#.ContentObjectOwner" class="method-link">ContentObjectOwner</a></li><li data-type="method" id="ElvClient_ContentAccess-ContentObjectTenantId-nav"><a href="module-ElvClient_ContentAccess.html#.ContentObjectTenantId" class="method-link">ContentObjectTenantId</a></li><li data-type="method" id="ElvClient_ContentAccess-ContentObjectVersions-nav"><a href="module-ElvClient_ContentAccess.html#.ContentObjectVersions" class="method-link">ContentObjectVersions</a></li><li data-type="method" id="ElvClient_ContentAccess-ContentObjects-nav"><a href="module-ElvClient_ContentAccess.html#.ContentObjects" class="method-link">ContentObjects</a></li><li data-type="method" id="ElvClient_ContentAccess-LatestVersionHash-nav"><a href="module-ElvClient_ContentAccess.html#.LatestVersionHash" class="method-link">LatestVersionHash</a></li><li data-type="method" id="ElvClient_ContentAccess-Permission-nav"><a href="module-ElvClient_ContentAccess.html#.Permission" class="method-link">Permission</a></li><li data-type="method" id="ElvClient_ContentAccess-Proofs-nav"><a href="module-ElvClient_ContentAccess.html#.Proofs" class="method-link">Proofs</a></li><li data-type="method" id="ElvClient_ContentAccess-QParts-nav"><a href="module-ElvClient_ContentAccess.html#.QParts" class="method-link">QParts</a></li><li data-type="method" id="ElvClient_ContentAccess-VerifyContentObject-nav"><a href="module-ElvClient_ContentAccess.html#.VerifyContentObject" class="method-link">VerifyContentObject</a></li><h4 class="methodGroupHeader">Content Space</h4><li data-type="method" id="ElvClient_ContentAccess-ContentSpaceId-nav"><a href="module-ElvClient_ContentAccess.html#.ContentSpaceId" class="method-link">ContentSpaceId</a></li><li data-type="method" id="ElvClient_ContentAccess-DefaultKMSAddress-nav"><a href="module-ElvClient_ContentAccess.html#.DefaultKMSAddress" class="method-link">DefaultKMSAddress</a></li><h4 class="methodGroupHeader">Content Types</h4><li data-type="method" id="ElvClient_ContentAccess-ContentType-nav"><a href="module-ElvClient_ContentAccess.html#.ContentType" class="method-link">ContentType</a></li><li data-type="method" id="ElvClient_ContentAccess-ContentTypeOwner-nav"><a href="module-ElvClient_ContentAccess.html#.ContentTypeOwner" class="method-link">ContentTypeOwner</a></li><li data-type="method" id="ElvClient_ContentAccess-ContentTypes-nav"><a href="module-ElvClient_ContentAccess.html#.ContentTypes" class="method-link">ContentTypes</a></li><h4 class="methodGroupHeader">Encryption</h4><li data-type="method" id="ElvClient_ContentAccess-Decrypt-nav"><a href="module-ElvClient_ContentAccess.html#.Decrypt" class="method-link">Decrypt</a></li><li data-type="method" id="ElvClient_ContentAccess-Encrypt-nav"><a href="module-ElvClient_ContentAccess.html#.Encrypt" class="method-link">Encrypt</a></li><li data-type="method" id="ElvClient_ContentAccess-EncryptionConk-nav"><a href="module-ElvClient_ContentAccess.html#.EncryptionConk" class="method-link">EncryptionConk</a></li><h4 class="methodGroupHeader">Links</h4><li data-type="method" id="ElvClient_ContentAccess-ContentObjectGraph-nav"><a href="module-ElvClient_ContentAccess.html#.ContentObjectGraph" class="method-link">ContentObjectGraph</a></li><li data-type="method" id="ElvClient_ContentAccess-LinkData-nav"><a href="module-ElvClient_ContentAccess.html#.LinkData" class="method-link">LinkData</a></li><li data-type="method" id="ElvClient_ContentAccess-LinkTarget-nav"><a href="module-ElvClient_ContentAccess.html#.LinkTarget" class="method-link">LinkTarget</a></li><li data-type="method" id="ElvClient_ContentAccess-LinkUrl-nav"><a href="module-ElvClient_ContentAccess.html#.LinkUrl" class="method-link">LinkUrl</a></li><h4 class="methodGroupHeader">Media</h4><li data-type="method" id="ElvClient_ContentAccess-AvailableDRMs-nav"><a href="module-ElvClient_ContentAccess.html#.AvailableDRMs" class="method-link">AvailableDRMs</a></li><li data-type="method" id="ElvClient_ContentAccess-AvailableOfferings-nav"><a href="module-ElvClient_ContentAccess.html#.AvailableOfferings" class="method-link">AvailableOfferings</a></li><li data-type="method" id="ElvClient_ContentAccess-BitmovinPlayoutOptions-nav"><a href="module-ElvClient_ContentAccess.html#.BitmovinPlayoutOptions" class="method-link">BitmovinPlayoutOptions</a></li><li data-type="method" id="ElvClient_ContentAccess-PlayoutOptions-nav"><a href="module-ElvClient_ContentAccess.html#.PlayoutOptions" class="method-link">PlayoutOptions</a></li><h4 class="methodGroupHeader">Metadata</h4><li data-type="method" id="ElvClient_ContentAccess-ContentObjectMetadata-nav"><a href="module-ElvClient_ContentAccess.html#.ContentObjectMetadata" class="method-link">ContentObjectMetadata</a></li><h4 class="methodGroupHeader">URL Generation</h4><li data-type="method" id="ElvClient_ContentAccess-CallBitcodeMethod-nav"><a href="module-ElvClient_ContentAccess.html#.CallBitcodeMethod" class="method-link">CallBitcodeMethod</a></li><li data-type="method" id="ElvClient_ContentAccess-ContentObjectImageUrl-nav"><a href="module-ElvClient_ContentAccess.html#.ContentObjectImageUrl" class="method-link">ContentObjectImageUrl</a></li><li data-type="method" id="ElvClient_ContentAccess-EmbedUrl-nav"><a href="module-ElvClient_ContentAccess.html#.EmbedUrl" class="method-link">EmbedUrl</a></li><li data-type="method" id="ElvClient_ContentAccess-FabricUrl-nav"><a href="module-ElvClient_ContentAccess.html#.FabricUrl" class="method-link">FabricUrl</a></li><li data-type="method" id="ElvClient_ContentAccess-FileUrl-nav"><a href="module-ElvClient_ContentAccess.html#.FileUrl" class="method-link">FileUrl</a></li><li data-type="method" id="ElvClient_ContentAccess-PublicRep-nav"><a href="module-ElvClient_ContentAccess.html#.PublicRep" class="method-link">PublicRep</a></li><li data-type="method" id="ElvClient_ContentAccess-Rep-nav"><a href="module-ElvClient_ContentAccess.html#.Rep" class="method-link">Rep</a></li></ul></li><li id="ElvClient_ContentManagement-nav">
          <div data-name="ElvClient/ContentManagement" class="class-link-container"><a class="class-link">ElvClient/ContentManagement</a></div><ul class='methods'><li data-type="method" id="ElvClient_ContentManagement-ElvClient/ContentManagement-nav"><a href="module-ElvClient_ContentManagement.html" class="method-link">ElvClient/ContentManagement</a></li><h4 class="methodGroupHeader">Access Requests</h4><li data-type="method" id="ElvClient_ContentManagement-CreateNonOwnerCap-nav"><a href="module-ElvClient_ContentManagement.html#.CreateNonOwnerCap" class="method-link">CreateNonOwnerCap</a></li><li data-type="method" id="ElvClient_ContentManagement-SetAccessCharge-nav"><a href="module-ElvClient_ContentManagement.html#.SetAccessCharge" class="method-link">SetAccessCharge</a></li><h4 class="methodGroupHeader">Auth Policies</h4><li data-type="method" id="ElvClient_ContentManagement-InitializeAuthPolicy-nav"><a href="module-ElvClient_ContentManagement.html#.InitializeAuthPolicy" class="method-link">InitializeAuthPolicy</a></li><li data-type="method" id="ElvClient_ContentManagement-SetAuthPolicy-nav"><a href="module-ElvClient_ContentManagement.html#.SetAuthPolicy" class="method-link">SetAuthPolicy</a></li><h4 class="methodGroupHeader">Content Libraries</h4><li data-type="method" id="ElvClient_ContentManagement-AddLibraryContentType-nav"><a href="module-ElvClient_ContentManagement.html#.AddLibraryContentType" class="method-link">AddLibraryContentType</a></li><li data-type="method" id="ElvClient_ContentManagement-CreateContentLibrary-nav"><a href="module-ElvClient_ContentManagement.html#.CreateContentLibrary" class="method-link">CreateContentLibrary</a></li><li data-type="method" id="ElvClient_ContentManagement-DeleteContentLibrary-nav"><a href="module-ElvClient_ContentManagement.html#.DeleteContentLibrary" class="method-link">DeleteContentLibrary</a></li><li data-type="method" id="ElvClient_ContentManagement-RemoveLibraryContentType-nav"><a href="module-ElvClient_ContentManagement.html#.RemoveLibraryContentType" class="method-link">RemoveLibraryContentType</a></li><li data-type="method" id="ElvClient_ContentManagement-SetContentLibraryImage-nav"><a href="module-ElvClient_ContentManagement.html#.SetContentLibraryImage" class="method-link">SetContentLibraryImage</a></li><h4 class="methodGroupHeader">Content Objects</h4><li data-type="method" id="ElvClient_ContentManagement-CopyContentObject-nav"><a href="module-ElvClient_ContentManagement.html#.CopyContentObject" class="method-link">CopyContentObject</a></li><li data-type="method" id="ElvClient_ContentManagement-CreateAndFinalizeContentObject-nav"><a href="module-ElvClient_ContentManagement.html#.CreateAndFinalizeContentObject" class="method-link">CreateAndFinalizeContentObject</a></li><li data-type="method" id="ElvClient_ContentManagement-CreateContentObject-nav"><a href="module-ElvClient_ContentManagement.html#.CreateContentObject" class="method-link">CreateContentObject</a></li><li data-type="method" id="ElvClient_ContentManagement-DeleteContentObject-nav"><a href="module-ElvClient_ContentManagement.html#.DeleteContentObject" class="method-link">DeleteContentObject</a></li><li data-type="method" id="ElvClient_ContentManagement-DeleteContentVersion-nav"><a href="module-ElvClient_ContentManagement.html#.DeleteContentVersion" class="method-link">DeleteContentVersion</a></li><li data-type="method" id="ElvClient_ContentManagement-EditAndFinalizeContentObject-nav"><a href="module-ElvClient_ContentManagement.html#.EditAndFinalizeContentObject" class="method-link">EditAndFinalizeContentObject</a></li><li data-type="method" id="ElvClient_ContentManagement-EditContentObject-nav"><a href="module-ElvClient_ContentManagement.html#.EditContentObject" class="method-link">EditContentObject</a></li><li data-type="method" id="ElvClient_ContentManagement-FinalizeContentObject-nav"><a href="module-ElvClient_ContentManagement.html#.FinalizeContentObject" class="method-link">FinalizeContentObject</a></li><li data-type="method" id="ElvClient_ContentManagement-PublishContentVersion-nav"><a href="module-ElvClient_ContentManagement.html#.PublishContentVersion" class="method-link">PublishContentVersion</a></li><li data-type="method" id="ElvClient_ContentManagement-SetContentObjectImage-nav"><a href="module-ElvClient_ContentManagement.html#.SetContentObjectImage" class="method-link">SetContentObjectImage</a></li><li data-type="method" id="ElvClient_ContentManagement-SetPermission-nav"><a href="module-ElvClient_ContentManagement.html#.SetPermission" class="method-link">SetPermission</a></li><h4 class="methodGroupHeader">Content Types</h4><li data-type="method" id="ElvClient_ContentManagement-CreateContentType-nav"><a href="module-ElvClient_ContentManagement.html#.CreateContentType" class="method-link">CreateContentType</a></li><h4 class="methodGroupHeader">Links</h4><li data-type="method" id="ElvClient_ContentManagement-CreateLinks-nav"><a href="module-ElvClient_ContentManagement.html#.CreateLinks" class="method-link">CreateLinks</a></li><li data-type="method" id="ElvClient_ContentManagement-GenerateSignedLinkToken-nav"><a href="module-ElvClient_ContentManagement.html#.GenerateSignedLinkToken" class="method-link">GenerateSignedLinkToken</a></li><li data-type="method" id="ElvClient_ContentManagement-UpdateContentObjectGraph-nav"><a href="module-ElvClient_ContentManagement.html#.UpdateContentObjectGraph" class="method-link">UpdateContentObjectGraph</a></li><h4 class="methodGroupHeader">Metadata</h4><li data-type="method" id="ElvClient_ContentManagement-DeleteMetadata-nav"><a href="module-ElvClient_ContentManagement.html#.DeleteMetadata" class="method-link">DeleteMetadata</a></li><li data-type="method" id="ElvClient_ContentManagement-MergeMetadata-nav"><a href="module-ElvClient_ContentManagement.html#.MergeMetadata" class="method-link">MergeMetadata</a></li><li data-type="method" id="ElvClient_ContentManagement-ReplaceMetadata-nav"><a href="module-ElvClient_ContentManagement.html#.ReplaceMetadata" class="method-link">ReplaceMetadata</a></li></ul></li><li id="ElvClient_Contracts-nav">
          <div data-name="ElvClient/Contracts" class="class-link-container"><a class="class-link">ElvClient/Contracts</a></div><ul class='methods'><li data-type="method" id="ElvClient_Contracts-ElvClient/Contracts-nav"><a href="module-ElvClient_Contracts.html" class="method-link">ElvClient/Contracts</a></li><h4 class="methodGroupHeader">Blockchain</h4><li data-type="method" id="ElvClient_Contracts-BlockNumber-nav"><a href="module-ElvClient_Contracts.html#.BlockNumber" class="method-link">BlockNumber</a></li><li data-type="method" id="ElvClient_Contracts-Events-nav"><a href="module-ElvClient_Contracts.html#.Events" class="method-link">Events</a></li><li data-type="method" id="ElvClient_Contracts-GetBalance-nav"><a href="module-ElvClient_Contracts.html#.GetBalance" class="method-link">GetBalance</a></li><li data-type="method" id="ElvClient_Contracts-SendFunds-nav"><a href="module-ElvClient_Contracts.html#.SendFunds" class="method-link">SendFunds</a></li><h4 class="methodGroupHeader">Contracts</h4><li data-type="method" id="ElvClient_Contracts-CallContractMethod-nav"><a href="module-ElvClient_Contracts.html#.CallContractMethod" class="method-link">CallContractMethod</a></li><li data-type="method" id="ElvClient_Contracts-CallContractMethodAndWait-nav"><a href="module-ElvClient_Contracts.html#.CallContractMethodAndWait" class="method-link">CallContractMethodAndWait</a></li><li data-type="method" id="ElvClient_Contracts-ContractAbi-nav"><a href="module-ElvClient_Contracts.html#.ContractAbi" class="method-link">ContractAbi</a></li><li data-type="method" id="ElvClient_Contracts-ContractEvents-nav"><a href="module-ElvClient_Contracts.html#.ContractEvents" class="method-link">ContractEvents</a></li><li data-type="method" id="ElvClient_Contracts-ContractMetadata-nav"><a href="module-ElvClient_Contracts.html#.ContractMetadata" class="method-link">ContractMetadata</a></li><li data-type="method" id="ElvClient_Contracts-ContractName-nav"><a href="module-ElvClient_Contracts.html#.ContractName" class="method-link">ContractName</a></li><li data-type="method" id="ElvClient_Contracts-CustomContractAddress-nav"><a href="module-ElvClient_Contracts.html#.CustomContractAddress" class="method-link">CustomContractAddress</a></li><li data-type="method" id="ElvClient_Contracts-DeployContract-nav"><a href="module-ElvClient_Contracts.html#.DeployContract" class="method-link">DeployContract</a></li><li data-type="method" id="ElvClient_Contracts-ExtractEventFromLogs-nav"><a href="module-ElvClient_Contracts.html#.ExtractEventFromLogs" class="method-link">ExtractEventFromLogs</a></li><li data-type="method" id="ElvClient_Contracts-ExtractValueFromEvent-nav"><a href="module-ElvClient_Contracts.html#.ExtractValueFromEvent" class="method-link">ExtractValueFromEvent</a></li><li data-type="method" id="ElvClient_Contracts-FormatContractArguments-nav"><a href="module-ElvClient_Contracts.html#.FormatContractArguments" class="method-link">FormatContractArguments</a></li><li data-type="method" id="ElvClient_Contracts-MergeContractMetadata-nav"><a href="module-ElvClient_Contracts.html#.MergeContractMetadata" class="method-link">MergeContractMetadata</a></li><li data-type="method" id="ElvClient_Contracts-ReplaceContractMetadata-nav"><a href="module-ElvClient_Contracts.html#.ReplaceContractMetadata" class="method-link">ReplaceContractMetadata</a></li><li data-type="method" id="ElvClient_Contracts-SetCustomContentContract-nav"><a href="module-ElvClient_Contracts.html#.SetCustomContentContract" class="method-link">SetCustomContentContract</a></li></ul></li><li id="ElvClient_Files+Parts-nav">
          <div data-name="ElvClient/Files+Parts" class="class-link-container"><a class="class-link">ElvClient/Files+Parts</a></div><ul class='methods'><li data-type="method" id="ElvClient_Files+Parts-ElvClient/Files+Parts-nav"><a href="module-ElvClient_Files+Parts.html" class="method-link">ElvClient/Files+Parts</a></li><h4 class="methodGroupHeader">Files</h4><li data-type="method" id="ElvClient_Files+Parts-CreateFileDirectories-nav"><a href="module-ElvClient_Files+Parts.html#.exports.CreateFileDirectories" class="method-link">CreateFileDirectories</a></li><li data-type="method" id="ElvClient_Files+Parts-DeleteFiles-nav"><a href="module-ElvClient_Files+Parts.html#.exports.DeleteFiles" class="method-link">DeleteFiles</a></li><li data-type="method" id="ElvClient_Files+Parts-DownloadFile-nav"><a href="module-ElvClient_Files+Parts.html#.exports.DownloadFile" class="method-link">DownloadFile</a></li><li data-type="method" id="ElvClient_Files+Parts-ListFiles-nav"><a href="module-ElvClient_Files+Parts.html#.exports.ListFiles" class="method-link">ListFiles</a></li><li data-type="method" id="ElvClient_Files+Parts-MoveFiles-nav"><a href="module-ElvClient_Files+Parts.html#.exports.MoveFiles" class="method-link">MoveFiles</a></li><li data-type="method" id="ElvClient_Files+Parts-UploadFiles-nav"><a href="module-ElvClient_Files+Parts.html#.exports.UploadFiles" class="method-link">UploadFiles</a></li><li data-type="method" id="ElvClient_Files+Parts-UploadFilesFromS3-nav"><a href="module-ElvClient_Files+Parts.html#.exports.UploadFilesFromS3" class="method-link">UploadFilesFromS3</a></li><h4 class="methodGroupHeader">Parts</h4><li data-type="method" id="ElvClient_Files+Parts-ContentPart-nav"><a href="module-ElvClient_Files+Parts.html#.exports.ContentPart" class="method-link">ContentPart</a></li><li data-type="method" id="ElvClient_Files+Parts-ContentParts-nav"><a href="module-ElvClient_Files+Parts.html#.exports.ContentParts" class="method-link">ContentParts</a></li><li data-type="method" id="ElvClient_Files+Parts-CreatePart-nav"><a href="module-ElvClient_Files+Parts.html#.exports.CreatePart" class="method-link">CreatePart</a></li><li data-type="method" id="ElvClient_Files+Parts-DeletePart-nav"><a href="module-ElvClient_Files+Parts.html#.exports.DeletePart" class="method-link">DeletePart</a></li><li data-type="method" id="ElvClient_Files+Parts-DownloadPart-nav"><a href="module-ElvClient_Files+Parts.html#.exports.DownloadPart" class="method-link">DownloadPart</a></li><li data-type="method" id="ElvClient_Files+Parts-FinalizePart-nav"><a href="module-ElvClient_Files+Parts.html#.exports.FinalizePart" class="method-link">FinalizePart</a></li><li data-type="method" id="ElvClient_Files+Parts-UploadPart-nav"><a href="module-ElvClient_Files+Parts.html#.exports.UploadPart" class="method-link">UploadPart</a></li><li data-type="method" id="ElvClient_Files+Parts-UploadPartChunk-nav"><a href="module-ElvClient_Files+Parts.html#.exports.UploadPartChunk" class="method-link">UploadPartChunk</a></li></ul></li><li id="ElvClient_LiveStream-nav">
          <div data-name="ElvClient/LiveStream" class="class-link-container"><a class="class-link">ElvClient/LiveStream</a></div><ul class='methods'><li data-type="method" id="ElvClient_LiveStream-ElvClient/LiveStream-nav"><a href="module-ElvClient_LiveStream.html" class="method-link">ElvClient/LiveStream</a></li><h4 class="methodGroupHeader">Live Stream</h4><li data-type="method" id="ElvClient_LiveStream-StreamConfig-nav"><a href="module-ElvClient_LiveStream.html#.StreamConfig" class="method-link">StreamConfig</a></li><li data-type="method" id="ElvClient_LiveStream-StreamCreate-nav"><a href="module-ElvClient_LiveStream.html#.StreamCreate" class="method-link">StreamCreate</a></li><li data-type="method" id="ElvClient_LiveStream-StreamStartOrStopOrReset-nav"><a href="module-ElvClient_LiveStream.html#.StreamStartOrStopOrReset" class="method-link">StreamStartOrStopOrReset</a></li><li data-type="method" id="ElvClient_LiveStream-StreamStatus-nav"><a href="module-ElvClient_LiveStream.html#.StreamStatus" class="method-link">StreamStatus</a></li></ul></li><li id="ElvClient_NFT-nav">
          <div data-name="ElvClient/NFT" class="class-link-container"><a class="class-link">ElvClient/NFT</a></div><ul class='methods'><li data-type="method" id="ElvClient_NFT-ElvClient/NFT-nav"><a href="module-ElvClient_NFT.html" class="method-link">ElvClient/NFT</a></li><h4 class="methodGroupHeader">Minting</h4><li data-type="method" id="ElvClient_NFT-MintNFT-nav"><a href="module-ElvClient_NFT.html#.MintNFT" class="method-link">MintNFT</a></li><h4 class="methodGroupHeader">Transactions</h4><li data-type="method" id="ElvClient_NFT-CollectionTransactions-nav"><a href="module-ElvClient_NFT.html#.CollectionTransactions" class="method-link">CollectionTransactions</a></li></ul></li><li id="ElvClient_NTP-nav">
          <div data-name="ElvClient/NTP" class="class-link-container"><a class="class-link">ElvClient/NTP</a></div><ul class='methods'><li data-type="method" id="ElvClient_NTP-ElvClient/NTP-nav"><a href="module-ElvClient_NTP.html" class="method-link">ElvClient/NTP</a></li><h4 class="methodGroupHeader">NTP Instances</h4><li data-type="method" id="ElvClient_NTP-CreateNTPInstance-nav"><a href="module-ElvClient_NTP.html#.CreateNTPInstance" class="method-link">CreateNTPInstance</a></li><li data-type="method" id="ElvClient_NTP-DeleteNTPInstance-nav"><a href="module-ElvClient_NTP.html#.DeleteNTPInstance" class="method-link">DeleteNTPInstance</a></li><li data-type="method" id="ElvClient_NTP-ListNTPInstances-nav"><a href="module-ElvClient_NTP.html#.ListNTPInstances" class="method-link">ListNTPInstances</a></li><li data-type="method" id="ElvClient_NTP-NTPInstance-nav"><a href="module-ElvClient_NTP.html#.NTPInstance" class="method-link">NTPInstance</a></li><li data-type="method" id="ElvClient_NTP-SuspendNTPInstance-nav"><a href="module-ElvClient_NTP.html#.SuspendNTPInstance" class="method-link">SuspendNTPInstance</a></li><li data-type="method" id="ElvClient_NTP-UpdateNTPInstance-nav"><a href="module-ElvClient_NTP.html#.UpdateNTPInstance" class="method-link">UpdateNTPInstance</a></li><h4 class="methodGroupHeader">Tickets</h4><li data-type="method" id="ElvClient_NTP-IssueNTPCode-nav"><a href="module-ElvClient_NTP.html#.IssueNTPCode" class="method-link">IssueNTPCode</a></li><li data-type="method" id="ElvClient_NTP-IssueSignedNTPCode-nav"><a href="module-ElvClient_NTP.html#.IssueSignedNTPCode" class="method-link">IssueSignedNTPCode</a></li><li data-type="method" id="ElvClient_NTP-RedeemCode-nav"><a href="module-ElvClient_NTP.html#.RedeemCode" class="method-link">RedeemCode</a></li></ul></li></ul><h3>Namespaces</h3><ul><li id="Crypto-nav">
          <div data-name="Crypto" class="class-link-container"><a class="class-link">Crypto</a></div><ul class='methods'><li data-type="method" id="Crypto-Crypto-nav"><a href="Crypto.html" class="method-link">Crypto</a></li><h4 class="methodGroupHeader">Methods</h4><li data-type="method" id="Crypto-Decrypt-nav"><a href="Crypto.html#.Decrypt" class="method-link">Decrypt</a></li><li data-type="method" id="Crypto-Encrypt-nav"><a href="Crypto.html#.Encrypt" class="method-link">Encrypt</a></li></ul></li><li id="Utils-nav">
          <div data-name="Utils" class="class-link-container"><a class="class-link">Utils</a></div><ul class='methods'><li data-type="method" id="Utils-Utils-nav"><a href="Utils.html" class="method-link">Utils</a></li><h4 class="methodGroupHeader">Methods</h4><li data-type="method" id="Utils-AddressToHash-nav"><a href="Utils.html#.AddressToHash" class="method-link">AddressToHash</a></li><li data-type="method" id="Utils-AddressToLibraryId-nav"><a href="Utils.html#.AddressToLibraryId" class="method-link">AddressToLibraryId</a></li><li data-type="method" id="Utils-AddressToNodeId-nav"><a href="Utils.html#.AddressToNodeId" class="method-link">AddressToNodeId</a></li><li data-type="method" id="Utils-AddressToObjectId-nav"><a href="Utils.html#.AddressToObjectId" class="method-link">AddressToObjectId</a></li><li data-type="method" id="Utils-AddressToSpaceId-nav"><a href="Utils.html#.AddressToSpaceId" class="method-link">AddressToSpaceId</a></li><li data-type="method" id="Utils-DecodeAuthorizationToken-nav"><a href="Utils.html#.DecodeAuthorizationToken" class="method-link">DecodeAuthorizationToken</a></li><li data-type="method" id="Utils-DecodeSignedToken-nav"><a href="Utils.html#.DecodeSignedToken" class="method-link">DecodeSignedToken</a></li><li data-type="method" id="Utils-DecodeVersionHash-nav"><a href="Utils.html#.DecodeVersionHash" class="method-link">DecodeVersionHash</a></li><li data-type="method" id="Utils-DecodeWriteToken-nav"><a href="Utils.html#.DecodeWriteToken" class="method-link">DecodeWriteToken</a></li><li data-type="method" id="Utils-EqualAddress-nav"><a href="Utils.html#.EqualAddress" class="method-link">EqualAddress</a></li><li data-type="method" id="Utils-EqualHash-nav"><a href="Utils.html#.EqualHash" class="method-link">EqualHash</a></li><li data-type="method" id="Utils-EtherToWei-nav"><a href="Utils.html#.EtherToWei" class="method-link">EtherToWei</a></li><li data-type="method" id="Utils-FormatAddress-nav"><a href="Utils.html#.FormatAddress" class="method-link">FormatAddress</a></li><li data-type="method" id="Utils-FormatSignature-nav"><a href="Utils.html#.FormatSignature" class="method-link">FormatSignature</a></li><li data-type="method" id="Utils-HashToAddress-nav"><a href="Utils.html#.HashToAddress" class="method-link">HashToAddress</a></li><li data-type="method" id="Utils-IsCloneable-nav"><a href="Utils.html#.IsCloneable" class="method-link">IsCloneable</a></li><li data-type="method" id="Utils-MakeClonable-nav"><a href="Utils.html#.MakeClonable" class="method-link">MakeClonable</a></li><li data-type="method" id="Utils-PublicKeyToAddress-nav"><a href="Utils.html#.PublicKeyToAddress" class="method-link">PublicKeyToAddress</a></li><li data-type="method" id="Utils-ResizeImage-nav"><a href="Utils.html#.ResizeImage" class="method-link">ResizeImage</a></li><li data-type="method" id="Utils-ToBigNumber-nav"><a href="Utils.html#.ToBigNumber" class="method-link">ToBigNumber</a></li><li data-type="method" id="Utils-ToBytes32-nav"><a href="Utils.html#.ToBytes32" class="method-link">ToBytes32</a></li><li data-type="method" id="Utils-ValidAddress-nav"><a href="Utils.html#.ValidAddress" class="method-link">ValidAddress</a></li><li data-type="method" id="Utils-ValidHash-nav"><a href="Utils.html#.ValidHash" class="method-link">ValidHash</a></li><li data-type="method" id="Utils-WeiToEther-nav"><a href="Utils.html#.WeiToEther" class="method-link">WeiToEther</a></li></ul></li></ul>
      </div>
    </nav>

    <div class="main">
      <div class="header"></div>
      <div class="main-content">
        
        <h1 class="page-title">
          client/Files.js
        </h1>
        

        
      

<a class="button" href="client_Files.html">Back</a>
<div class="source-container">
  <pre class="prettyprint source linenums"><code>/**
 * Methods for accessing and managing access groups
 *
 * @module ElvClient/Files+Parts
 */

const Utils = require("../Utils");

let fs;
if(Utils.Platform() === Utils.PLATFORM_NODE) {
  // Define Response in node
  // eslint-disable-next-line no-global-assign
  globalThis.Response = (require("node-fetch")).Response;
  fs = require("fs");
}

const UrlJoin = require("url-join");

const {
  ValidatePresence,
  ValidateWriteToken,
  ValidatePartHash,
  ValidateParameters
} = require("../Validation");


/* Files */

/**
 * List the file information about this object
 *
 * @memberof module:ElvClient/Files+Parts
 * @methodGroup Files
 * @namedParams
 * @param {string=} libraryId - ID of the library
 * @param {string=} objectId - ID of the object
 * @param {string=} versionHash - Hash of the object version - if not specified, most recent version will be used
 */
exports.ListFiles = async function({libraryId, objectId, versionHash}) {
  ValidateParameters({libraryId, objectId, versionHash});

  if(versionHash) { objectId = this.utils.DecodeVersionHash(versionHash).objectId; }

  let path = UrlJoin("q", versionHash || objectId, "meta", "files");

  return this.utils.ResponseToJson(
    this.HttpClient.Request({
      headers: await this.authClient.AuthorizationHeader({libraryId, objectId, versionHash}),
      method: "GET",
      path: path,
    })
  );
};

/**
 * Copy/reference files from S3 to a content object.
 *
 * S3 authentication is done by either providing an access key and secret or a presigned URL. The credentials will not be stored (neither in the client nor in the Fabric)
 *
 * NOTE: When providing a presigned URL instead of an access key + secret, the accessKey, secret, region and bucket parameters are not required.
 *
 * Expected format of fileInfo:
 *
     [
       {
         path: string,
         source: string // either a full path e.g. "s3://BUCKET_NAME/path..." or just the path part without "s3://BUCKET_NAME/"
       }
     ]
 *
 * @memberof module:ElvClient/Files+Parts
 * @methodGroup Files
 * @namedParams
 * @param {string} libraryId - ID of the library
 * @param {string} objectId - ID of the object
 * @param {string} writeToken - Write token of the draft
 * @param {string} region - AWS region to use
 * @param {string} bucket - AWS bucket to use
 * @param {Array&lt;Object>} fileInfo - List of files to reference/copy
 * @param {string} accessKey - AWS access key
 * @param {string} secret - AWS secret
 * @param {string=} signedUrl
 * @param {string} encryption="none" - Encryption for uploaded files (copy only) - cgck | none
 * @param {boolean} copy=false - If true, will copy the data from S3 into the fabric. Otherwise, a reference to the content will be made.
 * @param {function=} callback - If specified, will be periodically called with current upload status
 * - Arguments (copy): { done: boolean, uploaded: number, total: number, uploadedFiles: number, totalFiles: number, fileStatus: Object }
 * - Arguments (reference): { done: boolean, uploadedFiles: number, totalFiles: number }
 */
exports.UploadFilesFromS3 = async function({
  libraryId,
  objectId,
  writeToken,
  region,
  bucket,
  fileInfo,
  accessKey,
  secret,
  signedUrl,
  encryption="none",
  copy=false,
  callback
}) {
  ValidateParameters({libraryId, objectId});
  ValidateWriteToken(writeToken);

  const s3prefixRegex = /^s3:\/\/([^/]+)\//i; // for matching and extracting bucket name when full s3:// path is specified
  // if fileInfo source paths start with s3://bucketName/, check against bucket arg passed in, and strip
  for(let i = 0; i &lt; fileInfo.length; i++) {
    const fileSourcePath = fileInfo[i].source;
    const s3prefixMatch = (s3prefixRegex.exec(fileSourcePath));
    if(s3prefixMatch) {
      const bucketName = s3prefixMatch[1];
      if(bucketName !== bucket) {
        throw Error("Full S3 file path \"" + fileSourcePath + "\" specified, but does not match provided bucket name '" + bucket + "'");
      } else {
        // strip prefix
        fileInfo[i].source = fileSourcePath.replace(s3prefixRegex,"");
      }
    }
  }

  this.Log(`Uploading files from S3: ${libraryId} ${objectId} ${writeToken}`);

  let encryption_key;
  if(encryption === "cgck") {
    let conk = await this.EncryptionConk({
      libraryId,
      objectId,
      writeToken
    });

    conk = {
      ...conk,
      secret_key: ""
    };

    encryption_key = `kp__${this.utils.B58(Buffer.from(JSON.stringify(conk)))}`;
  }

  let cloudCredentials = {
    access_key_id: accessKey,
    secret_access_key: secret
  };

  if(signedUrl) {
    cloudCredentials = {
      signed_url: signedUrl
    };
  }

  const defaults = {
    encryption_key,
    access: {
      protocol: "s3",
      platform: "aws",
      path: bucket,
      storage_endpoint: {
        region
      },
      cloud_credentials: cloudCredentials
    }
  };

  const ops = fileInfo.map(info => {
    if(copy) {
      return {
        op: "ingest-copy",
        path: info.path,
        encryption: {
          scheme: encryption === "cgck" ? "cgck" : "none",
        },
        ingest: {
          type: "key",
          path: info.source,
        }
      };
    } else {
      return {
        op: "add-reference",
        path: info.path,
        reference: {
          type: "key",
          path: info.source,
        }
      };
    }
  });

  // eslint-disable-next-line no-unused-vars
  const {id} = await this.CreateFileUploadJob({libraryId, objectId, writeToken, ops, defaults});

  // eslint-disable-next-line no-constant-condition
  while(true) {
    await new Promise(resolve => setTimeout(resolve, 1000));

    const status = await this.UploadStatus({libraryId, objectId, writeToken, uploadId: id});

    if(status.errors &amp;&amp; status.errors.length > 1) {
      throw status.errors.join("\n");
    } else if(status.error) {
      this.Log(`S3 file upload failed:\n${JSON.stringify(status, null, 2)}`);
      throw status.error;
    } else if(status.status.toLowerCase() === "failed") {
      throw "File upload failed";
    }

    let done = false;
    if(copy) {
      done = status.ingest_copy.done;

      if(callback) {
        const progress = status.ingest_copy.progress;

        callback({
          done,
          uploaded: progress.bytes.completed,
          total: progress.bytes.total,
          uploadedFiles: progress.files.completed,
          totalFiles: progress.files.total,
          fileStatus: progress.files.details
        });
      }
    } else {
      done = status.add_reference.done;

      if(callback) {
        const progress = status.add_reference.progress;

        callback({
          done,
          uploadedFiles: progress.completed,
          totalFiles: progress.total,
        });
      }
    }

    if(done) { break; }
  }
};

/**
 * Upload files to a content object.
 *
 * Expected format of fileInfo:
 *
     [
         {
            path: string,
            mime_type: string,
            size: number,
            data: File | ArrayBuffer | Buffer | File Descriptor (Node)
          }
     ]
 *
 *
 * @memberof module:ElvClient/Files+Parts
 * @methodGroup Files
 * @namedParams
 * @param {string} libraryId - ID of the library
 * @param {string} objectId - ID of the object
 * @param {string} writeToken - Write token of the draft
 * @param {Array&lt;object>} fileInfo - List of files to upload, including their size, type, and contents
 * @param {string} encryption="none" - Encryption for uploaded files - cgck | none
 * @param {function=} callback - If specified, will be called after each job segment is finished with the current upload progress
 * - Format: {"filename1": {uploaded: number, total: number}, ...}
 */
exports.UploadFiles = async function({libraryId, objectId, writeToken, fileInfo, encryption="none", callback}) {
  ValidateParameters({libraryId, objectId});
  ValidateWriteToken(writeToken);
  ValidatePresence("fileInfo", fileInfo);

  this.Log(`Uploading files: ${libraryId} ${objectId} ${writeToken}`);

  let conk;
  if(encryption === "cgck") {
    conk = await this.EncryptionConk({libraryId, objectId, writeToken});
  }

  // Extract file data into easily accessible hash while removing the data from the fileinfo for upload job creation
  let progress = {};
  let fileDataMap = {};

  let originalFileInfo = fileInfo;
  fileInfo = [];
  for(let i = 0; i &lt; originalFileInfo.length; i++) {
    let entry = { ...originalFileInfo[i], data: undefined };

    entry.path = entry.path.replace(/^\/+/, "");

    if(encryption === "cgck") {
      entry.encryption = {
        scheme: "cgck"
      };
    }

    fileDataMap[entry.path] = originalFileInfo[i].data;

    entry.type = "file";

    progress[entry.path] = {
      uploaded: 0,
      total: entry.size
    };

    fileInfo.push(entry);
  }

  this.Log(fileInfo);

  if(callback) {
    callback(progress);
  }

  const {id, jobs} = await this.CreateFileUploadJob({
    libraryId,
    objectId,
    writeToken,
    ops: fileInfo,
    encryption
  });

  this.Log(`Upload ID: ${id}`);
  this.Log(jobs);

  // How far encryption can get ahead of upload
  const bufferSize = 500 * 1024 * 1024;

  let jobSpecs = [];
  let prepared = 0;
  let uploaded = 0;

  // Insert the data to upload into the job spec, encrypting if necessary
  const PrepareJobs = async () => {
    for(let j = 0; j &lt; jobs.length; j++) {
      while(prepared - uploaded > bufferSize) {
        // Wait for more data to be uploaded
        await new Promise(resolve => setTimeout(resolve, 500));
      }

      // Retrieve job info
      const jobId = jobs[j];
      let job = await this.UploadJobStatus({
        libraryId,
        objectId,
        writeToken,
        uploadId: id,
        jobId
      });

      for(let f = 0; f &lt; job.files.length; f++) {
        const fileInfo = job.files[f];

        let data;
        if(typeof fileDataMap[fileInfo.path] === "number") {
          // File descriptor - Read data from file
          data = Buffer.alloc(fileInfo.len);
          fs.readSync(fileDataMap[fileInfo.path], data, 0, fileInfo.len, fileInfo.off);
        } else {
          // Full data - Slice requested chunk
          data = fileDataMap[fileInfo.path].slice(fileInfo.off, fileInfo.off + fileInfo.len);
        }

        if(encryption === "cgck") {
          data = await this.Crypto.Encrypt(conk, data);
        }

        job.files[f].data = data;

        prepared += fileInfo.len;
      }

      jobSpecs[j] = job;

      // Wait for a bit to let upload start
      await new Promise(resolve => setTimeout(resolve, 50));
    }
  };

  const UploadJob = async (jobId, j)  => {
    while(!jobSpecs[j]) {
      // Wait for more jobs to be prepared
      await new Promise(resolve => setTimeout(resolve, 500));
    }

    const jobSpec = jobSpecs[j];
    const files = jobSpec.files;

    // Upload each item
    for(let f = 0; f &lt; files.length; f++) {
      const fileInfo = files[f];

      let retries = 0;
      let succeeded = false;
      do {
        try {
          await this.UploadFileData({
            libraryId,
            objectId,
            writeToken,
            uploadId: id,
            jobId,
            filePath: fileInfo.path,
            fileData: fileInfo.data,
            encryption
          });

          succeeded = true;
        } catch(error) {
          this.Log(error, true);

          retries += 1;

          if(retries >= 10) {
            throw error;
          }

          await new Promise(resolve => setTimeout(resolve, 10 * retries * 1000));
        }
      } while(!succeeded &amp;&amp; retries &lt; 10);

      delete jobSpecs[j].files[f].data;
      uploaded += fileInfo.len;

      if(callback) {
        progress[fileInfo.path] = {
          ...progress[fileInfo.path],
          uploaded: progress[fileInfo.path].uploaded + fileInfo.len
        };

        callback(progress);
      }
    }
  };

  // Preparing jobs is done asynchronously
  PrepareJobs().catch(e => {
    throw e;
  });

  // Upload the first several chunks in sequence, to determine average upload rate
  const rateTestJobs = Math.min(3, jobs.length);
  let rates = [];
  for(let j = 0; j &lt; rateTestJobs; j++) {
    const start = new Date().getTime();
    await UploadJob(jobs[j], j);
    const elapsed = (new Date().getTime() - start) / 1000;
    const size = jobSpecs[j].files.map(file => file.len).reduce((length, total) => length + total, 0);
    rates.push(size / elapsed / (1024 * 1024));
  }

  const averageRate = rates.reduce((mbps, total) => mbps + total, 0) / rateTestJobs;

  // Upload remaining jobs in parallel
  const concurrentUploads = Math.min(5, Math.ceil(averageRate / 2));
  await this.utils.LimitedMap(
    concurrentUploads,
    jobs,
    async (jobId, j)  => {
      if(j &lt; rateTestJobs) { return; }

      await UploadJob(jobId, j);
    }
  );
};

exports.CreateFileUploadJob = async function({libraryId, objectId, writeToken, ops, defaults={}, encryption="none"}) {
  ValidateParameters({libraryId, objectId});
  ValidateWriteToken(writeToken);

  this.Log(`Creating file upload job: ${libraryId} ${objectId} ${writeToken}`);
  this.Log(ops);

  if(encryption === "cgck") {
    defaults.encryption = { scheme: "cgck" };
  }

  const body = {
    seq: 0,
    seq_complete: true,
    defaults,
    ops
  };

  const path = UrlJoin("q", writeToken, "file_jobs");

  return this.utils.ResponseToJson(
    this.HttpClient.Request({
      headers: await this.authClient.AuthorizationHeader({libraryId, objectId, update: true, encryption}),
      method: "POST",
      path: path,
      body,
      allowFailover: false
    })
  );
};

exports.UploadStatus = async function({libraryId, objectId, writeToken, uploadId}) {
  ValidateParameters({libraryId, objectId});
  ValidateWriteToken(writeToken);

  const path = UrlJoin("q", writeToken, "file_jobs", uploadId);

  return this.utils.ResponseToJson(
    this.HttpClient.Request({
      headers: await this.authClient.AuthorizationHeader({libraryId, objectId, update: true}),
      method: "GET",
      path: path,
      allowFailover: false
    })
  );
};

exports.UploadJobStatus = async function({libraryId, objectId, writeToken, uploadId, jobId}) {
  ValidateParameters({libraryId, objectId});
  ValidateWriteToken(writeToken);

  const path = UrlJoin("q", writeToken, "file_jobs", uploadId, "uploads", jobId);

  let response = await this.utils.ResponseToJson(
    this.HttpClient.Request({
      headers: await this.authClient.AuthorizationHeader({libraryId, objectId, update: true}),
      method: "GET",
      path: path,
      allowFailover: false,
      queryParams: { start: 0, limit: 10000 }
    })
  );

  while(response.next !== response.total &amp;&amp; response.next >= 0) {
    const newResponse = await this.utils.ResponseToJson(
      this.HttpClient.Request({
        headers: await this.authClient.AuthorizationHeader({libraryId, objectId, update: true}),
        method: "GET",
        path: path,
        allowFailover: false,
        queryParams: { start: response.next }
      })
    );

    response.files = [
      ...response.files,
      ...newResponse.files
    ];
    response.next = newResponse.next;
  }

  return response;
};

exports.UploadFileData = async function({libraryId, objectId, writeToken, encryption, uploadId, jobId, filePath, fileData}) {
  ValidateParameters({libraryId, objectId});
  ValidateWriteToken(writeToken);

  const jobStatus = await this.UploadJobStatus({libraryId, objectId, writeToken, uploadId, jobId});

  // Find the status of this file
  let fileStatus = jobStatus.files.find(item => item.path == filePath);
  if(encryption &amp;&amp; encryption !== "none") {
    fileStatus = fileStatus.encrypted;
  }

  if(fileStatus.rem === 0) {
    // Job is actually done
    return;
  } else if(fileStatus.skip) {
    fileData = fileData.slice(fileStatus.skip);
  }

  let path = UrlJoin("q", writeToken, "file_jobs", uploadId, jobId);

  return await this.utils.ResponseToJson(
    this.HttpClient.Request({
      method: "POST",
      path: path,
      body: fileData,
      bodyType: "BINARY",
      headers: {
        "Content-type": "application/octet-stream",
        ...(await this.authClient.AuthorizationHeader({libraryId, objectId, update: true}))
      },
      allowFailover: false,
      allowRetry: false
    })
  );
};

exports.FinalizeUploadJob = async function({libraryId, objectId, writeToken}) {
  ValidateParameters({libraryId, objectId});
  ValidateWriteToken(writeToken);

  this.Log(`Finalizing upload job: ${libraryId} ${objectId} ${writeToken}`);

  const path = UrlJoin("q", writeToken, "files");

  await this.HttpClient.Request({
    method: "POST",
    path: path,
    bodyType: "BINARY",
    headers: await this.authClient.AuthorizationHeader({libraryId, objectId, update: true}),
    allowFailover: false
  });
};

/**
 * Create the specified directories on the specified object
 *
 * @memberof module:ElvClient/Files+Parts
 * @methodGroup Files
 * @namedParams
 * @param {string} libraryId - ID of the library
 * @param {string} objectId - ID of the object
 * @param {string} writeToken - Write token of the draft
 * @param {Array&lt;string>} filePaths - List of file paths to create
 */
exports.CreateFileDirectories = async function({libraryId, objectId, writeToken, filePaths}) {
  ValidateParameters({libraryId, objectId});
  ValidateWriteToken(writeToken);

  this.Log(`Creating Directories: ${libraryId} ${objectId} ${writeToken}`);
  this.Log(filePaths);

  const ops = filePaths.map(path => ({op: "add", type: "directory", path}));

  await this.CreateFileUploadJob({libraryId, objectId, writeToken, ops});
};

/**
 * Move or rename the specified list of files/directories
 *
 * @memberof module:ElvClient/Files+Parts
 * @methodGroup Files
 * @namedParams
 * @param {string} libraryId - ID of the library
 * @param {string} objectId - ID of the object
 * @param {string} writeToken - Write token of the draft
 * @param {Array&lt;string>} filePaths - List of file paths to move. Format: ```[ { "path": "original/path", to: "new/path" } ]```
 */
exports.MoveFiles = async function({libraryId, objectId, writeToken, filePaths}) {
  ValidateParameters({libraryId, objectId});
  ValidateWriteToken(writeToken);

  this.Log(`Moving Files: ${libraryId} ${objectId} ${writeToken}`);
  this.Log(filePaths);

  const ops = filePaths.map(({path, to}) => ({op: "move", copy_move_source_path: path, path: to}));

  await this.CreateFileUploadJob({libraryId, objectId, writeToken, ops});
};

/**
 * Delete the specified list of files/directories
 *
 * @memberof module:ElvClient/Files+Parts
 * @methodGroup Files
 * @namedParams
 * @param {string} libraryId - ID of the library
 * @param {string} objectId - ID of the object
 * @param {string} writeToken - Write token of the draft
 * @param {Array&lt;string>} filePaths - List of file paths to delete
 */
exports.DeleteFiles = async function({libraryId, objectId, writeToken, filePaths}) {
  ValidateParameters({libraryId, objectId});
  ValidateWriteToken(writeToken);

  this.Log(`Deleting Files: ${libraryId} ${objectId} ${writeToken}`);
  this.Log(filePaths);

  const ops = filePaths.map(path => ({op: "del", path}));

  await this.CreateFileUploadJob({libraryId, objectId, writeToken, ops});
};

/**
 * Download a file from a content object
 *
 * @memberof module:ElvClient/Files+Parts
 * @methodGroup Files
 * @namedParams
 * @param {string=} libraryId - ID of the library
 * @param {string=} objectId - ID of the object
 * @param {string=} versionHash - Hash of the object version - if not specified, latest version will be used
 * @param {string=} writeToken - Write token for the draft from which to download the file
 * @param {string} filePath - Path to the file to download
 * @param {string=} format="arrayBuffer" - Format in which to return the data ("blob" | "arraybuffer" | "buffer")
 * @param {boolean=} chunked=false - If specified, file will be downloaded and decrypted in chunks. The
 * specified callback will be invoked on completion of each chunk. This is recommended for large files.
 * @param {number=} chunkSize=1000000 - Size of file chunks to request for download
 * - NOTE: If the file is encrypted, the size of the chunks returned via the callback function will not be affected by this value
 * @param {boolean=} clientSideDecryption=false - If specified, decryption of the file (if necessary) will be done by the client
 * instead of on the fabric node
 * @param {function=} callback - If specified, will be periodically called with current download status - Required if `chunked` is true
 * - Signature: ({bytesFinished, bytesTotal}) => {}
 * - Signature (chunked): ({bytesFinished, bytesTotal, chunk}) => {}
 *
 * @returns {Promise&lt;ArrayBuffer> | undefined} - No return if chunked is specified, file data in the requested format otherwise
 */
exports.DownloadFile = async function({
  libraryId,
  objectId,
  versionHash,
  writeToken,
  filePath,
  format="arrayBuffer",
  chunked=false,
  chunkSize,
  clientSideDecryption=false,
  callback
}) {
  ValidateParameters({libraryId, objectId, versionHash});
  ValidatePresence("filePath", filePath);

  if(versionHash) { objectId = this.utils.DecodeVersionHash(versionHash).objectId; }

  const fileInfo = await this.ContentObjectMetadata({
    libraryId,
    objectId,
    versionHash,
    writeToken,
    metadataSubtree: UrlJoin("files", filePath)
  });

  const encrypted = fileInfo &amp;&amp; fileInfo["."].encryption &amp;&amp; fileInfo["."].encryption.scheme === "cgck";
  const encryption = encrypted ? "cgck" : undefined;

  const path =
    encrypted &amp;&amp; !clientSideDecryption ?
      UrlJoin("q", writeToken || versionHash || objectId, "rep", "files_download", filePath) :
      UrlJoin("q", writeToken || versionHash || objectId, "files", filePath);


  const headers = await this.authClient.AuthorizationHeader({libraryId, objectId, versionHash, encryption, makeAccessRequest: encryption === "cgck"});
  headers.Accept = "*/*";

  // If not owner, indicate re-encryption
  const ownerCapKey = `eluv.caps.iusr${this.utils.AddressToHash(this.signer.address)}`;
  const ownerCap = await this.ContentObjectMetadata({libraryId, objectId, versionHash, metadataSubtree: ownerCapKey});

  if(encrypted &amp;&amp; !this.utils.EqualAddress(this.signer.address, await this.ContentObjectOwner({objectId})) &amp;&amp; !ownerCap) {
    headers["X-Content-Fabric-Decryption-Mode"] = "reencrypt";
  }

  // If using server side decryption, specify in header
  if(encrypted &amp;&amp; !clientSideDecryption) {
    headers["X-Content-Fabric-Decryption-Mode"] = "decrypt";
    // rep/files_download endpoint doesn't currently support Range header
    chunkSize = Number.MAX_SAFE_INTEGER;
  }

  const bytesTotal = fileInfo["."].size;

  if(encrypted &amp;&amp; clientSideDecryption) {
    return await this.DownloadEncrypted({
      conk: await this.EncryptionConk({libraryId, objectId, versionHash, download: true}),
      downloadPath: path,
      bytesTotal,
      headers,
      callback,
      format,
      clientSideDecryption,
      chunked
    });
  } else {
    if(!chunkSize) {
      chunkSize = 10000000;
    }

    try {
      return await this.Download({
        downloadPath: path,
        bytesTotal,
        headers,
        callback,
        format,
        chunked,
        chunkSize
      });
    } catch(error) {
      if(encrypted &amp;&amp; !clientSideDecryption) {
        // If encrypted download with rep/files_download failed, retry with client side decryption
        return (
          this.DownloadFile({
            ...arguments[0],
            clientSideDecryption: true
          })
        );
      }

      throw error;
    }
  }
};

/* Parts */

/**
 * List content object parts
 *
 * @memberof module:ElvClient/Files+Parts
 * @methodGroup Parts
 * @namedParams
 * @param {string=} libraryId - ID of the library
 * @param {string=} objectId - ID of the object
 * @param {string=} versionHash - Hash of the object version - if not specified, latest version will be used
 *
 * @returns {Promise&lt;Object>} - Response containing list of parts of the object
 */
exports.ContentParts = async function({libraryId, objectId, versionHash}) {
  ValidateParameters({libraryId, objectId, versionHash});

  this.Log(`Retrieving parts: ${libraryId} ${objectId || versionHash}`);

  if(versionHash) { objectId = this.utils.DecodeVersionHash(versionHash).objectId; }

  const path = UrlJoin("q", versionHash || objectId, "parts");

  const response = await this.utils.ResponseToJson(
    this.HttpClient.Request({
      headers: await this.authClient.AuthorizationHeader({libraryId, objectId, versionHash}),
      method: "GET",
      path: path
    })
  );

  return response.parts;
};

/**
 * Get information on a specific part
 *
 * @memberof module:ElvClient/Files+Parts
 * @methodGroup Parts
 * @namedParams
 * @param {string=} libraryId - ID of the library
 * @param {string=} objectId - ID of the object
 * @param {string=} versionHash - Hash of the object version - if not specified, latest version will be used
 * @param {string} partHash - Hash of the part to retrieve
 *
 * @returns {Promise&lt;Object>} - Response containing information about the specified part
 */
exports.ContentPart = async function({libraryId, objectId, versionHash, partHash}) {
  ValidateParameters({libraryId, objectId, versionHash});
  ValidatePartHash(partHash);

  this.Log(`Retrieving part: ${libraryId} ${objectId || versionHash} ${partHash}`);

  if(versionHash) { objectId = this.utils.DecodeVersionHash(versionHash).objectId; }

  let path = UrlJoin("q", versionHash || objectId, "parts", partHash);

  return await this.utils.ResponseToJson(
    this.HttpClient.Request({
      headers: await this.authClient.AuthorizationHeader({libraryId, objectId, versionHash}),
      method: "GET",
      path: path
    })
  );
};

/**
 * Download a part from a content object. The fromByte and range parameters can be used to specify a
 * specific section of the part to download.
 *
 * @memberof module:ElvClient/Files+Parts
 * @methodGroup Parts
 * @namedParams
 * @param {string=} libraryId - ID of the library
 * @param {string=} objectId - ID of the object
 * @param {string=} versionHash - Hash of the object version - if not specified, latest version will be used
 * @param {string=} writeToken - Write token for the draft from which to download the part
 * @param {string} partHash - Hash of the part to download
 * @param {string=} format="arrayBuffer" - Format in which to return the data ("blob" | "arraybuffer" | "buffer)
 * @param {boolean=} chunked=false - If specified, part will be downloaded and decrypted in chunks. The
 * specified callback will be invoked on completion of each chunk. This is recommended for large files,
 * especially if they are encrypted.
 * @param {number=} chunkSize=1000000 - Size of file chunks to request for download
 * - NOTE: If the file is encrypted, the size of the chunks returned via the callback function will not be affected by this value
 * @param {function=} callback - If specified, will be periodically called with current download status - Required if `chunked` is true
 * - Signature: ({bytesFinished, bytesTotal}) => {}
 * - Signature (chunked): ({bytesFinished, bytesTotal, chunk}) => {}
 *
 * @returns {Promise&lt;ArrayBuffer> | undefined} - No return if chunked is specified, part data in the requested format otherwise
 */
exports.DownloadPart = async function({
  libraryId,
  objectId,
  versionHash,
  writeToken,
  partHash,
  format="arrayBuffer",
  chunked=false,
  chunkSize=10000000,
  callback
}) {
  ValidateParameters({libraryId, objectId, versionHash});
  ValidatePartHash(partHash);

  if(versionHash) { objectId = this.utils.DecodeVersionHash(versionHash).objectId; }

  const encrypted = partHash.startsWith("hqpe");
  const encryption = encrypted ? "cgck" : undefined;
  const path = UrlJoin("q", writeToken || versionHash || objectId, "data", partHash);

  let headers = await this.authClient.AuthorizationHeader({libraryId, objectId, versionHash, encryption, makeAccessRequest: true});

  const bytesTotal = (await this.ContentPart({libraryId, objectId, versionHash, partHash})).part.size;

  if(encrypted) {
    // If not owner, indicate re-encryption
    if(!this.utils.EqualAddress(this.signer.address, await this.ContentObjectOwner({objectId}))) {
      headers["X-Content-Fabric-Decryption-Mode"] = "reencrypt";
    }

    return await this.DownloadEncrypted({
      conk: await this.EncryptionConk({libraryId, objectId, download: true}),
      downloadPath: path,
      bytesTotal,
      headers,
      callback,
      format,
      chunked
    });
  } else {
    return await this.Download({
      downloadPath: path,
      bytesTotal,
      headers,
      callback,
      format,
      chunked,
      chunkSize
    });
  }
};

exports.Download = async function({
  downloadPath,
  headers,
  bytesTotal,
  chunked=false,
  chunkSize=2000000,
  callback,
  format="arrayBuffer"
}) {
  if(chunked &amp;&amp; !callback) { throw Error("No callback specified for chunked download"); }

  // Non-chunked file is still downloaded in parts, but assembled into a full file by the client
  // instead of being returned in chunks via callback
  let outputChunks;
  if(!chunked) {
    outputChunks = [];
  }

  // Download file in chunks
  let bytesFinished = 0;
  const totalChunks = Math.ceil(bytesTotal / chunkSize);
  for(let i = 0; i &lt; totalChunks; i++) {
    headers["Range"] = `bytes=${bytesFinished}-${bytesFinished + chunkSize - 1}`;
    const response = await this.HttpClient.Request({path: downloadPath, headers, method: "GET"});

    bytesFinished = Math.min(bytesFinished + chunkSize, bytesTotal);

    if(chunked) {
      callback({bytesFinished, bytesTotal, chunk: await this.utils.ResponseToFormat(format, response)});
    } else {
      outputChunks.push(
        Buffer.from(await response.arrayBuffer())
      );

      if(callback) {
        callback({bytesFinished, bytesTotal});
      }
    }
  }

  if(!chunked) {
    return await this.utils.ResponseToFormat(
      format,
      new Response(Buffer.concat(outputChunks))
    );
  }
};

exports.DownloadEncrypted = async function({
  conk,
  downloadPath,
  bytesTotal,
  headers,
  callback,
  format="arrayBuffer",
  chunked=false
}) {
  if(chunked &amp;&amp; !callback) { throw Error("No callback specified for chunked download"); }

  // Must align chunk size with encryption block size
  const isReencryption = conk.public_key.startsWith("ktpk");
  const chunkSize = this.Crypto.EncryptedBlockSize(1000000, isReencryption);

  let bytesFinished = 0;
  format = format.toLowerCase();

  let outputChunks = [];

  // Set up decryption stream
  const stream = await this.Crypto.OpenDecryptionStream(conk);
  stream.on("data", async chunk => {
    if(chunked) {
      // Turn buffer into desired format, if necessary
      if(format !== "buffer") {
        const arrayBuffer = chunk.buffer.slice(chunk.byteOffset, chunk.byteOffset + chunk.byteLength);

        if(format === "arraybuffer") {
          chunk = arrayBuffer;
        } else {
          chunk = await this.utils.ResponseToFormat(
            format,
            new Response(arrayBuffer)
          );
        }
      }

      callback({
        bytesFinished,
        bytesTotal,
        chunk
      });
    } else {
      if(callback) {
        callback({
          bytesFinished,
          bytesTotal
        });
      }

      outputChunks.push(chunk);
    }
  });

  const totalChunks = Math.ceil(bytesTotal / chunkSize);
  for(let i = 0; i &lt; totalChunks; i++) {
    headers["Range"] = `bytes=${bytesFinished}-${bytesFinished + chunkSize - 1}`;
    const response = await this.HttpClient.Request({headers, method: "GET", path: downloadPath});

    bytesFinished = Math.min(bytesFinished + chunkSize, bytesTotal);

    stream.write(new Uint8Array(await response.arrayBuffer()));
  }

  // Wait for decryption to complete
  stream.end();
  await new Promise(resolve =>
    stream.on("finish", () => {
      resolve();
    })
  );

  if(!chunked) {
    return await this.utils.ResponseToFormat(format, new Response(Buffer.concat(outputChunks)));
  }
};

/**
 * Create a part upload draft
 *
 * @memberof module:ElvClient/Files+Parts
 * @methodGroup Parts
 * @namedParams
 * @param {string} libraryId - ID of the library
 * @param {string} objectId - ID of the object
 * @param {string} writeToken - Write token of the content object draft
 * @param {string=} encryption=none - Desired encryption scheme. Options: 'none' (default), 'cgck'
 *
 * @returns {Promise&lt;string>} - The part write token for the part draft
 */
exports.CreatePart = async function({libraryId, objectId, writeToken, encryption}) {
  ValidateParameters({libraryId, objectId});
  ValidateWriteToken(writeToken);

  const path = UrlJoin("q", writeToken, "parts");

  const openResponse = await this.utils.ResponseToJson(
    this.HttpClient.Request({
      headers: await this.authClient.AuthorizationHeader({libraryId, objectId, update: true, encryption}),
      method: "POST",
      path,
      bodyType: "BINARY",
      body: "",
      allowFailover: false
    })
  );

  return openResponse.part.write_token;
};

/**
 * Upload data to an open part draft
 *
 * @memberof module:ElvClient/Files+Parts
 * @methodGroup Parts
 * @namedParams
 * @param {string} libraryId - ID of the library
 * @param {string} objectId - ID of the object
 * @param {string} writeToken - Write token of the content object draft
 * @param {string} partWriteToken - Write token of the part
 * @param {(ArrayBuffer | Buffer)} chunk - Data to upload
 * @param {string=} encryption=none - Desired encryption scheme. Options: 'none' (default), 'cgck'
 *
 * @returns {Promise&lt;string>} - The part write token for the part draft
 */
exports.UploadPartChunk = async function({libraryId, objectId, writeToken, partWriteToken, chunk, encryption}) {
  ValidateParameters({libraryId, objectId});
  ValidateWriteToken(writeToken);

  if(encryption &amp;&amp; encryption !== "none") {
    const conk = await this.EncryptionConk({libraryId, objectId, writeToken});
    chunk = await this.Crypto.Encrypt(conk, chunk);
  }

  const path = UrlJoin("q", writeToken, "parts");
  await this.utils.ResponseToJson(
    this.HttpClient.Request({
      headers: await this.authClient.AuthorizationHeader({libraryId, objectId, update: true, encryption}),
      method: "POST",
      path: UrlJoin(path, partWriteToken),
      body: chunk,
      bodyType: "BINARY",
      allowFailover: false
    })
  );
};

/**
 * Finalize an open part draft
 *
 * @memberof module:ElvClient/Files+Parts
 * @methodGroup Parts
 * @namedParams
 * @param {string} libraryId - ID of the library
 * @param {string} objectId - ID of the object
 * @param {string} writeToken - Write token of the content object draft
 * @param {string} partWriteToken - Write token of the part
 * @param {string=} encryption=none - Desired encryption scheme. Options: 'none' (default), 'cgck'
 *
 * @returns {Promise&lt;object>} - The finalize response for the new part
 */
exports.FinalizePart = async function({libraryId, objectId, writeToken, partWriteToken, encryption}) {
  ValidateParameters({libraryId, objectId});
  ValidateWriteToken(writeToken);

  const path = UrlJoin("q", writeToken, "parts");
  return await this.utils.ResponseToJson(
    await this.HttpClient.Request({
      headers: await this.authClient.AuthorizationHeader({libraryId, objectId, update: true, encryption}),
      method: "POST",
      path: UrlJoin(path, partWriteToken),
      bodyType: "BINARY",
      body: "",
      allowFailover: false
    })
  );
};

/**
 * Upload part to an object draft
 *
 * Note: If uploading a large file (especially with an HTML file and/or when using the FrameClient) it is
 * recommended to use the CreatePart + UploadPartChunk + FinalizePart flow to upload the file in
 * smaller chunks.
 *
 * @memberof module:ElvClient/Files+Parts
 * @methodGroup Parts
 * @namedParams
 * @param {string} libraryId - ID of the library
 * @param {string} objectId - ID of the object
 * @param {string} writeToken - Write token of the content object draft
 * @param {(File | ArrayBuffer | Buffer)} data - Data to upload
 * @param {number=} chunkSize=1000000 (1MB) - Chunk size, in bytes
 * @param {string=} encryption=none - Desired encryption scheme. Options: 'none' (default), 'cgck'
 * @param {function=} callback - If specified, will be periodically called with current upload status
 * - Signature: ({bytesFinished, bytesTotal}) => {}
 *
 * @returns {Promise&lt;Object>} - Response containing information about the uploaded part
 */
exports.UploadPart = async function({libraryId, objectId, writeToken, data, encryption="none", chunkSize=10000000, callback}) {
  ValidateParameters({libraryId, objectId});
  ValidateWriteToken(writeToken);

  const partWriteToken = await this.CreatePart({libraryId, objectId, writeToken, encryption});

  const size = data.length || data.byteLength || data.size;

  if(callback) {
    callback({bytesFinished: 0, bytesTotal: size});
  }

  for(let i = 0; i &lt; size; i += chunkSize) {
    const chunk = data.slice(i, i + chunkSize);
    await this.UploadPartChunk({
      libraryId,
      objectId,
      writeToken,
      partWriteToken,
      chunk,
      encryption
    });

    if(callback) {
      callback({bytesFinished: Math.min(i + chunkSize, size), bytesTotal: size});
    }
  }

  return await this.FinalizePart({libraryId, objectId, writeToken, partWriteToken, encryption});
};

/**
 * Delete the specified part from a content draft
 *
 * @memberof module:ElvClient/Files+Parts
 * @methodGroup Parts
 * @namedParams
 * @param {string} libraryId - ID of the library
 * @param {string} objectId - ID of the object
 * @param {string} writeToken - Write token of the content object draft
 * @param {string} partHash - Hash of the part to delete
 */
exports.DeletePart = async function({libraryId, objectId, writeToken, partHash}) {
  ValidateParameters({libraryId, objectId});
  ValidateWriteToken(writeToken);
  ValidatePartHash(partHash);

  let path = UrlJoin("q", writeToken, "parts", partHash);

  await this.HttpClient.Request({
    headers: await this.authClient.AuthorizationHeader({libraryId, objectId, update: true}),
    method: "DELETE",
    path: path,
    allowFailover: false
  });
};
</code></pre>
</div>

    



        <footer class="footer">
          Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.2</a>
        </footer>
      </div>
    </div>
  </div>

  <script>
    // Format and add line numbers to code
    prettyPrint();
  </script>

  <script type="text/javascript" src="scripts/utils.js"></script>

  </body>
</html>
