

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="shortcut icon" href="images/favicon.png" >

  <title>
    ClientMethods.js - Documentation
  </title>

  <script src="scripts/prettify/prettify.js"></script>
  <script src="scripts/prettify/lang-css.js"></script>

  <link type="text/css" rel="stylesheet" href="styles/elv-jsdoc.css">
  <link type="text/css" rel="stylesheet" href="styles/elv-prettify-jsdoc.css">
</head>

<body>
  <div class="layout-container">
    <nav class="nav-container">
      <div class="header">
        <a href="index.html">
          <img class="logo" src="images/logo-dark.png" />
        </a>
        <div class="title">
          Eluvio Wallet Client
        </div>
      </div>
      <div class="nav-content">
        <h3>Classes</h3><ul><li id="ElvWalletClient-nav">
          <div data-name="ElvWalletClient" class="class-link-container"><a class="class-link">ElvWalletClient</a></div><ul class='methods'><h4 class="methodGroupHeader">Constructor</h4><li data-type="method" id="ElvWalletClient-ElvWalletClient-nav"><a href="ElvWalletClient.html" class="method-link">ElvWalletClient</a></li><h4 class="methodGroupHeader">Authorization</h4><li data-type="method" id="ElvWalletClient-Authenticate-nav"><a href="ElvWalletClient.html#Authenticate" class="method-link">Authenticate</a></li><li data-type="method" id="ElvWalletClient-AuthenticateExternalWallet-nav"><a href="ElvWalletClient.html#AuthenticateExternalWallet" class="method-link">AuthenticateExternalWallet</a></li><li data-type="method" id="ElvWalletClient-AuthenticateOAuth-nav"><a href="ElvWalletClient.html#AuthenticateOAuth" class="method-link">AuthenticateOAuth</a></li><h4 class="methodGroupHeader">Initialization</h4><li data-type="method" id="ElvWalletClient-Initialize-nav"><a href="ElvWalletClient.html#.Initialize" class="method-link">Initialize</a></li><h4 class="methodGroupHeader">Login</h4><li data-type="method" id="ElvWalletClient-LogIn-nav"><a href="ElvWalletClient.html#LogIn" class="method-link">LogIn</a></li><li data-type="method" id="ElvWalletClient-LogOut-nav"><a href="ElvWalletClient.html#LogOut" class="method-link">LogOut</a></li><h4 class="methodGroupHeader">Signatures</h4><li data-type="method" id="ElvWalletClient-CanSign-nav"><a href="ElvWalletClient.html#CanSign" class="method-link">CanSign</a></li><li data-type="method" id="ElvWalletClient-PersonalSign-nav"><a href="ElvWalletClient.html#PersonalSign" class="method-link">PersonalSign</a></li><h4 class="methodGroupHeader">Methods</h4><li data-type="method" id="ElvWalletClient-ClientAuthToken-nav"><a href="ElvWalletClient.html#ClientAuthToken" class="method-link">ClientAuthToken</a></li></ul></li></ul><h3>Modules</h3><ul><li id="ClientMethods-nav">
          <div data-name="ClientMethods" class="class-link-container"><a class="class-link">ClientMethods</a></div><ul class='methods'><li data-type="method" id="ClientMethods-ClientMethods-nav"><a href="module-ClientMethods.html" class="method-link">ClientMethods</a></li><h4 class="methodGroupHeader">Leaderboard</h4><li data-type="method" id="ClientMethods-Leaderboard-nav"><a href="module-ClientMethods.html#.Leaderboard" class="method-link">Leaderboard</a></li><h4 class="methodGroupHeader">Listings</h4><li data-type="method" id="ClientMethods-CreateListing-nav"><a href="module-ClientMethods.html#.CreateListing" class="method-link">CreateListing</a></li><li data-type="method" id="ClientMethods-Listing-nav"><a href="module-ClientMethods.html#.Listing" class="method-link">Listing</a></li><li data-type="method" id="ClientMethods-ListingAttributes-nav"><a href="module-ClientMethods.html#.ListingAttributes" class="method-link">ListingAttributes</a></li><li data-type="method" id="ClientMethods-ListingEditionNames-nav"><a href="module-ClientMethods.html#.ListingEditionNames" class="method-link">ListingEditionNames</a></li><li data-type="method" id="ClientMethods-ListingNames-nav"><a href="module-ClientMethods.html#.ListingNames" class="method-link">ListingNames</a></li><li data-type="method" id="ClientMethods-ListingStats-nav"><a href="module-ClientMethods.html#.ListingStats" class="method-link">ListingStats</a></li><li data-type="method" id="ClientMethods-ListingStatus-nav"><a href="module-ClientMethods.html#.ListingStatus" class="method-link">ListingStatus</a></li><li data-type="method" id="ClientMethods-Listings-nav"><a href="module-ClientMethods.html#.Listings" class="method-link">Listings</a></li><li data-type="method" id="ClientMethods-RemoveListing-nav"><a href="module-ClientMethods.html#.RemoveListing" class="method-link">RemoveListing</a></li><li data-type="method" id="ClientMethods-Sales-nav"><a href="module-ClientMethods.html#.Sales" class="method-link">Sales</a></li><li data-type="method" id="ClientMethods-SalesNames-nav"><a href="module-ClientMethods.html#.SalesNames" class="method-link">SalesNames</a></li><li data-type="method" id="ClientMethods-SalesStats-nav"><a href="module-ClientMethods.html#.SalesStats" class="method-link">SalesStats</a></li><li data-type="method" id="ClientMethods-Transfers-nav"><a href="module-ClientMethods.html#.Transfers" class="method-link">Transfers</a></li><h4 class="methodGroupHeader">Marketplaces</h4><li data-type="method" id="ClientMethods-AvailableMarketplaces-nav"><a href="module-ClientMethods.html#.AvailableMarketplaces" class="method-link">AvailableMarketplaces</a></li><li data-type="method" id="ClientMethods-Marketplace-nav"><a href="module-ClientMethods.html#.Marketplace" class="method-link">Marketplace</a></li><li data-type="method" id="ClientMethods-MarketplaceCSS-nav"><a href="module-ClientMethods.html#.MarketplaceCSS" class="method-link">MarketplaceCSS</a></li><li data-type="method" id="ClientMethods-MarketplaceInfo-nav"><a href="module-ClientMethods.html#.MarketplaceInfo" class="method-link">MarketplaceInfo</a></li><li data-type="method" id="ClientMethods-MarketplaceStock-nav"><a href="module-ClientMethods.html#.MarketplaceStock" class="method-link">MarketplaceStock</a></li><h4 class="methodGroupHeader">NFTs</h4><li data-type="method" id="ClientMethods-NFT-nav"><a href="module-ClientMethods.html#.NFT" class="method-link">NFT</a></li><li data-type="method" id="ClientMethods-NFTContractStats-nav"><a href="module-ClientMethods.html#.NFTContractStats" class="method-link">NFTContractStats</a></li><li data-type="method" id="ClientMethods-TransferNFT-nav"><a href="module-ClientMethods.html#.TransferNFT" class="method-link">TransferNFT</a></li><h4 class="methodGroupHeader">Offers</h4><li data-type="method" id="ClientMethods-AcceptMarketplaceOffer-nav"><a href="module-ClientMethods.html#.AcceptMarketplaceOffer" class="method-link">AcceptMarketplaceOffer</a></li><li data-type="method" id="ClientMethods-CreateMarketplaceOffer-nav"><a href="module-ClientMethods.html#.CreateMarketplaceOffer" class="method-link">CreateMarketplaceOffer</a></li><li data-type="method" id="ClientMethods-MarketplaceOffers-nav"><a href="module-ClientMethods.html#.MarketplaceOffers" class="method-link">MarketplaceOffers</a></li><li data-type="method" id="ClientMethods-RejectMarketplaceOffer-nav"><a href="module-ClientMethods.html#.RejectMarketplaceOffer" class="method-link">RejectMarketplaceOffer</a></li><li data-type="method" id="ClientMethods-RemoveMarketplaceOffer-nav"><a href="module-ClientMethods.html#.RemoveMarketplaceOffer" class="method-link">RemoveMarketplaceOffer</a></li><h4 class="methodGroupHeader">Purchase</h4><li data-type="method" id="ClientMethods-ClaimItem-nav"><a href="module-ClientMethods.html#.ClaimItem" class="method-link">ClaimItem</a></li><li data-type="method" id="ClientMethods-PurchaseItem-nav"><a href="module-ClientMethods.html#.PurchaseItem" class="method-link">PurchaseItem</a></li><li data-type="method" id="ClientMethods-PurchaseListing-nav"><a href="module-ClientMethods.html#.PurchaseListing" class="method-link">PurchaseListing</a></li><h4 class="methodGroupHeader">Status</h4><li data-type="method" id="ClientMethods-ClaimStatus-nav"><a href="module-ClientMethods.html#.ClaimStatus" class="method-link">ClaimStatus</a></li><li data-type="method" id="ClientMethods-CollectionRedemptionStatus-nav"><a href="module-ClientMethods.html#.CollectionRedemptionStatus" class="method-link">CollectionRedemptionStatus</a></li><li data-type="method" id="ClientMethods-ListingPurchaseStatus-nav"><a href="module-ClientMethods.html#.ListingPurchaseStatus" class="method-link">ListingPurchaseStatus</a></li><li data-type="method" id="ClientMethods-PackOpenStatus-nav"><a href="module-ClientMethods.html#.PackOpenStatus" class="method-link">PackOpenStatus</a></li><li data-type="method" id="ClientMethods-PurchaseStatus-nav"><a href="module-ClientMethods.html#.PurchaseStatus" class="method-link">PurchaseStatus</a></li><li data-type="method" id="ClientMethods-RedeemableOfferStatus-nav"><a href="module-ClientMethods.html#.RedeemableOfferStatus" class="method-link">RedeemableOfferStatus</a></li><h4 class="methodGroupHeader">Tenants</h4><li data-type="method" id="ClientMethods-ExchangeRate-nav"><a href="module-ClientMethods.html#.ExchangeRate" class="method-link">ExchangeRate</a></li><li data-type="method" id="ClientMethods-TenantCSS-nav"><a href="module-ClientMethods.html#.TenantCSS" class="method-link">TenantCSS</a></li><li data-type="method" id="ClientMethods-TenantConfiguration-nav"><a href="module-ClientMethods.html#.TenantConfiguration" class="method-link">TenantConfiguration</a></li><h4 class="methodGroupHeader">User</h4><li data-type="method" id="ClientMethods-UserAddress-nav"><a href="module-ClientMethods.html#.UserAddress" class="method-link">UserAddress</a></li><li data-type="method" id="ClientMethods-UserInfo-nav"><a href="module-ClientMethods.html#.UserInfo" class="method-link">UserInfo</a></li><li data-type="method" id="ClientMethods-UserItemAttributes-nav"><a href="module-ClientMethods.html#.UserItemAttributes" class="method-link">UserItemAttributes</a></li><li data-type="method" id="ClientMethods-UserItemEditionNames-nav"><a href="module-ClientMethods.html#.UserItemEditionNames" class="method-link">UserItemEditionNames</a></li><li data-type="method" id="ClientMethods-UserItemNames-nav"><a href="module-ClientMethods.html#.UserItemNames" class="method-link">UserItemNames</a></li><li data-type="method" id="ClientMethods-UserItems-nav"><a href="module-ClientMethods.html#.UserItems" class="method-link">UserItems</a></li><li data-type="method" id="ClientMethods-UserListings-nav"><a href="module-ClientMethods.html#.UserListings" class="method-link">UserListings</a></li><li data-type="method" id="ClientMethods-UserSales-nav"><a href="module-ClientMethods.html#.UserSales" class="method-link">UserSales</a></li><li data-type="method" id="ClientMethods-UserTransfers-nav"><a href="module-ClientMethods.html#.UserTransfers" class="method-link">UserTransfers</a></li><li data-type="method" id="ClientMethods-UserWalletBalance-nav"><a href="module-ClientMethods.html#.UserWalletBalance" class="method-link">UserWalletBalance</a></li><h4 class="methodGroupHeader">Voting</h4><li data-type="method" id="ClientMethods-CastVote-nav"><a href="module-ClientMethods.html#.CastVote" class="method-link">CastVote</a></li><li data-type="method" id="ClientMethods-RevokeVote-nav"><a href="module-ClientMethods.html#.RevokeVote" class="method-link">RevokeVote</a></li><li data-type="method" id="ClientMethods-VoteStatus-nav"><a href="module-ClientMethods.html#.VoteStatus" class="method-link">VoteStatus</a></li></ul></li><li id="Notifications-nav">
          <div data-name="Notifications" class="class-link-container"><a class="class-link">Notifications</a></div><ul class='methods'><li data-type="method" id="Notifications-Notifications-nav"><a href="module-Notifications.html" class="method-link">Notifications</a></li><h4 class="methodGroupHeader">Notifications</h4><li data-type="method" id="Notifications-AddNotificationListener-nav"><a href="module-Notifications.html#.AddNotificationListener" class="method-link">AddNotificationListener</a></li><li data-type="method" id="Notifications-Notifications-nav"><a href="module-Notifications.html#.Notifications" class="method-link">Notifications</a></li><li data-type="method" id="Notifications-PushNotification-nav"><a href="module-Notifications.html#.PushNotification" class="method-link">PushNotification</a></li></ul></li><li id="ProfileMethods-nav">
          <div data-name="ProfileMethods" class="class-link-container"><a class="class-link">ProfileMethods</a></div><ul class='methods'><li data-type="method" id="ProfileMethods-ProfileMethods-nav"><a href="module-ProfileMethods.html" class="method-link">ProfileMethods</a></li><h4 class="methodGroupHeader">Profile</h4><li data-type="method" id="ProfileMethods-Profile-nav"><a href="module-ProfileMethods.html#.Profile" class="method-link">Profile</a></li><h4 class="methodGroupHeader">ProfileMetadata</h4><li data-type="method" id="ProfileMethods-ProfileMetadata-nav"><a href="module-ProfileMethods.html#.ProfileMetadata" class="method-link">ProfileMetadata</a></li><li data-type="method" id="ProfileMethods-RemoveProfileMetadata-nav"><a href="module-ProfileMethods.html#.RemoveProfileMetadata" class="method-link">RemoveProfileMetadata</a></li><li data-type="method" id="ProfileMethods-SetProfileMetadata-nav"><a href="module-ProfileMethods.html#.SetProfileMetadata" class="method-link">SetProfileMetadata</a></li></ul></li></ul>
      </div>
    </nav>

    <div class="main">
      <div class="header"></div>
      <div class="main-content">
        
        <h1 class="page-title">
          ClientMethods.js
        </h1>
        

        
      

<a class="button" href="ClientMethods.html">Back</a>
<div class="source-container">
  <pre class="prettyprint source linenums"><code>const Utils = require("../Utils");
const UrlJoin = require("url-join");
const {FormatNFTDetails, FormatNFTMetadata, FormatNFT} = require("./Utils");
const MergeWith = require("lodash/mergeWith");

/**
 * Methods
 *
 * @module ClientMethods
 */

/* USER INFO */


/**
 * &lt;b>&lt;i>Requires login&lt;/i>&lt;/b>
 *
 * Retrieve information about the user, including the address, wallet type, and (for custodial users) email address.
 *
 * @methodGroup User
 *
 * @returns {Object} - User info
 */
exports.UserInfo = function() {
  if(!this.loggedIn) { return; }

  return {
    name: this.__authorization.email || this.UserAddress(),
    address: this.UserAddress() ,
    email: this.__authorization.email,
    walletType: this.__authorization.walletType,
    walletName: this.__authorization.walletName
  };
};

/**
 * &lt;b>&lt;i>Requires login&lt;/i>&lt;/b>
 *
 * Retrieve the address of the current user.
 *
 * @methodGroup User
 *
 * @returns {string} - The address of the current user
 */
exports.UserAddress = function() {
  if(!this.loggedIn) { return; }

  return this.client.utils.DecodeSignedToken(this.AuthToken()).payload.adr;
};

/**
 * &lt;b>&lt;i>Requires login&lt;/i>&lt;/b>
 *
 * Retrieve the fund balances for the current user
 *
 * @methodGroup User
 * @returns {Promise&lt;Object>} - Returns balances for the user. All values are in USD.
 *  &lt;ul>
 *  &lt;li>- totalWalletBalance - Total balance of the users sales and wallet balance purchases&lt;/li>
 *  &lt;li>- availableWalletBalance - Balance available for purchasing items&lt;/li>
 *  &lt;li>- pendingWalletBalance - Balance unavailable for purchasing items&lt;/li>
 *  &lt;li>- withdrawableWalletBalance - Amount that is available for withdrawal&lt;/li>
 *  &lt;li>- usedBalance - &lt;i>(Only included if user has set up Solana link with the Phantom wallet)&lt;/i> Available USDC balance of the user's Solana wallet&lt;/li>
 *  &lt;/ul>
 */
exports.UserWalletBalance = async function(checkOnboard=false) {
  if(!this.loggedIn) { return; }

  // eslint-disable-next-line no-unused-vars
  const { balance, usage_hold, payout_hold, locked_offer_balance, stripe_id, stripe_payouts_enabled } = await this.client.utils.ResponseToJson(
    await this.client.authClient.MakeAuthServiceRequest({
      path: UrlJoin("as", "wlt", "mkt", "bal"),
      method: "GET",
      headers: {
        Authorization: `Bearer ${this.AuthToken()}`
      }
    })
  );

  const userStripeId = stripe_id;
  const userStripeEnabled = stripe_payouts_enabled;
  const totalWalletBalance = parseFloat(balance || 0);
  const lockedWalletBalance = parseFloat(locked_offer_balance || 0);
  const availableWalletBalance = Math.max(0, totalWalletBalance - parseFloat(usage_hold || 0) - lockedWalletBalance);
  const pendingWalletBalance = Math.max(0, totalWalletBalance - availableWalletBalance);
  const withdrawableWalletBalance = Math.max(0, totalWalletBalance - parseFloat(Math.max(payout_hold, lockedWalletBalance) || 0));

  if(checkOnboard &amp;&amp; stripe_id &amp;&amp; !stripe_payouts_enabled) {
    // Refresh stripe enabled flag
    const rootUrl = new URL(UrlJoin(window.location.origin, window.location.pathname)).toString();
    await this.client.authClient.MakeAuthServiceRequest({
      path: UrlJoin("as", "wlt", "onb", "stripe"),
      method: "POST",
      body: {
        country: "US",
        mode: this.mode,
        refresh_url: rootUrl.toString(),
        return_url: rootUrl.toString()
      },
      headers: {
        Authorization: `Bearer ${this.AuthToken()}`
      }
    });

    return await this.UserWalletBalance(false);
  }

  let balances = {
    totalWalletBalance,
    availableWalletBalance,
    lockedWalletBalance,
    pendingWalletBalance,
    withdrawableWalletBalance,
  };

  if(userStripeEnabled) {
    balances.userStripeId = userStripeId;
    balances.userStripeEnabled = userStripeEnabled;
  }

  // TODO: integrate
  /*
  if(cryptoStore.usdcConnected) {
    balances.usdcBalance = cryptoStore.phantomUSDCBalance;
  }

   */

  return balances;
};

/**
 * Retrieve all valid names for filtering user items. Full item names are required for filtering results by name.
 *
 * Specify marketplace information to filter the results to only items offered in that marketplace.
 *
 * @methodGroup User
 * @namedParams
 * @param {string=} userAddress - Address of a user
 * @param {Object=} marketplaceParams - Parameters of a marketplace to filter results by
 *
 * @returns {Promise&lt;Array&lt;String>>} - A list of item names
 */
exports.UserItemNames = async function({marketplaceParams, userAddress}={}) {
  let filters = [];
  if(marketplaceParams) {
    filters.push(`tenant:eq:${(await this.MarketplaceInfo({marketplaceParams})).tenantId}`);
  }

  if(userAddress) {
    filters.push(`wlt:eq:${Utils.FormatAddress(userAddress)}`);
  }

  return await Utils.ResponseToJson(
    await this.client.authClient.MakeAuthServiceRequest({
      path: UrlJoin("as", "wlt", "names"),
      method: "GET",
      queryParams: { filter: filters }
    })
  );
};

/**
 * Retrieve all valid edition names for filtering the specified item. Full edition names are required for filtering results by edition.
 *
 * Specify marketplace information to filter the results to only items offered in that marketplace.
 *
 * @methodGroup User
 * @namedParams
 * @param {string} displayName - Name of an item
 *
 * @returns {Promise&lt;Array&lt;String>>} - A list of item editions
 */
exports.UserItemEditionNames = async function({displayName}) {
  return await Utils.ResponseToJson(
    await this.client.authClient.MakeAuthServiceRequest({
      path: UrlJoin("as", "wlt", "editions"),
      method: "GET",
      queryParams: { filter: `meta/display_name:eq:${displayName}` }
    })
  );
};

/**
 * Retrieve all valid attribute names and values. Full attribute names and values are required for filtering results by attribute.
 *
 * Specify marketplace information to filter the results to only items offered in that marketplace.
 *
 * @methodGroup User
 * @namedParams
 * @param {string=} userAddress - Address of a user
 * @param {string=} displayName - Name of an item
 * @param {Object=} marketplaceParams - Parameters of a marketplace to filter results by
 *
 * @returns {Promise&lt;Array&lt;String>>} - A list of item names
 */
exports.UserItemAttributes = async function({marketplaceParams, displayName, userAddress}={}) {
  let filters = [];
  if(marketplaceParams) {
    filters.push(`tenant:eq:${(await this.MarketplaceInfo({marketplaceParams})).tenantId}`);
  }

  if(userAddress) {
    filters.push(`wlt:eq:${Utils.FormatAddress(userAddress)}`);
  }

  if(displayName) {
    filters.push(`meta/display_name:eq:${displayName}`);
  }

  const attributes = await Utils.ResponseToJson(
    await this.client.authClient.MakeAuthServiceRequest({
      path: UrlJoin("as", "wlt", "attributes"),
      method: "GET",
      queryParams: {
        filter: filters
      }
    })
  );

  return attributes
    .map(({trait_type, values}) => ({ name: trait_type, values }))
    .filter(({name}) =>
      !["Content Fabric Hash", "Total Minted Supply", "Creator"].includes(name)
    );
};

/**
 * &lt;b>&lt;i>Requires login&lt;/i>&lt;/b>
 *
 * Retrieve items owned by the specified or current user matching the specified parameters.
 *
 * @methodGroup User
 * @namedParams
 * @param {boolean=} includeFullMetadata=false - If true, will include full metadata for each item. Ignored if not logged in.
 * @param {string=} userAddress - Address of a user. If not specified, will return results for current user
 * @param {integer=} start=0 - PAGINATION: Index from which the results should start
 * @param {integer=} limit=50 - PAGINATION: Maximum number of results to return
 * @param {string=} sortBy="default" - Sort order. Options: `default`, `meta/display_name`
 * @param {boolean=} sortDesc=false - Sort results descending instead of ascending
 * @param {string=} filter - Filter results by item name.
 * @param {string=} contractAddress - Filter results by the address of the NFT contract
 * @param {string=} tokenId - Filter by token ID (if filtering by contract address)
 * @param {Object=} marketplaceParams - Filter results by marketplace
 * @param {Array&lt;integer>=} collectionIndexes - If filtering by marketplace, filter by collection(s). The index refers to the index in the array `marketplace.collections`
 *
 * @returns {Promise&lt;Object>} - Results of the query and pagination info
 */
exports.UserItems = async function ({sortBy = "default", includeFullMetadata = false} = {}) {
  if(includeFullMetadata &amp;&amp; this.loggedIn) {
    return this.FilteredQuery({mode: "owned-full-meta", sortBy, ...(arguments[0] || {})});
  } else {
    return this.FilteredQuery({mode: "owned", sortBy, ...(arguments[0] || {})});
  }
};

/**
 * Return all listings for the current user. Not paginated.
 *
 * @methodGroup User
 * @namedParams
 * @param {string=} userAddress - Address of a user. If not specified, will return results for current user
 * @param {string=} sortBy="created" - Sort order. Options: `created`, `info/token_id`, `info/ordinal`, `price`, `nft/display_name`
 * @param {boolean=} sortDesc=false - Sort results descending instead of ascending
 * @param {Object=} marketplaceParams - Filter results by marketplace
 * @param {string=} contractAddress - Filter results by the address of the NFT contract
 * @param {string=} tokenId - Filter by token ID (if filtering by contract address)
 *
 * @returns {Promise&lt;Array&lt;Object>>} - List of current user's listings
 */
exports.UserListings = async function({userAddress, sortBy="created", sortDesc=false, contractAddress, tokenId, marketplaceParams}={}) {
  return (
    await this.FilteredQuery({
      mode: "listings",
      start: 0,
      limit: 10000,
      sortBy,
      sortDesc,
      sellerAddress: userAddress || this.UserAddress(),
      marketplaceParams,
      contractAddress,
      tokenId,
      includeCheckoutLocked: true
    })
  ).results;
};

/**
 * Return all sales for the current user. Not paginated.
 *
 * @methodGroup User
 * @namedParams
 * @param {string=} userAddress - Address of a user. If not specified, will return results for current user
 * @param {string=} sortBy="created" - Sort order. Options: `created`, `price`, `name`
 * @param {boolean=} sortDesc=false - Sort results descending instead of ascending
 * @param {Object=} marketplaceParams - Filter results by marketplace
 * @param {string=} contractAddress - Filter results by the address of the NFT contract
 * @param {string=} tokenId - Filter by token ID (if filtering by contract address)
 * @param {integer=} startTime - Filter by results listed after the specified time (in milliseconds since epoch)
 * @param {integer=} endTime - Filter by results listed before the specified time (in milliseconds since epoch)
 * @param {integer=} lastNDays - Filter by results listed in the past N days
 *
 * @returns {Promise&lt;Array&lt;Object>>} - List of current user's sales
 */
exports.UserSales = async function({userAddress, sortBy="created", sortDesc=false, contractAddress, tokenId, startTime, endTime, lastNDays, marketplaceParams}={}) {
  return (
    await this.FilteredQuery({
      mode: "sales",
      start: 0,
      limit: 10000,
      sortBy,
      sortDesc,
      sellerAddress: userAddress || this.UserAddress(),
      startTime,
      endTime,
      lastNDays,
      marketplaceParams,
      contractAddress,
      tokenId
    })
  ).results;
};

/**
 * Return all transfers and sales for the current user. Not paginated.
 *
 * @methodGroup User
 * @namedParams
 * @param {string=} userAddress - Address of a user. If not specified, will return results for current user
 * @param {string=} sortBy="created" - Sort order. Options: `created`, `price`, `name`
 * @param {boolean=} sortDesc=false - Sort results descending instead of ascending
 * @param {Object=} marketplaceParams - Filter results by marketplace
 * @param {string=} contractAddress - Filter results by the address of the NFT contract
 * @param {string=} tokenId - Filter by token ID (if filtering by contract address)
 * @param {integer=} startTime - Filter by results listed after the specified time (in milliseconds since epoch)
 * @param {integer=} endTime - Filter by results listed before the specified time (in milliseconds since epoch)
 * @param {integer=} lastNDays - Filter by results listed in the past N days
 *
 * @returns {Promise&lt;Array&lt;Object>>} - List of current user's sales
 */
exports.UserTransfers = async function({userAddress, sortBy="created", sortDesc=false, contractAddress, tokenId, startTime, endTime, lastNDays, marketplaceParams}={}) {
  return (
    await this.FilteredQuery({
      mode: "transfers",
      start: 0,
      limit: 10000,
      sortBy,
      sortDesc,
      sellerAddress: userAddress || this.UserAddress(),
      marketplaceParams,
      contractAddress,
      tokenId,
      startTime,
      endTime,
      lastNDays
    })
  ).results;
};

/* TENANT */

/**
 * Retrieve configuration information about the specified tenant, or the tenant associated with the specified contract.
 *
 * This information includes the royalty rate the tenant receives for secondary sales.
 *
 * @methodGroup Tenants
 * @namedParams
 * @param {string=} tenantId - The ID of the tenant for which to retrieve configuration
 * @param {string=} contractAddress - The ID of an nft contract for which to retrieve configuration
 *
 * @returns {Promise&lt;Object>} - The tenant configuration
 */
exports.TenantConfiguration = async function({tenantId, contractAddress}) {
  try {
    contractAddress = contractAddress ? Utils.FormatAddress(contractAddress) : undefined;

    if(!this.tenantConfigs[contractAddress || tenantId]) {
      this.tenantConfigs[contractAddress || tenantId] = await Utils.ResponseToJson(
        this.client.authClient.MakeAuthServiceRequest({
          path: contractAddress ?
            UrlJoin("as", "config", "nft", contractAddress) :
            UrlJoin("as", "config", "tnt", tenantId),
          method: "GET",
        })
      );
    }

    return this.tenantConfigs[contractAddress || tenantId];
  } catch(error) {
    this.Log("Failed to load tenant configuration", true, error);

    return {};
  }
};


/**
 * Retrieve the current exchange rate for the specified currency to USD
 *
 * @methodGroup Tenants
 * @namedParams
 * @param {string} currency - The currency for which to retrieve the USD exchange rate
 */
exports.ExchangeRate = async function({currency}) {
  if(!currency) {
    throw Error("Eluvio Wallet Client: Invalid or missing currency in ExchangeRate");
  }

  return await Utils.ResponseToJson(
    this.client.authClient.MakeAuthServiceRequest({
      path: UrlJoin("as", "xr", "ebanx", currency),
      method: "GET"
    })
  );
};

/**
 * Retrieve custom CSS for the specified tenant
 *
 * @methodGroup Tenants
 * @namedParams
 * @param {Object} tenantSlug
 *
 * @returns {Promise&lt;string>} - The CSS of the tenant
 */
exports.TenantCSS = async function ({tenantSlug}) {
  if(!this.cachedCSS[tenantSlug]) {
    this.cachedCSS[tenantSlug] = await this.client.ContentObjectMetadata({
      libraryId: this.mainSiteLibraryId,
      objectId: this.mainSiteId,
      metadataSubtree: UrlJoin("/public", "asset_metadata", "tenants", tenantSlug, "info", "branding", "wallet_css"),
      authorizationToken: this.publicStaticToken
    });
  }

  return this.cachedCSS[tenantSlug] || "";
};

/* MARKETPLACE */

/**
 * Retrieve available stock for the specified marketplace, organized by SKU.
 *
 * If a user is logged in, stock information will also include how many of that item the user has purchased.
 *
 * @methodGroup Marketplaces
 * @namedParams
 * @param {Object} marketplaceParams - Parameters of the marketplace
 *
 * @returns {Promise&lt;Object>} - Stock info for items in the marketplace
 */
exports.MarketplaceStock = async function ({marketplaceParams, tenantId}) {
  if(!tenantId) {
    const marketplaceInfo = this.MarketplaceInfo({marketplaceParams});
    tenantId = marketplaceInfo.tenantId;
  }

  if(this.loggedIn) {
    return await Utils.ResponseToJson(
      this.client.authClient.MakeAuthServiceRequest({
        path: UrlJoin("as", "wlt", "nft", "info", tenantId),
        method: "GET",
        headers: {
          Authorization: `Bearer ${this.AuthToken()}`
        }
      })
    );
  }

  return await Utils.ResponseToJson(
    this.client.authClient.MakeAuthServiceRequest({
      path: UrlJoin("as", "nft", "stock", tenantId),
      method: "GET"
    })
  );
};

/**
 * Retrieve basic information about a specific available marketplace with the specified tenant/marketplace slug, ID, or hash.
 *
 * Includes the slugs, ID and hash of the marketplace, as well as branding information.
 *
 * To retrieve full metadata for the marketplace, use the &lt;a href="#.Marketplace">Marketplace&lt;/a> method.
 *
 * @methodGroup Marketplaces
 * @namedParams
 * @param {Object} marketplaceParams - Parameters of the marketplace
 *
 * @returns {Promise&lt;Object>} - Info about the marketplace
 */
exports.MarketplaceInfo = function ({marketplaceParams}) {
  let { tenantSlug, marketplaceSlug, marketplaceId, marketplaceHash } = (marketplaceParams || {});

  let marketplaceInfo;
  if(tenantSlug &amp;&amp; marketplaceSlug) {
    marketplaceInfo = (this.availableMarketplaces[tenantSlug] || {})[marketplaceSlug];
  } else {
    marketplaceId = marketplaceHash ? this.client.utils.DecodeVersionHash(marketplaceHash).objectId : marketplaceId;
    marketplaceInfo = this.availableMarketplacesById[marketplaceId];
  }

  if(!marketplaceInfo) {
    throw Error(`Eluvio Wallet Client: Unable to find marketplace with parameters ${JSON.stringify(arguments)}`);
  }

  return marketplaceInfo;
};

/**
 * Retrieve custom CSS for the specified marketplace
 *
 * @methodGroup Marketplaces
 * @namedParams
 * @param {Object} marketplaceParams - Parameters of the marketplace
 *
 * @returns {Promise&lt;string>} - The CSS of the marketplace
 */
exports.MarketplaceCSS = async function ({marketplaceParams}) {
  const marketplaceInfo = this.MarketplaceInfo({marketplaceParams});

  const marketplaceHash = marketplaceInfo.marketplaceHash;

  if(!this.cachedCSS[marketplaceHash]) {
    this.cachedCSS[marketplaceHash] = await this.client.ContentObjectMetadata({
      versionHash: marketplaceHash,
      metadataSubtree: "public/asset_metadata/info/branding/custom_css",
      authorizationToken: this.publicStaticToken,
      noAuth: true
    });
  }

  return this.cachedCSS[marketplaceHash] || "";
};

/**
 * Retrieve info about all available marketplaces
 *
 * @methodGroup Marketplaces
 * @namedParams
 * @param {boolean=} organizeById - By default, the returned marketplace info is organized by tenant and marketplace slug. If this option is enabled, the marketplaces will be organized by marketplace ID instead.
 * @param {boolean=} forceReload=false - If specified, a new request will be made to check the currently available marketplaces instead of returning cached info
 *
 * @returns {Promise&lt;Object>} - Info about available marketplaces
 */
exports.AvailableMarketplaces = async function ({organizeById, forceReload=false}={}) {
  if(forceReload) {
    await this.LoadAvailableMarketplaces(true);
  }

  return {
    ...(organizeById ? this.availableMarketplacesById : this.availableMarketplaces)
  };
};

/**
 * Retrieve full information about the specified marketplace
 *
 * &lt;b>&lt;i>Note&lt;/i>&lt;/b> - Upon changing login state, the marketplace should be retrieved again as permission info in marketplace items may be different depending on the current user's permissions.
 *
 * @methodGroup Marketplaces
 * @namedParams
 * @param {Object} marketplaceParams - Parameters of the marketplace
 *
 * @returns {Promise&lt;Object>} - The full information for the marketplace
 */
exports.Marketplace = async function ({marketplaceParams}) {
  return this.LoadMarketplace(marketplaceParams);
};


/* NFTS */

/**
 * Return info about the specified NFT contract, including the cap, current total supply, and total minted and burned.
 *
 * @methodGroup NFTs
 * @namedParams
 * @param {string} contractAddress - The contract address of the NFT
 *
 * @returns {Promise&lt;Object>} - Information about the specified contract
 */
exports.NFTContractStats = async function({contractAddress}) {
  return await Utils.ResponseToJson(
    this.client.authClient.MakeAuthServiceRequest({
      path: UrlJoin("as", "nft", "info", contractAddress),
      method: "GET"
    })
  );
};

/**
 * Load full info for the specified NFT
 *
 * @methodGroup NFTs
 * @namedParams
 * @param {string} contractAddress - The contract address of the NFT
 * @param {string} tokenId - The token ID of the NFT
 */
exports.NFT = async function({tokenId, contractAddress}) {
  let nft = FormatNFTDetails(
    await Utils.ResponseToJson(
      this.client.authClient.MakeAuthServiceRequest({
        path: UrlJoin("as", "nft", "info", contractAddress, tokenId),
        method: "GET"
      })
    )
  );

  const assetMetadata = (await this.client.ContentObjectMetadata({
    versionHash: nft.details.VersionHash,
    metadataSubtree: "public/asset_metadata/nft",
    produceLinkUrls: true
  })) || {};

  nft.metadata = MergeWith({}, assetMetadata, nft.metadata, (a, b) => b === null || b === "" ? a : undefined);

  if(this.localization) {
    const localizedMetadata = (await this.client.ContentObjectMetadata({
      versionHash: nft.details.VersionHash,
      metadataSubtree: UrlJoin("public", "asset_metadata", "localizations", this.localization, "nft"),
      produceLinkUrls: true
    })) || {};

    nft.metadata = MergeWith({}, nft.metadata, localizedMetadata, (a, b) => b === null || b === "" ? a : undefined);
  }

  nft.config = await this.TenantConfiguration({contractAddress});

  return FormatNFTMetadata(this, nft);
};

/**
 * &lt;b>&lt;i>Requires login&lt;/i>&lt;/b>
 *
 * Transfer the specified NFT owned by the current user to the specified address
 *
 * @methodGroup NFTs
 * @namedParams
 * @param {string} contractAddress - The contract address of the NFT
 * @param {string} tokenId - The token ID of the NFT
 * @param {string} targetAddress - The address to which to transfer the NFT
 */
exports.TransferNFT = async function({contractAddress, tokenId, targetAddress}) {
  if(!targetAddress || !Utils.ValidAddress(targetAddress)) {
    throw Error("Eluvio Wallet Client: Invalid or missing target address in UserTransferNFT");
  }

  return await this.client.authClient.MakeAuthServiceRequest({
    path: UrlJoin("as", "wlt", "mkt", "xfer"),
    method: "POST",
    body: {
      contract: Utils.FormatAddress(contractAddress),
      token: tokenId,
      to_addr: Utils.FormatAddress(targetAddress)
    },
    headers: {
      Authorization: `Bearer ${this.AuthToken()}`
    }
  });
};


/** LISTINGS */

/**
 * Retrieve the status of the specified listing
 *
 * @methodGroup Listings
 * @namedParams
 * @param {string=} listingId - The ID of the listing
 *
 * @returns {Promise&lt;Object>} - The status of the listing
 */
exports.ListingStatus = async function({listingId}) {
  try {
    return await Utils.ResponseToJson(
      await this.client.authClient.MakeAuthServiceRequest({
        path: UrlJoin("as", "mkt", "status", listingId),
        method: "GET"
      })
    );
  } catch(error) {
    if(error.status === 404) { return; }

    throw error;
  }
};

/**
 * Retrieve a specific listing
 *
 * NOTE: When a listing is sold or deleted, it will no longer be queryable with this API. Use &lt;a href="#.ListingStatus">ListingStatus&lt;/a> instead.
 *
 * @methodGroup Listings
 * @namedParams
 * @param {string=} listingId - The ID of the listing
 *
 * @returns {Promise&lt;Object>} - The listing
 */
exports.Listing = async function({listingId}) {
  return FormatNFT(
    this,
    await Utils.ResponseToJson(
      await this.client.authClient.MakeAuthServiceRequest({
        path: UrlJoin("as", "mkt", "l", listingId),
        method: "GET",
      })
    )
  );
};


/**
 * Retrieve listings matching the specified parameters.
 *
 * @methodGroup Listings
 * @namedParams
 * @param {integer=} start=0 - PAGINATION: Index from which the results should start
 * @param {integer=} limit=50 - PAGINATION: Maximum number of results to return
 * @param {string=} sortBy="created" - Sort order. Options: `created`, `info/token_id`, `info/ordinal`, `price`, `nft/display_name`
 * @param {boolean=} sortDesc=false - Sort results descending instead of ascending
 * @param {string=} filter - Filter results by item name.
 *  &lt;br />&lt;br />
 *  NOTE: This string must be an &lt;b>exact match&lt;/b> on the item name.
 * You can retrieve all available item names from the &lt;a href="#.ListingNames">ListingNames method&lt;/a>.
 *  @param {Array&lt;string>=} editionFilters - Filter results by item edition.
 *  &lt;br />&lt;br />
 *  NOTE: This string must be an &lt;b>exact match&lt;/b> on the edition name.
 * You can retrieve all available item edition names from the &lt;a href="#.ListingEditionNames">ListingEditionNames method&lt;/a>.
 *  @param {Array&lt;Object>} attributeFilters - Filter results by item attributes. Each entry should include name and value (e.g. `[{name: "attribute-name", value: "attribute-value"}]`)
 *  &lt;br />&lt;br />
 *  NOTE: These filters must be an &lt;b>exact match&lt;/b> on the attribute name and value.
 * You can retrieve all available item attributes from the &lt;a href="#.ListingAttributes">ListingAttributes method&lt;/a>.
 * @param {Object=} priceRange - Filter min and/or max price (e.g. `{min: 1}` `{max: 2}` `{min: 1.50, max: 10.50})
 * @param {string=} sellerAddress - Filter by a specific seller
 * @param {string=} contractAddress - Filter results by the address of the NFT contract
 * @param {string=} tokenId - Filter by token ID (if filtering by contract address)
 * @param {string=} currency - Filter results by purchase currency. Available options: `usdc`
 * @param {Object=} marketplaceParams - Filter results by marketplace
 * @param {Array&lt;integer>=} collectionIndexes - If filtering by marketplace, filter by collection(s). The index refers to the index in the array `marketplace.collections`
 * @param {integer=} startTime - Filter by results listed after the specified time (in milliseconds since epoch)
 * @param {integer=} endTime - Filter by results listed before the specified time (in milliseconds since epoch)
 * @param {integer=} lastNDays - Filter by results listed in the past N days
 * @param {boolean=} includeCheckoutLocked - If specified, listings which are currently in the checkout process (and not so currently purchasable) will be included in the results. By default they are excluded.
 *
 * @returns {Promise&lt;Object>} - Results of the query and pagination info
 */
exports.Listings = async function() {
  return this.FilteredQuery({mode: "listings", ...(arguments[0] || {})});
};

/**
 * Retrieve stats for listings matching the specified parameters.
 *
 * @methodGroup Listings
 * @namedParams
 * @param {integer=} start=0 - PAGINATION: Index from which the results should start
 * @param {integer=} limit=50 - PAGINATION: Maximum number of results to return
 * @param {string=} sortBy="created" - Sort order. Options: `created`, `info/token_id`, `info/ordinal`, `price`, `nft/display_name`
 * @param {boolean=} sortDesc=false - Sort results descending instead of ascending
 * @param {string=} filter - Filter results by item name.
 *  &lt;br />&lt;br />
 *  NOTE: This string must be an &lt;b>exact match&lt;/b> on the item name.
 * You can retrieve all available item names from the &lt;a href="#.ListingNames">ListingNames method&lt;/a>.
 *  @param {Array&lt;string>} editionFilters - Filter results by item edition.
 *  &lt;br />&lt;br />
 *  NOTE: This string must be an &lt;b>exact match&lt;/b> on the edition name.
 * You can retrieve all available item edition names from the &lt;a href="#.ListingEditionNames">ListingEditionNames method&lt;/a>.
 *  @param {Array&lt;Object>} attributeFilters - Filter results by item attributes. Each entry should include name and value (e.g. `[{name: "attribute-name", value: "attribute-value"}]`)
 *  &lt;br />&lt;br />
 *  NOTE: These filters must be an &lt;b>exact match&lt;/b> on the attribute name and value.
 * You can retrieve all available item attributes from the &lt;a href="#.ListingAttributes">ListingAttributes method&lt;/a>.
 * @param {Object=} priceRange - Filter min and/or max price (e.g. `{min: 1}` `{max: 2}` `{min: 1.50, max: 10.50})
 * @param {string=} sellerAddress - Filter by a specific seller
 * @param {string=} contractAddress - Filter results by the address of the NFT contract
 * @param {string=} tokenId - Filter by token ID (if filtering by contract address)
 * @param {string=} currency - Filter results by purchase currency. Available options: `usdc`
 * @param {Object=} marketplaceParams - Filter results by marketplace
 * @param {Array&lt;integer>=} collectionIndexes - If filtering by marketplace, filter by collection(s). The index refers to the index in the array `marketplace.collections`
 * @param {integer=} startTime - Filter by results listed after the specified time (in milliseconds since epoch)
 * @param {integer=} endTime - Filter by results listed before the specified time (in milliseconds since epoch)
 * @param {integer=} lastNDays - Filter by results listed in the past N days
 *
 * @returns {Promise&lt;Object>} - Statistics about listings. All prices in USD.
 */
exports.ListingStats = async function() {
  return this.FilteredQuery({mode: "listing-stats", ...(arguments[0] || {})});
};

/**
 * Retrieve sales matching the specified parameters.
 *
 * @methodGroup Listings
 * @namedParams
 * @param {integer=} start=0 - PAGINATION: Index from which the results should start
 * @param {integer=} limit=50 - PAGINATION: Maximum number of results to return
 * @param {string=} sortBy="created" - Sort order. Options: `created`, `price`, `name`
 * @param {boolean=} sortDesc=false - Sort results descending instead of ascending
 * @param {string=} filter - Filter results by item name.
 *  &lt;br />&lt;br />
 *  NOTE: This string must be an &lt;b>exact match&lt;/b> on the item name.
 * You can retrieve all available item names from the &lt;a href="#.ListingNames">ListingNames method&lt;/a>.
 *  @param {Array&lt;string>} editionFilters - Filter results by item edition.
 *  &lt;br />&lt;br />
 *  NOTE: This string must be an &lt;b>exact match&lt;/b> on the edition name.
 * You can retrieve all available item edition names from the &lt;a href="#.ListingEditionNames">ListingEditionNames method&lt;/a>.
 *  @param {Array&lt;Object>} attributeFilters - Filter results by item attributes. Each entry should include name and value (e.g. `[{name: "attribute-name", value: "attribute-value"}]`)
 *  &lt;br />&lt;br />
 *  NOTE: These filters must be an &lt;b>exact match&lt;/b> on the attribute name and value.
 * You can retrieve all available item attributes from the &lt;a href="#.ListingAttributes">ListingAttributes method&lt;/a>.
 * @param {string=} sellerAddress - Filter by a specific seller
 * @param {string=} contractAddress - Filter results by the address of the NFT contract
 * @param {string=} tokenId - Filter by token ID (if filtering by contract address)
 * @param {string=} currency - Filter results by purchase currency. Available options: `usdc`
 * @param {Object=} marketplaceParams - Filter results by marketplace
 * @param {Array&lt;integer>=} collectionIndexes - If filtering by marketplace, filter by collection(s). The index refers to the index in the array `marketplace.collections`
 * @param {integer=} startTime - Filter by results listed after the specified time (in milliseconds since epoch)
 * @param {integer=} endTime - Filter by results listed before the specified time (in milliseconds since epoch)
 * @param {integer=} lastNDays - Filter by results listed in the past N days
 *
 * @returns {Promise&lt;Object>} - Results of the query and pagination info
 */
exports.Sales = async function() {
  return this.FilteredQuery({mode: "sales", ...(arguments[0] || {})});
};

/**
 * Retrieve sales and transfers matching the specified parameters.
 *
 * @methodGroup Listings
 * @namedParams
 * @param {integer=} start=0 - PAGINATION: Index from which the results should start
 * @param {integer=} limit=50 - PAGINATION: Maximum number of results to return
 * @param {string=} sortBy="created" - Sort order. Options: `created`, `price`, `name`
 * @param {boolean=} sortDesc=false - Sort results descending instead of ascending
 * @param {string=} filter - Filter results by item name.
 *  &lt;br />&lt;br />
 *  NOTE: This string must be an &lt;b>exact match&lt;/b> on the item name.
 * You can retrieve all available item names from the &lt;a href="#.ListingNames">ListingNames method&lt;/a>.
 *  @param {Array&lt;string>} editionFilters - Filter results by item edition.
 *  &lt;br />&lt;br />
 *  NOTE: This string must be an &lt;b>exact match&lt;/b> on the edition name.
 * You can retrieve all available item edition names from the &lt;a href="#.ListingEditionNames">ListingEditionNames method&lt;/a>.
 *  @param {Array&lt;Object>} attributeFilters - Filter results by item attributes. Each entry should include name and value (e.g. `[{name: "attribute-name", value: "attribute-value"}]`)
 *  &lt;br />&lt;br />
 *  NOTE: These filters must be an &lt;b>exact match&lt;/b> on the attribute name and value.
 * You can retrieve all available item attributes from the &lt;a href="#.ListingAttributes">ListingAttributes method&lt;/a>.
 * @param {string=} sellerAddress - Filter by a specific seller
 * @param {string=} contractAddress - Filter results by the address of the NFT contract
 * @param {string=} tokenId - Filter by token ID (if filtering by contract address)
 * @param {string=} currency - Filter results by purchase currency. Available options: `usdc`
 * @param {Object=} marketplaceParams - Filter results by marketplace
 * @param {Array&lt;integer>=} collectionIndexes - If filtering by marketplace, filter by collection(s). The index refers to the index in the array `marketplace.collections`
 * @param {integer=} startTime - Filter by results listed after the specified time (in milliseconds since epoch)
 * @param {integer=} endTime - Filter by results listed before the specified time (in milliseconds since epoch)
 * @param {integer=} lastNDays - Filter by results listed in the past N days
 *
 * @returns {Promise&lt;Object>} - Results of the query and pagination info
 */
exports.Transfers = async function() {
  return this.FilteredQuery({mode: "transfers", ...(arguments[0] || {})});
};

/**
 * Retrieve stats for listings matching the specified parameters.
 *
 * @methodGroup Listings
 * @namedParams
 * @param {integer=} start=0 - PAGINATION: Index from which the results should start
 * @param {integer=} limit=50 - PAGINATION: Maximum number of results to return
 * @param {string=} sortBy="created" -
 * @param {boolean=} sortDesc=false - Sort results descending instead of ascending
 * @param {string=} filter - Filter results by item name.
 *  &lt;br />&lt;br />
 *  NOTE: This string must be an &lt;b>exact match&lt;/b> on the item name.
 * You can retrieve all available item names from the &lt;a href="#.ListingNames">ListingNames method&lt;/a>.
 *  @param {Array&lt;string>} editionFilters - Filter results by item edition.
 *  &lt;br />&lt;br />
 *  NOTE: This string must be an &lt;b>exact match&lt;/b> on the edition name.
 * You can retrieve all available item edition names from the &lt;a href="#.ListingEditionNames">ListingEditionNames method&lt;/a>.
 *  @param {Array&lt;Object>} attributeFilters - Filter results by item attributes. Each entry should include name and value (e.g. `[{name: "attribute-name", value: "attribute-value"}]`)
 *  &lt;br />&lt;br />
 *  NOTE: These filters must be an &lt;b>exact match&lt;/b> on the attribute name and value.
 * You can retrieve all available item attributes from the &lt;a href="#.ListingAttributes">ListingAttributes method&lt;/a>.
 * @param {string=} sellerAddress - Filter by a specific seller
 * @param {string=} contractAddress - Filter results by the address of the NFT contract
 * @param {string=} tokenId - Filter by token ID (if filtering by contract address)
 * @param {string=} currency - Filter results by purchase currency. Available options: `usdc`
 * @param {Object=} marketplaceParams - Filter results by marketplace
 * @param {Array&lt;integer>=} collectionIndexes - If filtering by marketplace, filter by collection(s). The index refers to the index in the array `marketplace.collections`
 * @param {integer=} startTime - Filter by results listed after the specified time (in milliseconds since epoch)
 * @param {integer=} endTime - Filter by results listed before the specified time (in milliseconds since epoch)
 * @param {integer=} lastNDays - Filter by results listed in the past N days
 *
 * @returns {Promise&lt;Object>} - Statistics about sales. All prices in USD.
 */
exports.SalesStats = async function() {
  return this.FilteredQuery({mode: "sales-stats", ...(arguments[0] || {})});
};

/**
 * Get the leaderboard rankings for the specified marketplace. If user address is specified, will return the ranking for the specified user (if present)
 *
 * @methodGroup Leaderboard
 * @namedParams
 * @param {Object=} marketplaceParams - Filter results by marketplace
 * @param {string=} userAddress - Retrieve the ranking for a specific user
 * @param {integer=} start=0 - PAGINATION: Index from which the results should start
 * @param {integer=} limit=50 - PAGINATION: Maximum number of results to return
 *
 * @returns {Promise&lt;Array|Object>} - Returns a list of leaderboard rankings or, if userAddress is specified, ranking for that user.
 */
exports.Leaderboard = async function({userAddress, marketplaceParams}) {
  if(userAddress) {
    let params = {
      addr: Utils.FormatAddress(userAddress)
    };

    if(marketplaceParams) {
      params.filter = [`tenant:eq:${(await this.MarketplaceInfo({marketplaceParams})).tenantId}`];
    }

    return ((await Utils.ResponseToJson(
      await this.client.authClient.MakeAuthServiceRequest({
        path: UrlJoin("as", "wlt", "ranks"),
        method: "GET",
        queryParams: params
      })
    )) || [])[0];
  }

  return this.FilteredQuery({mode: "leaderboard", ...(arguments[0] || {})});
};



/**
 * &lt;b>&lt;i>Requires login&lt;/i>&lt;/b>
 *
 * Create or update a listing for the specified item
 *
 * @methodGroup Listings
 * @namedParams
 * @param {string} contractAddress - The NFT contract address of the item
 * @param {string} tokenId - The token ID of the item
 * @param {number} price - The price of the listing, in USD
 * @param {string=} listingId - (When editing a listing) The ID of the existing listing
 *
 * @returns {Promise&lt;string>} - The listing ID of the created listing
 */
exports.CreateListing = async function({contractAddress, tokenId, price, listingId}) {
  contractAddress = Utils.FormatAddress(contractAddress);

  if(listingId) {
    // Update
    return await Utils.ResponseToFormat(
      "text",
      await this.client.authClient.MakeAuthServiceRequest({
        path: UrlJoin("as", "wlt", "mkt"),
        method: "PUT",
        body: {
          id: listingId,
          price: parseFloat(price)
        },
        headers: {
          Authorization: `Bearer ${this.AuthToken()}`
        }
      })
    );
  } else {
    // Create
    return await Utils.ResponseToJson(
      await this.client.authClient.MakeAuthServiceRequest({
        path: UrlJoin("as", "wlt", "mkt"),
        method: "POST",
        body: {
          contract: contractAddress,
          token: tokenId,
          price: parseFloat(price)
        },
        headers: {
          Authorization: `Bearer ${this.AuthToken()}`
        }
      })
    );
  }
};

/**
 * &lt;b>&lt;i>Requires login&lt;/i>&lt;/b>
 *
 * Remove the specified listing
 *
 * @methodGroup Listings
 * @namedParams
 * @param {string} listingId - The ID of the listing to remove
 */
exports.RemoveListing = async function({listingId}) {
  await this.client.authClient.MakeAuthServiceRequest({
    path: UrlJoin("as", "wlt", "mkt", listingId),
    method: "DELETE",
    headers: {
      Authorization: `Bearer ${this.AuthToken()}`
    }
  });
};

/**
 * Retrieve all valid names for filtering listing sales names. Full item names are required for filtering sales results by name.
 *
 * Specify marketplace information to filter the results to only items offered in that marketplace.
 *
 * @methodGroup Listings
 * @namedParams
 * @param {Object} marketplaceParams - Parameters of a marketplace to filter results by
 *
 * @returns {Promise&lt;Array&lt;String>>} - A list of item names
 */
exports.SalesNames = async function({marketplaceParams}) {
  let tenantId;
  if(marketplaceParams) {
    tenantId = (await this.MarketplaceInfo({marketplaceParams})).tenantId;
  }

  return await Utils.ResponseToJson(
    await this.client.authClient.MakeAuthServiceRequest({
      path: UrlJoin("as", "mkt", "names", "hst"),
      method: "GET",
      queryParams: tenantId ? { filter: `tenant:eq:${tenantId}` } : {}
    })
  );
};

/**
 * Retrieve all valid names for filtering listings. Full item names are required for filtering listing results by name.
 *
 * Specify marketplace information to filter the results to only items offered in that marketplace.
 *
 * @methodGroup Listings
 * @namedParams
 * @param {Object} marketplaceParams - Parameters of a marketplace to filter results by
 *
 * @returns {Promise&lt;Array&lt;String>>} - A list of item names
 */
exports.ListingNames = async function({marketplaceParams}) {
  let tenantId;
  if(marketplaceParams) {
    tenantId = (await this.MarketplaceInfo({marketplaceParams})).tenantId;
  }

  return await Utils.ResponseToJson(
    await this.client.authClient.MakeAuthServiceRequest({
      path: UrlJoin("as", "mkt", "names"),
      method: "GET",
      queryParams: tenantId ? { filter: `tenant:eq:${tenantId}` } : {}
    })
  );
};


/**
 * Retrieve all valid edition names of the specified item. Full item edition names are required for filtering listing results by edition.
 *
 * @methodGroup Listings
 * @namedParams
 * @param {string} displayName - Display name of the item from which to request edition names
 *
 * @returns {Promise&lt;Array&lt;String>>} - A list of item editions
 */
exports.ListingEditionNames = async function({displayName}) {
  return await Utils.ResponseToJson(
    await this.client.authClient.MakeAuthServiceRequest({
      path: UrlJoin("as", "mkt", "editions"),
      queryParams: {
        filter: `nft/display_name:eq:${displayName}`
      },
      method: "GET"
    })
  );
};

/**
 * Retrieve names of all valid attributes for listed items. Full attribute names and values are required for filtering listing results by attributes.
 *
 * Specify marketplace information to filter the results to only items offered in that marketplace.
 *
 * @methodGroup Listings
 * @namedParams
 * @param {Object=} marketplaceParams - Parameters of a marketplace to filter results by
 * @param {string=} displayName - Display name of the item from which to request attributes
 *
 * @returns {Promise&lt;Array&lt;String>>} - A list of valid attributes
 */
exports.ListingAttributes = async function({marketplaceParams, displayName}={}) {
  let filters = [];

  if(marketplaceParams) {
    filters.push(`tenant:eq:${(await this.MarketplaceInfo({marketplaceParams})).tenantId}`);
  }

  if(displayName) {
    filters.push(`nft/display_name:eq:${displayName}`);
  }

  const attributes = await Utils.ResponseToJson(
    await this.client.authClient.MakeAuthServiceRequest({
      path: UrlJoin("as", "mkt", "attributes"),
      method: "GET",
      queryParams: {
        filter: filters
      }
    })
  );

  return attributes
    .map(({trait_type, values}) => ({ name: trait_type, values }))
    .filter(({name}) =>
      !["Content Fabric Hash", "Total Minted Supply", "Creator"].includes(name)
    );
};

/* PURCHASE / CLAIM */

/**
 * Claim the specified item from the specified marketplace
 *
 * Use the &lt;a href="#.ClaimStatus">ClaimStatus&lt;/a> method to check minting status after claiming
 *
 * @methodGroup Purchase
 * @namedParams
 * @param {Object} marketplaceParams - Parameters of the marketplace
 * @param {string} sku - The SKU of the item to claim
 * @param {string=} email - Email address of the user. If specified, this will bind the user to the tenant of the specified marketplace
 */
exports.ClaimItem = async function({marketplaceParams, sku, email}) {
  const marketplaceInfo = await this.MarketplaceInfo({marketplaceParams});

  await this.client.authClient.MakeAuthServiceRequest({
    method: "POST",
    path: UrlJoin("as", "wlt", "act", marketplaceInfo.tenant_id),
    body: {
      op: "nft-claim",
      sid: marketplaceInfo.marketplaceId,
      sku,
      email
    },
    headers: {
      Authorization: `Bearer ${this.AuthToken()}`
    }
  });
};

/**
 * Redirect to the wallet app to purchase the specified item from the specified marketplace
 *
 * Use the &lt;a href="#.PurchaseStatus">PurchaseStatus&lt;/a> method to check minting status after purchasing
 *
 * @methodGroup Purchase
 * @namedParams
 * @param {Object} marketplaceParams - Parameters of the marketplace
 * @param {string} sku - The SKU of the item to claim
 * @param {string=} confirmationId - Confirmation ID with which to reference this purchase. If not specified, a confirmation ID will be automatically generated. On success, the user will be returned to `successUrl` with the `confirmationId` as a URL parameter.
 * @param {string} successUrl - The URL to redirect back to upon successful purchase
 * @param {string} cancelUrl - The URL to redirect back to upon cancellation of purchase
 */
exports.PurchaseItem = async function({marketplaceParams, sku, confirmationId, successUrl, cancelUrl}) {
  const marketplaceInfo = await this.MarketplaceInfo({marketplaceParams});

  window.location.href = this.FlowURL({
    type: "action",
    flow: "purchase",
    marketplaceId: marketplaceInfo.marketplaceId,
    parameters: {
      sku,
      confirmationId,
      successUrl,
      cancelUrl,
      login: true,
      auth: this.ClientAuthToken(),
    }
  });
};

/**
 * Redirect to the wallet app to purchase the specified listing
 *
 * Use the &lt;a href="#.PurchaseStatus">ListingPurchaseStatus&lt;/a> method to check minting status after purchasing
 *
 * @methodGroup Purchase
 * @namedParams
 * @param {Object=} marketplaceParams - Parameters of the marketplace
 * @param {string} listingId - The SKU of the item to claim
 * @param {string=} confirmationId - Confirmation ID with which to reference this purchase. If not specified, a confirmation ID will be automatically generated. On success, the user will be returned to `successUrl` with the `confirmationId` as a URL parameter.
 * @param {string} successUrl - The URL to redirect back to upon successful purchase
 * @param {string} cancelUrl - The URL to redirect back to upon cancellation of purchase
 */
exports.PurchaseListing = async function({marketplaceParams, listingId, confirmationId, successUrl, cancelUrl}) {
  let marketplaceInfo;
  if(marketplaceParams) {
    marketplaceInfo = await this.MarketplaceInfo({marketplaceParams});
  }

  window.location.href = this.FlowURL({
    type: "action",
    flow: "purchase",
    marketplaceId: marketplaceInfo &amp;&amp; marketplaceInfo.marketplaceId,
    parameters: {
      listingId,
      confirmationId,
      successUrl,
      cancelUrl,
      login: true,
      auth: this.ClientAuthToken(),
    }
  });
};

/* MINTING STATUS */

/**
 * Return status of the specified listing purchase
 *
 * @methodGroup Status
 * @namedParams
 * @param {string} listingId - The ID of the listing
 * @param {string} confirmationId - The confirmation ID of the purchase
 *
 * @returns {Promise&lt;Object>} - The status of the purchase
 */
exports.ListingPurchaseStatus = async function({listingId, confirmationId}) {
  try {
    const listingStatus = await this.ListingStatus({listingId});

    if(!listingStatus) {
      throw Error("Unable to find info for listing " + listingId);
    }

    const statuses = await this.MintingStatus({tenantId: listingStatus.tenant});

    return statuses
      .find(status =>
        status.op === "nft-transfer" &amp;&amp;
        status.extra &amp;&amp; status.extra[0] === confirmationId
      ) || { status: "none" };
  } catch(error) {
    this.Log(error, true);
    return { status: "unknown" };
  }
};

/**
 * Return status of the specified marketplace purchase
 *
 * @methodGroup Status
 * @namedParams
 * @param {Object} marketplaceParams - Parameters of the marketplace
 * @param {string} confirmationId - The confirmation ID of the purchase
 *
 * @returns {Promise&lt;Object>} - The minting status of the purchaseed item(s)
 */
exports.PurchaseStatus = async function({marketplaceParams, confirmationId}) {
  try {
    const marketplaceInfo = await this.MarketplaceInfo({marketplaceParams});
    const statuses = await this.MintingStatus({tenantId: marketplaceInfo.tenant_id});

    return statuses.find(status => status.op === "nft-buy" &amp;&amp; status.confirmationId === confirmationId) || { status: "none" };
  } catch(error) {
    this.Log(error, true);
    return { status: "unknown" };
  }
};

/**
 * Return status of the specified item claim
 *
 * @methodGroup Status
 * @namedParams
 * @param {Object} marketplaceParams - Parameters of the marketplace
 * @param {string} sku - The SKU of the item claimed
 *
 * @returns {Promise&lt;Object>} - The minting status of the claim
 */
exports.ClaimStatus = async function({marketplaceParams, sku}) {
  try {
    const marketplaceInfo = await this.MarketplaceInfo({marketplaceParams});
    const statuses = await this.MintingStatus({tenantId: marketplaceInfo.tenantId});

    return statuses.find(status => status.op === "nft-claim" &amp;&amp; status.marketplaceId === marketplaceInfo.marketplaceId &amp;&amp; status.confirmationId === sku) || { status: "none" };
  } catch(error) {
    this.Log(error, true);
    return { status: "unknown" };
  }
};

/**
 * Return status of the specified pack opening
 *
 * @methodGroup Status
 * @namedParams
 * @param {string} contractAddress - The NFT contract address of the opened pack
 * @param {string} tokenId - The token ID of the opened pack
 *
 * @returns {Promise&lt;Object>} - The status of the pack opening
 */
exports.PackOpenStatus = async function({contractAddress, tokenId}) {
  try {
    const tenantConfig = await this.TenantConfiguration({contractAddress});

    const statuses = await this.MintingStatus({tenantId: tenantConfig.tenant});

    return statuses.find(status => status.op === "nft-open" &amp;&amp; Utils.EqualAddress(contractAddress, status.address) &amp;&amp; status.tokenId === tokenId) || { status: "none" };
  } catch(error) {
    this.Log(error, true);
    return { status: "unknown" };
  }
};

/**
 * Return status of the specified collection redemption
 *
 * @methodGroup Status
 * @namedParams
 * @param {Object} marketplaceParams - Parameters of the marketplace
 * @param {string} confirmationId - The confirmation ID of the redemption
 *
 * @returns {Promise&lt;Object>} - The status of the collection redemption
 */
exports.CollectionRedemptionStatus = async function({marketplaceParams, confirmationId}) {
  try {
    const statuses = await this.MintingStatus({marketplaceParams});

    return statuses.find(status => status.op === "nft-redeem" &amp;&amp; status.confirmationId === confirmationId) || { status: "none" };
  } catch(error) {
    this.Log(error, true);
    return { status: "unknown" };
  }
};

/**
 * Return status of the specified redeemable offer
 *
 * @methodGroup Status
 * @namedParams
 * @param {string=} tenantId - ID of the tenant for this NFT (not required if `marketplaceParams` is specified)
 * @param {Object=} marketplaceParams - Parameters of the marketplace for this NFT (not required if `tenantId` is specified)
 * @param {string} contractAddress - The address of the NFT contract
 * @param {string} tokenId - The token ID of the NFT
 * @param {string} offerId - The ID of the offer
 *
 * @returns {Promise&lt;Object>} - The status of the offer redemption
 */
exports.RedeemableOfferStatus = async function({tenantId, marketplaceParams, contractAddress, tokenId, offerId}) {
  try {
    const statuses = await this.MintingStatus({marketplaceParams, tenantId});
    contractAddress = Utils.FormatAddress(contractAddress);

    return statuses.find(status =>
      status.op === "nft-offer-redeem" &amp;&amp;
      Utils.EqualAddress(status.address, contractAddress) &amp;&amp;
      status.tokenId === (tokenId || "").toString() &amp;&amp;
      status.extra &amp;&amp; typeof status.extra[0] !== "undefined" &amp;&amp; status.extra[0].toString() === (offerId || "").toString()
    ) || { status: "none" };
  } catch(error) {
    this.Log(error, true);
    return { status: "unknown" };
  }
};

exports.RedeemableCustomFulfillmentInfo = async function({redeemableTransactionId}) {
  return await Utils.ResponseToJson(
    this.stateStoreClient.Request({
      method: "GET",
      path: UrlJoin("code-fulfillment", this.network === "main" ? "main" : "demov3", "fulfill", redeemableTransactionId),
      headers: {
        Authorization: `Bearer ${this.AuthToken()}`
      }
    })
  );
};


/* EVENTS */


exports.LoadDrop = async function({tenantSlug, eventSlug, dropId}) {
  if(!this.drops){
    this.drops = {};
  }

  if(!this.drops[tenantSlug]) {
    this.drops[tenantSlug] = {};
  }

  if(!this.drops[tenantSlug][eventSlug]) {
    this.drops[tenantSlug][eventSlug] = {};
  }

  if(!this.drops[tenantSlug][eventSlug][dropId]) {
    const event = (await this.client.ContentObjectMetadata({
      libraryId: this.mainSiteLibraryId,
      objectId: this.mainSiteId,
      metadataSubtree: UrlJoin("public", "asset_metadata", "tenants", tenantSlug, "sites", eventSlug, "info"),
      resolveLinks: true,
      linkDepthLimit: 2,
      resolveIncludeSource: true,
      produceLinkUrls: true,
      select: [".", "drops"],
      noAuth: true
    })) || [];

    const eventId = Utils.DecodeVersionHash(event["."].source).objectId;

    event.drops.forEach(drop => {
      drop = {
        ...drop,
        eventId
      };

      this.drops[tenantSlug][eventSlug][drop.uuid] = drop;
      this.drops[drop.uuid] = drop;
    });
  }

  return this.drops[dropId];
};

exports.SubmitDropVote = async function({marketplaceParams, eventId, dropId, sku}) {
  const marketplaceInfo = await this.MarketplaceInfo({marketplaceParams});
  await this.client.authClient.MakeAuthServiceRequest({
    path: UrlJoin("as", "wlt", "act", marketplaceInfo.tenant_id),
    method: "POST",
    body: {
      op: "vote-drop",
      evt: eventId,
      id: dropId,
      itm: sku
    },
    headers: {
      Authorization: `Bearer ${this.AuthToken()}`
    }
  });
};

exports.DropStatus = async function({marketplace, eventId, dropId}) {
  try {
    const response = await Utils.ResponseToJson(
      this.client.authClient.MakeAuthServiceRequest({
        path: UrlJoin("as", "wlt", "act", marketplace.tenant_id, eventId, dropId),
        method: "GET",
        headers: {
          Authorization: `Bearer ${this.AuthToken()}`
        }
      })
    );

    return response.sort((a, b) => a.ts > b.ts ? 1 : -1)[0] || { status: "none" };
  } catch(error) {
    this.Log(error, true);
    return "";
  }
};


/* OFFERS */

/**
 * Retrieve offers for the specified parameters
 *
 * @methodGroup Offers
 * @namedParams
 * @param {string=} contractAddress - The address of an NFT contract
 * @param {string=} tokenId - The token ID of an NFT
 * @param {string=} buyerAddress - The address of the offerrer
 * @param {string=} sellerAddress - The address of the offerree
 * @param {Array&lt;String>=} statuses - Status to filter results by. Allowed values: "ACTIVE", "ACCEPTED", "CANCELLED", "DECLINED", "INVALID"
 * @param {number} start=0 - The index to start from
 * @param {number=} limit=10 - The maximum number of results to return
 *
 * @returns {Promise&lt;Array&lt;Object>>} - Offers matching the specified filters
 */
exports.MarketplaceOffers = async function({contractAddress, tokenId, buyerAddress, sellerAddress, statuses, start=0, limit=10}) {
  let path = UrlJoin("as", "mkt", "offers", "ls");
  if(buyerAddress) {
    path = UrlJoin(path, "b", Utils.FormatAddress(buyerAddress));
  } else if(sellerAddress) {
    path = UrlJoin(path, "s", Utils.FormatAddress(sellerAddress));
  }

  if(contractAddress) {
    path = UrlJoin(path, "c", Utils.FormatAddress(contractAddress));

    if(tokenId) {
      path = UrlJoin(path, "t", tokenId);
    }
  }

  let queryParams = {
    start,
    limit
  };

  if(statuses &amp;&amp; statuses.length > 0) {
    queryParams.include = statuses.join(",");
  }

  const offers = await Utils.ResponseToJson(
    this.client.authClient.MakeAuthServiceRequest({
      path: path,
      method: "GET",
      queryParams
    })
  );

  return offers
    .map(offer => ({
      ...offer,
      created: offer.created * 1000,
      updated: offer.updated * 1000,
      expiration: offer.expiration * 1000
    }));
};

/**
 * &lt;b>&lt;i>Requires login&lt;/i>&lt;/b>
 *
 * Create or update an offer on the specified NFT
 *
 * @methodGroup Offers
 * @namedParams
 * @param {string} contractAddress - The contract address of the NFT
 * @param {string} tokenId - The token ID of the NFT
 * @param {string=} offerId - IF modifying an existing offer, the ID of the offer
 * @param {number} price - The amount to offer
 * @param {number=} expiresAt - The time (in epoch ms) the offer will expire
 *
 * @returns {Promise&lt;Object>} - Info about the created/updated offer
 */
exports.CreateMarketplaceOffer = async function({contractAddress, tokenId, offerId, price, expiresAt}) {
  let response;
  if(offerId) {
    response = await Utils.ResponseToJson(
      this.client.authClient.MakeAuthServiceRequest({
        path: UrlJoin("as", "wlt", "mkt", "offers", offerId),
        method: "PUT",
        body: {
          price,
          expiration: Math.floor(expiresAt / 1000)
        },
        headers: {
          Authorization: `Bearer ${this.AuthToken()}`
        }
      })
    );
  } else {
    response = await Utils.ResponseToJson(
      this.client.authClient.MakeAuthServiceRequest({
        path: UrlJoin("as", "wlt", "mkt", "offers", contractAddress, tokenId),
        method: "POST",
        body: {
          contract: contractAddress,
          token: tokenId,
          price,
          expiration: Math.floor(expiresAt / 1000)
        },
        headers: {
          Authorization: `Bearer ${this.AuthToken()}`
        }
      })
    );
  }

  return response.offer_id;
};

/**
 * &lt;b>&lt;i>Requires login&lt;/i>&lt;/b>
 *
 * Cancel the specified offer
 *
 * @methodGroup Offers
 * @namedParams
 * @param {string} offerId - The ID of the offer
 */
exports.RemoveMarketplaceOffer = async function({offerId}) {
  return await this.client.authClient.MakeAuthServiceRequest({
    path: UrlJoin("as", "wlt", "mkt", "offers", offerId),
    method: "DELETE",
    headers: {
      Authorization: `Bearer ${this.AuthToken()}`
    }
  });
};

/**
 * &lt;b>&lt;i>Requires login&lt;/i>&lt;/b>
 *
 * Accept the specified offer
 *
 * @methodGroup Offers
 * @namedParams
 * @param {string} offerId - The ID of the offer
 */
exports.AcceptMarketplaceOffer = async function({offerId}) {
  return await this.client.authClient.MakeAuthServiceRequest({
    path: UrlJoin("as", "wlt", "mkt", "offers", "accept", offerId),
    method: "PUT",
    headers: {
      Authorization: `Bearer ${this.AuthToken()}`
    }
  });
};

/**
 * &lt;b>&lt;i>Requires login&lt;/i>&lt;/b>
 *
 * Reject the specified offer
 *
 * @methodGroup Offers
 * @namedParams
 * @param {string} offerId - The ID of the offer
 */
exports.RejectMarketplaceOffer = async function({offerId}) {
  return await this.client.authClient.MakeAuthServiceRequest({
    path: UrlJoin("as", "wlt", "mkt", "offers", "decline", offerId),
    method: "PUT",
    headers: {
      Authorization: `Bearer ${this.AuthToken()}`
    }
  });
};


/* Voting */

/**
 * Retrieve the current status of the specified voting event
 *
 * @methodGroup Voting
 * @namedParams
 * @param {string} tenantId - The tenant ID of the marketplace in which the voting event is specified
 * @param {string} votingEventId - The ID of the voting event
 *
 * @returns {Promise&lt;Object>} - Info about the voting event, including the current user's votes and the current total voting tally
 */
exports.VoteStatus = async function ({tenantId, votingEventId}) {
  return await Utils.ResponseToJson(
    this.client.authClient.MakeAuthServiceRequest({
      path: UrlJoin("as", "votes", tenantId, votingEventId),
      headers: {
        Authorization: `Bearer ${this.AuthToken()}`
      }
    })
  );
};

/**
 * &lt;b>&lt;i>Requires login&lt;/i>&lt;/b>
 *
 * Cast a vote for the specified item in the specified voting event
 *
 * @methodGroup Voting
 * @namedParams
 * @param {string} tenantId - The tenant ID of the marketplace in which the voting event is specified
 * @param {string} votingEventId - The ID of the voting event
 * @param {string} sku - The SKU of the item to vote for
 *
 * @returns {Promise&lt;Object>} - Info about the voting event, including the current user's votes and the current total voting tally
 */
exports.CastVote = async function ({tenantId, votingEventId, sku}) {
  return await Utils.ResponseToJson(
    this.client.authClient.MakeAuthServiceRequest({
      path: UrlJoin("as", "votes", tenantId, votingEventId, sku),
      method: "POST",
      headers: {
        Authorization: `Bearer ${this.AuthToken()}`
      }
    })
  );
};

/**
 * &lt;b>&lt;i>Requires login&lt;/i>&lt;/b>
 *
 * Revoke a previously cast vote for the specified item in the specified voting event
 *
 * @methodGroup Voting
 * @namedParams
 * @param {string} tenantId - The tenant ID of the marketplace in which the voting event is specified
 * @param {string} votingEventId - The ID of the voting event
 * @param {string} sku - The SKU of the item to vote for
 *
 * @returns {Promise&lt;Object>} - Info about the voting event, including the current user's votes and the current total voting tally
 */
exports.RevokeVote = async function ({tenantId, votingEventId, sku}) {
  return await Utils.ResponseToJson(
    this.client.authClient.MakeAuthServiceRequest({
      path: UrlJoin("as", "votes", tenantId, votingEventId, sku),
      method: "DELETE",
      headers: {
        Authorization: `Bearer ${this.AuthToken()}`
      }
    })
  );
};
</code></pre>
</div>

    



        <footer class="footer">
          Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.2</a>
        </footer>
      </div>
    </div>
  </div>

  <script>
    // Format and add line numbers to code
    prettyPrint();
  </script>

  <script type="text/javascript" src="scripts/utils.js"></script>

  </body>
</html>
