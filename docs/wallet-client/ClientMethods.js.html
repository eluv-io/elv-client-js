

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="shortcut icon" href="images/favicon.png" >

  <title>
    ClientMethods.js - Documentation
  </title>

  <script src="scripts/prettify/prettify.js"></script>
  <script src="scripts/prettify/lang-css.js"></script>

  <link type="text/css" rel="stylesheet" href="styles/elv-jsdoc.css">
  <link type="text/css" rel="stylesheet" href="styles/elv-prettify-jsdoc.css">
</head>

<body>
  <div class="layout-container">
    <nav class="nav-container">
      <div class="header">
        <a href="index.html">
          <img class="logo" src="images/logo-dark.png" />
        </a>
        <div class="title">
          Eluvio Wallet Client
        </div>
      </div>
      <div class="nav-content">
        <h3>Classes</h3><ul><li id="ElvWalletClient-nav">
          <div data-name="ElvWalletClient" class="class-link-container"><a class="class-link">ElvWalletClient</a></div><ul class='methods'><h4 class="methodGroupHeader">Constructor</h4><li data-type="method" id="ElvWalletClient-ElvWalletClient-nav"><a href="ElvWalletClient.html" class="method-link">ElvWalletClient</a></li><h4 class="methodGroupHeader">Authorization</h4><li data-type="method" id="ElvWalletClient-Authenticate-nav"><a href="ElvWalletClient.html#Authenticate" class="method-link">Authenticate</a></li><li data-type="method" id="ElvWalletClient-AuthenticateExternalWallet-nav"><a href="ElvWalletClient.html#AuthenticateExternalWallet" class="method-link">AuthenticateExternalWallet</a></li><li data-type="method" id="ElvWalletClient-AuthenticateOAuth-nav"><a href="ElvWalletClient.html#AuthenticateOAuth" class="method-link">AuthenticateOAuth</a></li><h4 class="methodGroupHeader">Initialization</h4><li data-type="method" id="ElvWalletClient-Initialize-nav"><a href="ElvWalletClient.html#.Initialize" class="method-link">Initialize</a></li><h4 class="methodGroupHeader">Login</h4><li data-type="method" id="ElvWalletClient-LogIn-nav"><a href="ElvWalletClient.html#LogIn" class="method-link">LogIn</a></li><li data-type="method" id="ElvWalletClient-LogOut-nav"><a href="ElvWalletClient.html#LogOut" class="method-link">LogOut</a></li><h4 class="methodGroupHeader">Methods</h4><li data-type="method" id="ElvWalletClient-ClientAuthToken-nav"><a href="ElvWalletClient.html#ClientAuthToken" class="method-link">ClientAuthToken</a></li></ul></li></ul><h3>Modules</h3><ul><li id="ClientMethods-nav">
          <div data-name="ClientMethods" class="class-link-container"><a class="class-link">ClientMethods</a></div><ul class='methods'><li data-type="method" id="ClientMethods-ClientMethods-nav"><a href="module-ClientMethods.html" class="method-link">ClientMethods</a></li><h4 class="methodGroupHeader">Items</h4><li data-type="method" id="ClientMethods-NFT-nav"><a href="module-ClientMethods.html#.NFT" class="method-link">NFT</a></li><h4 class="methodGroupHeader">Listings</h4><li data-type="method" id="ClientMethods-CreateListing-nav"><a href="module-ClientMethods.html#.CreateListing" class="method-link">CreateListing</a></li><li data-type="method" id="ClientMethods-Listing-nav"><a href="module-ClientMethods.html#.Listing" class="method-link">Listing</a></li><li data-type="method" id="ClientMethods-ListingAttributes-nav"><a href="module-ClientMethods.html#.ListingAttributes" class="method-link">ListingAttributes</a></li><li data-type="method" id="ClientMethods-ListingEditionNames-nav"><a href="module-ClientMethods.html#.ListingEditionNames" class="method-link">ListingEditionNames</a></li><li data-type="method" id="ClientMethods-ListingNames-nav"><a href="module-ClientMethods.html#.ListingNames" class="method-link">ListingNames</a></li><li data-type="method" id="ClientMethods-Listings-nav"><a href="module-ClientMethods.html#.Listings" class="method-link">Listings</a></li><li data-type="method" id="ClientMethods-ListingStats-nav"><a href="module-ClientMethods.html#.ListingStats" class="method-link">ListingStats</a></li><li data-type="method" id="ClientMethods-ListingStatus-nav"><a href="module-ClientMethods.html#.ListingStatus" class="method-link">ListingStatus</a></li><li data-type="method" id="ClientMethods-RemoveListing-nav"><a href="module-ClientMethods.html#.RemoveListing" class="method-link">RemoveListing</a></li><li data-type="method" id="ClientMethods-Sales-nav"><a href="module-ClientMethods.html#.Sales" class="method-link">Sales</a></li><li data-type="method" id="ClientMethods-SalesStats-nav"><a href="module-ClientMethods.html#.SalesStats" class="method-link">SalesStats</a></li><h4 class="methodGroupHeader">Marketplaces</h4><li data-type="method" id="ClientMethods-AvailableMarketplaces-nav"><a href="module-ClientMethods.html#.AvailableMarketplaces" class="method-link">AvailableMarketplaces</a></li><li data-type="method" id="ClientMethods-Marketplace-nav"><a href="module-ClientMethods.html#.Marketplace" class="method-link">Marketplace</a></li><li data-type="method" id="ClientMethods-MarketplaceCSS-nav"><a href="module-ClientMethods.html#.MarketplaceCSS" class="method-link">MarketplaceCSS</a></li><li data-type="method" id="ClientMethods-MarketplaceInfo-nav"><a href="module-ClientMethods.html#.MarketplaceInfo" class="method-link">MarketplaceInfo</a></li><li data-type="method" id="ClientMethods-MarketplaceStock-nav"><a href="module-ClientMethods.html#.MarketplaceStock" class="method-link">MarketplaceStock</a></li><h4 class="methodGroupHeader">NFT</h4><li data-type="method" id="ClientMethods-TransferNFT-nav"><a href="module-ClientMethods.html#.TransferNFT" class="method-link">TransferNFT</a></li><h4 class="methodGroupHeader">Status</h4><li data-type="method" id="ClientMethods-ClaimStatus-nav"><a href="module-ClientMethods.html#.ClaimStatus" class="method-link">ClaimStatus</a></li><li data-type="method" id="ClientMethods-CollectionRedemptionStatus-nav"><a href="module-ClientMethods.html#.CollectionRedemptionStatus" class="method-link">CollectionRedemptionStatus</a></li><li data-type="method" id="ClientMethods-ListingPurchaseStatus-nav"><a href="module-ClientMethods.html#.ListingPurchaseStatus" class="method-link">ListingPurchaseStatus</a></li><li data-type="method" id="ClientMethods-PackOpenStatus-nav"><a href="module-ClientMethods.html#.PackOpenStatus" class="method-link">PackOpenStatus</a></li><li data-type="method" id="ClientMethods-PurchaseStatus-nav"><a href="module-ClientMethods.html#.PurchaseStatus" class="method-link">PurchaseStatus</a></li><h4 class="methodGroupHeader">Tenants</h4><li data-type="method" id="ClientMethods-TenantConfiguration-nav"><a href="module-ClientMethods.html#.TenantConfiguration" class="method-link">TenantConfiguration</a></li><h4 class="methodGroupHeader">User</h4><li data-type="method" id="ClientMethods-UserAddress-nav"><a href="module-ClientMethods.html#.UserAddress" class="method-link">UserAddress</a></li><li data-type="method" id="ClientMethods-UserInfo-nav"><a href="module-ClientMethods.html#.UserInfo" class="method-link">UserInfo</a></li><li data-type="method" id="ClientMethods-UserItemInfo-nav"><a href="module-ClientMethods.html#.UserItemInfo" class="method-link">UserItemInfo</a></li><li data-type="method" id="ClientMethods-UserItems-nav"><a href="module-ClientMethods.html#.UserItems" class="method-link">UserItems</a></li><li data-type="method" id="ClientMethods-UserListings-nav"><a href="module-ClientMethods.html#.UserListings" class="method-link">UserListings</a></li><li data-type="method" id="ClientMethods-UserSales-nav"><a href="module-ClientMethods.html#.UserSales" class="method-link">UserSales</a></li><li data-type="method" id="ClientMethods-UserWalletBalance-nav"><a href="module-ClientMethods.html#.UserWalletBalance" class="method-link">UserWalletBalance</a></li></ul></li></ul>
      </div>
    </nav>

    <div class="main">
      <div class="header"></div>
      <div class="main-content">
        
        <h1 class="page-title">
          ClientMethods.js
        </h1>
        

        
      

<a class="button" href="ClientMethods.html">Back</a>
<div class="source-container">
  <pre class="prettyprint source linenums"><code>const Utils = require("../Utils");
const UrlJoin = require("url-join");
const {FormatNFTDetails, FormatNFTMetadata, FormatNFT} = require("./Utils");

/**
 * Methods
 *
 * @module ClientMethods
 */

/* USER INFO */


/**
 * &lt;b>&lt;i>Requires login&lt;/i>&lt;/b>
 *
 * Retrieve information about the user, including the address, wallet type, and (for custodial users) email address.
 *
 * @methodGroup User
 *
 * @returns {Object} - User info
 */
exports.UserInfo = function() {
  if(!this.loggedIn) { return; }

  return {
    address: this.UserAddress() ,
    email: this.__authorization.email,
    walletType: this.__authorization.walletType,
    walletName: this.__authorization.walletName
  };
};

/**
 * &lt;b>&lt;i>Requires login&lt;/i>&lt;/b>
 *
 * Retrieve the address of the current user.
 *
 * @methodGroup User
 *
 * @returns {string} - The address of the current user
 */
exports.UserAddress = function() {
  if(!this.loggedIn) { return; }

  return this.client.utils.DecodeSignedToken(this.AuthToken()).payload.adr;
};

/**
 * &lt;b>&lt;i>Requires login&lt;/i>&lt;/b>
 *
 * Retrieve the fund balances for the current user
 *
 * @methodGroup User
 * @returns {Promise&lt;{Object}>} - Returns balances for the user. All values are in USD.
 *  &lt;ul>
 *  &lt;li>- totalWalletBalance - Total balance of the users sales and wallet balance purchases&lt;/li>
 *  &lt;li>- availableWalletBalance - Balance available for purchasing items&lt;/li>
 *  &lt;li>- pendingWalletBalance - Balance unavailable for purchasing items&lt;/li>
 *  &lt;li>- withdrawableWalletBalance - Amount that is available for withdrawal&lt;/li>
 *  &lt;li>- usedBalance - &lt;i>(Only included if user has set up Solana link with the Phantom wallet)&lt;/i> Available USDC balance of the user's Solana wallet&lt;/li>
 *  &lt;/ul>
 */
exports.UserWalletBalance = async function(checkOnboard=false) {
  if(!this.loggedIn) { return; }

  // eslint-disable-next-line no-unused-vars
  const { balance, usage_hold, payout_hold, stripe_id, stripe_payouts_enabled } = await this.client.utils.ResponseToJson(
    await this.client.authClient.MakeAuthServiceRequest({
      path: UrlJoin("as", "wlt", "mkt", "bal"),
      method: "GET",
      headers: {
        Authorization: `Bearer ${this.AuthToken()}`
      }
    })
  );

  const userStripeId = stripe_id;
  const userStripeEnabled = stripe_payouts_enabled;
  const totalWalletBalance = parseFloat(balance || 0);
  const availableWalletBalance = Math.max(0, totalWalletBalance - parseFloat(usage_hold || 0));
  const pendingWalletBalance = Math.max(0, totalWalletBalance - availableWalletBalance);
  const withdrawableWalletBalance = Math.max(0, totalWalletBalance - parseFloat(payout_hold || 0));

  if(checkOnboard &amp;&amp; stripe_id &amp;&amp; !stripe_payouts_enabled) {
    // Refresh stripe enabled flag
    const rootUrl = new URL(UrlJoin(window.location.origin, window.location.pathname)).toString();
    await this.client.authClient.MakeAuthServiceRequest({
      path: UrlJoin("as", "wlt", "onb", "stripe"),
      method: "POST",
      body: {
        country: "US",
        mode: this.mode,
        refresh_url: rootUrl.toString(),
        return_url: rootUrl.toString()
      },
      headers: {
        Authorization: `Bearer ${this.AuthToken()}`
      }
    });

    return await this.UserWalletBalance(false);
  }

  let balances = {
    totalWalletBalance,
    availableWalletBalance,
    pendingWalletBalance,
    withdrawableWalletBalance,
  };

  if(userStripeEnabled) {
    balances.userStripeId = userStripeId;
    balances.userStripeEnabled = userStripeEnabled;
  }

  // TODO: integrate
  /*
  if(cryptoStore.usdcConnected) {
    balances.usdcBalance = cryptoStore.phantomUSDCBalance;
  }

   */

  return balances;
};


/**
 * &lt;b>&lt;i>Requires login&lt;/i>&lt;/b>
 *
 * Returns basic contract info about the items the current user owns, organized by contract address + token ID
 *
 * This method is significantly faster than &lt;a href="#.UserItems">UserItems&lt;/a>, but does not include any NFT metadata.
 *
 * @methodGroup User
 *
 * @returns {Promise&lt;Object>} - Basic info about all owned items.
 */
exports.UserItemInfo = async function () {
  if(!this.loggedIn) { return {}; }

  const accountId = `iusr${Utils.AddressToHash(this.UserAddress())}`;
  this.profileData = await this.client.ethClient.MakeProviderCall({
    methodName: "send",
    args: [
      "elv_getAccountProfile",
      [this.client.contentSpaceId, accountId]
    ]
  });

  if(!this.profileData || !this.profileData.NFTs) { return {}; }

  let nftInfo = {};
  Object.keys(this.profileData.NFTs).map(tenantId =>
    this.profileData.NFTs[tenantId].forEach(details => {
      const versionHash = (details.TokenUri || "").split("/").find(s => (s || "").startsWith("hq__"));

      if(!versionHash) {
        return;
      }

      if(details.TokenHold) {
        details.TokenHoldDate = new Date(parseInt(details.TokenHold) * 1000);
      }

      const contractAddress = Utils.FormatAddress(details.ContractAddr);
      const key = `${contractAddress}-${details.TokenIdStr}`;
      nftInfo[key] = {
        ...details,
        ContractAddr: Utils.FormatAddress(details.ContractAddr),
        ContractId: `ictr${Utils.AddressToHash(details.ContractAddr)}`,
        VersionHash: versionHash
      };
    })
  );

  this.nftInfo = nftInfo;

  return this.nftInfo;
};


/**
 * &lt;b>&lt;i>Requires login&lt;/i>&lt;/b>
 *
 * Retrieve items owned by the current user matching the specified parameters.
 *
 * @methodGroup User
 * @namedParams
 * @param {integer=} start=0 - PAGINATION: Index from which the results should start
 * @param {integer=} limit=50 - PAGINATION: Maximum number of results to return
 * @param {string=} sortBy="created" - Sort order. Options: `default`, `meta/display_name`
 * @param {boolean=} sortDesc=false - Sort results descending instead of ascending
 * @param {string=} filter - Filter results by item name.
 * @param {string=} contractAddress - Filter results by the address of the NFT contract
 * @param {string=} tokenId - Filter by token ID (if filtering by contract address)
 * @param {Object=} marketplaceParams - Filter results by marketplace
 * @param {integer=} collectionIndex - If filtering by marketplace, filter by collection. The index refers to the index in the array `marketplace.collections`
 *
 * @returns {Promise&lt;Object>} - Results of the query and pagination info
 */
exports.UserItems = async function() {
  return this.FilteredQuery({mode: "owned", ...(arguments[0] || {})});
};

/**
 * Return all listings for the current user. Not paginated.
 *
 * @methodGroup User
 * @namedParams
 * @param {string=} sortBy="created" - Sort order. Options: `created`, `info/token_id`, `info/ordinal`, `price`, `nft/display_name`
 * @param {boolean=} sortDesc=false - Sort results descending instead of ascending
 * @param {Object=} marketplaceParams - Filter results by marketplace
 * @param {string=} contractAddress - Filter results by the address of the NFT contract
 * @param {string=} tokenId - Filter by token ID (if filtering by contract address)
 *
 * @returns {Promise&lt;Array&lt;Object>>} - List of current user's listings
 */
exports.UserListings = async function({sortBy="created", sortDesc=false, contractAddress, tokenId, marketplaceParams}={}) {
  return (
    await this.FilteredQuery({
      mode: "listings",
      start: 0,
      limit: 10000,
      sortBy,
      sortDesc,
      sellerAddress: this.UserAddress(),
      marketplaceParams,
      contractAddress,
      tokenId
    })
  ).results;
};

/**
 * Return all sales for the current user. Not paginated.
 *
 * @methodGroup User
 * @namedParams
 * @param {string=} sortBy="created" - Sort order. Options: `created`, `price`, `name`
 * @param {boolean=} sortDesc=false - Sort results descending instead of ascending
 * @param {Object=} marketplaceParams - Filter results by marketplace
 * @param {string=} contractAddress - Filter results by the address of the NFT contract
 * @param {string=} tokenId - Filter by token ID (if filtering by contract address)
 * @param {integer=} lastNDays - Filter by results listed in the past N days
 *
 * @returns {Promise&lt;Array&lt;Object>>} - List of current user's sales
 */
exports.UserSales = async function({sortBy="created", sortDesc=false, contractAddress, tokenId, marketplaceParams}={}) {
  return (
    await this.FilteredQuery({
      mode: "sales",
      start: 0,
      limit: 10000,
      sortBy,
      sortDesc,
      sellerAddress: this.UserAddress(),
      marketplaceParams,
      contractAddress,
      tokenId
    })
  ).results;
};


/* TENANT */

/**
 * Retrieve configuration information about the specified tenant, or the tenant associated with the specified contract.
 *
 * This information includes the royalty rate the tenant receives for secondary sales.
 *
 * @methodGroup Tenants
 * @namedParams
 * @param {string=} tenantId - The ID of the tenant for which to retrieve configuration
 * @param {string=} contractAddress - The ID of an nft contract for which to retrieve configuration
 *
 * @returns {Promise&lt;{Object}>} - The tenant configuration
 */
exports.TenantConfiguration = async function({tenantId, contractAddress}) {
  try {
    return await Utils.ResponseToJson(
      this.client.authClient.MakeAuthServiceRequest({
        path: contractAddress ?
          UrlJoin("as", "config", "nft", contractAddress) :
          UrlJoin("as", "config", "tnt", tenantId),
        method: "GET",
      })
    );
  } catch(error) {
    this.Log("Failed to load tenant configuration", true);
    this.Log(error, true);

    return {};
  }
};


/* MARKETPLACE */

/**
 * Retrieve available stock for the specified marketplace, organized by SKU.
 *
 * If a user is logged in, stock information will also include how many of that item the user has purchased.
 *
 * @methodGroup Marketplaces
 * @namedParams
 * @param {Object} marketplaceParams - Parameters of the marketplace
 *
 * @returns {Promise&lt;Object>} - Stock info for items in the marketplace
 */
exports.MarketplaceStock = async function ({marketplaceParams, tenantId}) {
  if(!tenantId) {
    const marketplaceInfo = this.MarketplaceInfo({marketplaceParams});
    tenantId = marketplaceInfo.tenantId;
  }

  if(this.loggedIn) {
    return await Utils.ResponseToJson(
      this.client.authClient.MakeAuthServiceRequest({
        path: UrlJoin("as", "wlt", "nft", "info", tenantId),
        method: "GET",
        headers: {
          Authorization: `Bearer ${this.AuthToken()}`
        }
      })
    );
  }

  return await Utils.ResponseToJson(
    this.client.authClient.MakeAuthServiceRequest({
      path: UrlJoin("as", "nft", "stock", tenantId),
      method: "GET"
    })
  );
};

/**
 * Retrieve basic information about a specific available marketplace with the specified tenant/marketplace slug, ID, or hash.
 *
 * Includes the slugs, ID and hash of the marketplace, as well as branding information.
 *
 * To retrieve full metadata for the marketplace, use the &lt;a href="#.Marketplace">Marketplace&lt;/a> method.
 *
 * @methodGroup Marketplaces
 * @namedParams
 * @param {Object} marketplaceParams - Parameters of the marketplace
 *
 * @returns {Promise&lt;Object>} - Info about the marketplace
 */
exports.MarketplaceInfo = function ({marketplaceParams}) {
  let { tenantSlug, marketplaceSlug, marketplaceId, marketplaceHash } = (marketplaceParams || {});

  let marketplaceInfo;
  if(tenantSlug &amp;&amp; marketplaceSlug) {
    marketplaceInfo = (this.availableMarketplaces[tenantSlug] || {})[marketplaceSlug];
  } else {
    marketplaceId = marketplaceHash ? this.client.utils.DecodeVersionHash(marketplaceHash).objectId : marketplaceId;
    marketplaceInfo = this.availableMarketplacesById[marketplaceId];
  }

  if(!marketplaceInfo) {
    throw Error(`Eluvio Wallet Client: Unable to find marketplace with parameters ${JSON.stringify(arguments)}`);
  }

  return marketplaceInfo;
};

/**
 * Retrieve custom CSS for the specified marketplace
 *
 * @methodGroup Marketplaces
 * @namedParams
 * @param {Object} marketplaceParams - Parameters of the marketplace
 *
 * @returns {Promise&lt;string>} - The CSS of the marketplace
 */
exports.MarketplaceCSS = async function ({marketplaceParams}) {
  const marketplaceInfo = this.MarketplaceInfo({marketplaceParams});

  const marketplaceHash = marketplaceInfo.marketplaceHash;

  if(!this.cachedCSS[marketplaceHash]) {
    this.cachedCSS[marketplaceHash] = await this.client.ContentObjectMetadata({
      versionHash: marketplaceHash,
      metadataSubtree: "public/asset_metadata/info/branding/custom_css",
      authorizationToken: this.publicStaticToken,
      noAuth: true
    });
  }

  return this.cachedCSS[marketplaceHash] || "";
};

/**
 * Retrieve info about all available marketplaces
 *
 * @methodGroup Marketplaces
 * @namedParams
 * @param {boolean=} organizeById - By default, the returned marketplace info is organized by tenant and marketplace slug. If this option is enabled, the marketplaces will be organized by marketplace ID instead.
 * @param {boolean=} forceReload=false - If specified, a new request will be made to check the currently available marketplaces instead of returning cached info
 *
 * @returns {Promise&lt;{Object}>} - Info about available marketplaces
 */
exports.AvailableMarketplaces = async function ({organizeById, forceReload=false}={}) {
  if(forceReload) {
    await this.LoadAvailableMarketplaces(true);
  }

  return {
    ...(organizeById ? this.availableMarketplacesById : this.availableMarketplaces)
  };
};

/**
 * Retrieve full information about the specified marketplace
 *
 * &lt;b>&lt;i>Note&lt;/i>&lt;/b> - Upon changing login state, the marketplace should be retrieved again as permission info in marketplace items may be different depending on the current user's permissions.
 *
 * @methodGroup Marketplaces
 * @namedParams
 * @param {Object} marketplaceParams - Parameters of the marketplace
 *
 * @returns {Promise&lt;Object>} - The full information for the marketplace
 */
exports.Marketplace = async function ({marketplaceParams}) {
  return this.LoadMarketplace(marketplaceParams);
};


/* NFTS */

/**
 * Load full info for the specified NFT
 *
 * @methodGroup Items
 * @namedParams
 * @param {string} contractAddress - The contract address of the NFT
 * @param {string} tokenId - The token ID of the NFT
 */
exports.NFT = async function({tokenId, contractAddress}) {
  let nft = FormatNFTDetails(
    await Utils.ResponseToJson(
      this.client.authClient.MakeAuthServiceRequest({
        path: UrlJoin("as", "nft", "info", contractAddress, tokenId),
        method: "GET"
      })
    )
  );

  nft.metadata = {
    ...(
      (await this.client.ContentObjectMetadata({
        versionHash: nft.details.VersionHash,
        metadataSubtree: "public/asset_metadata/nft",
        produceLinkUrls: true
      })) || {}
    ),
    ...(nft.metadata || {})
  };

  nft.config = await this.TenantConfiguration({contractAddress});

  return FormatNFTMetadata(nft);
};

/**
 * &lt;b>&lt;i>Requires login&lt;/i>&lt;/b>
 *
 * Transfer the specified NFT owned by the current user to the specified address
 *
 * @methodGroup NFT
 * @namedParams
 * @param {string} contractAddress - The contract address of the NFT
 * @param {string} tokenId - The token ID of the NFT
 * @param {string} targetAddress - The address to which to transfer the NFT
 */
exports.TransferNFT = async function({contractAddress, tokenId, targetAddress}) {
  if(!targetAddress || !Utils.ValidAddress(targetAddress)) {
    throw Error("Eluvio Wallet Client: Invalid or missing target address in UserTransferNFT");
  }

  return await this.client.authClient.MakeAuthServiceRequest({
    path: UrlJoin("as", "wlt", "mkt", "xfer"),
    method: "POST",
    body: {
      contract: Utils.FormatAddress(contractAddress),
      token: tokenId,
      to_addr: Utils.FormatAddress(targetAddress)
    },
    headers: {
      Authorization: `Bearer ${this.AuthToken()}`
    }
  });
};


/** LISTINGS */

/**
 * Retrieve the status of the specified listing
 *
 * @methodGroup Listings
 * @namedParams
 * @param {string=} listingId - The ID of the listing
 *
 * @returns {Promise&lt;Object>} - The status of the listing
 */
exports.ListingStatus = async function({listingId}) {
  try {
    return await Utils.ResponseToJson(
      await this.client.authClient.MakeAuthServiceRequest({
        path: UrlJoin("as", "mkt", "status", listingId),
        method: "GET"
      })
    );
  } catch(error) {
    if(error.status === 404) { return; }

    throw error;
  }
};

/**
 * Retrieve a specific listing
 *
 * NOTE: When a listing is sold or deleted, it will no longer be queryable with this API. Use &lt;a href="#.ListingStatus">ListingStatus&lt;/a> instead.
 *
 * @methodGroup Listings
 * @namedParams
 * @param {string=} listingId - The ID of the listing
 *
 * @returns {Promise&lt;Object>} - The listing
 */
exports.Listing = async function({listingId}) {
  return FormatNFT(
    await Utils.ResponseToJson(
      await this.client.authClient.MakeAuthServiceRequest({
        path: UrlJoin("as", "mkt", "l", listingId),
        method: "GET",
      })
    )
  );
};


/**
 * Retrieve listings matching the specified parameters.
 *
 * @methodGroup Listings
 * @namedParams
 * @param {integer=} start=0 - PAGINATION: Index from which the results should start
 * @param {integer=} limit=50 - PAGINATION: Maximum number of results to return
 * @param {string=} sortBy="created" - Sort order. Options: `created`, `info/token_id`, `info/ordinal`, `price`, `nft/display_name`
 * @param {boolean=} sortDesc=false - Sort results descending instead of ascending
 * @param {string=} filter - Filter results by item name.
 *  &lt;br />&lt;br />
 *  NOTE: This string must be an &lt;b>exact match&lt;/b> on the item name.
 * You can retrieve all available item names from the &lt;a href="#.ListingNames">ListingNames method&lt;/a>.
 *  @param {string=} editionFilter - Filter results by item edition.
 *  &lt;br />&lt;br />
 *  NOTE: This string must be an &lt;b>exact match&lt;/b> on the edition name.
 * You can retrieve all available item edition names from the &lt;a href="#.ListingEditionNames">ListingEditionNames method&lt;/a>.
 *  @param {Array&lt;Object>} attributeFilters - Filter results by item attributes. Each entry should include name and value (e.g. `[{name: "attribute-name", value: "attribute-value"}]`)
 *  &lt;br />&lt;br />
 *  NOTE: These filters must be an &lt;b>exact match&lt;/b> on the attribute name and value.
 * You can retrieve all available item attributes from the &lt;a href="#.ListingAttributes">ListingAttributes method&lt;/a>.
 * @param {string=} sellerAddress - Filter by a specific seller
 * @param {string=} contractAddress - Filter results by the address of the NFT contract
 * @param {string=} tokenId - Filter by token ID (if filtering by contract address)
 * @param {string=} currency - Filter results by purchase currency. Available options: `usdc`
 * @param {Object=} marketplaceParams - Filter results by marketplace
 * @param {integer=} collectionIndex - If filtering by marketplace, filter by collection. The index refers to the index in the array `marketplace.collections`
 * @param {integer=} lastNDays - Filter by results listed in the past N days
 *
 * @returns {Promise&lt;Object>} - Results of the query and pagination info
 */
exports.Listings = async function() {
  return this.FilteredQuery({mode: "listings", ...(arguments[0] || {})});
};

/**
 * Retrieve stats for listings matching the specified parameters.
 *
 * @methodGroup Listings
 * @namedParams
 * @param {integer=} start=0 - PAGINATION: Index from which the results should start
 * @param {integer=} limit=50 - PAGINATION: Maximum number of results to return
 * @param {string=} sortBy="created" - Sort order. Options: `created`, `info/token_id`, `info/ordinal`, `price`, `nft/display_name`
 * @param {boolean=} sortDesc=false - Sort results descending instead of ascending
 * @param {string=} filter - Filter results by item name.
 *  &lt;br />&lt;br />
 *  NOTE: This string must be an &lt;b>exact match&lt;/b> on the item name.
 * You can retrieve all available item names from the &lt;a href="#.ListingNames">ListingNames method&lt;/a>.
 *  @param {string=} editionFilter - Filter results by item edition.
 *  &lt;br />&lt;br />
 *  NOTE: This string must be an &lt;b>exact match&lt;/b> on the edition name.
 * You can retrieve all available item edition names from the &lt;a href="#.ListingEditionNames">ListingEditionNames method&lt;/a>.
 *  @param {Array&lt;Object>} attributeFilters - Filter results by item attributes. Each entry should include name and value (e.g. `[{name: "attribute-name", value: "attribute-value"}]`)
 *  &lt;br />&lt;br />
 *  NOTE: These filters must be an &lt;b>exact match&lt;/b> on the attribute name and value.
 * You can retrieve all available item attributes from the &lt;a href="#.ListingAttributes">ListingAttributes method&lt;/a>.
 * @param {string=} sellerAddress - Filter by a specific seller
 * @param {string=} contractAddress - Filter results by the address of the NFT contract
 * @param {string=} tokenId - Filter by token ID (if filtering by contract address)
 * @param {string=} currency - Filter results by purchase currency. Available options: `usdc`
 * @param {Object=} marketplaceParams - Filter results by marketplace
 * @param {integer=} collectionIndex - If filtering by marketplace, filter by collection. The index refers to the index in the array `marketplace.collections`
 * @param {integer=} lastNDays - Filter by results listed in the past N days
 *
 * @returns {Promise&lt;Object>} - Statistics about listings. All prices in USD.
 */
exports.ListingStats = async function() {
  return this.FilteredQuery({mode: "listing-stats", ...(arguments[0] || {})});
};

/**
 * Retrieve sales matching the specified parameters.
 *
 * @methodGroup Listings
 * @namedParams
 * @param {integer=} start=0 - PAGINATION: Index from which the results should start
 * @param {integer=} limit=50 - PAGINATION: Maximum number of results to return
 * @param {string=} sortBy="created" - Sort order. Options: `created`, `price`, `name`
 * @param {boolean=} sortDesc=false - Sort results descending instead of ascending
 * @param {string=} filter - Filter results by item name.
 *  &lt;br />&lt;br />
 *  NOTE: This string must be an &lt;b>exact match&lt;/b> on the item name.
 * You can retrieve all available item names from the &lt;a href="#.ListingNames">ListingNames method&lt;/a>.
 *  @param {string=} editionFilter - Filter results by item edition.
 *  &lt;br />&lt;br />
 *  NOTE: This string must be an &lt;b>exact match&lt;/b> on the edition name.
 * You can retrieve all available item edition names from the &lt;a href="#.ListingEditionNames">ListingEditionNames method&lt;/a>.
 *  @param {Array&lt;Object>} attributeFilters - Filter results by item attributes. Each entry should include name and value (e.g. `[{name: "attribute-name", value: "attribute-value"}]`)
 *  &lt;br />&lt;br />
 *  NOTE: These filters must be an &lt;b>exact match&lt;/b> on the attribute name and value.
 * You can retrieve all available item attributes from the &lt;a href="#.ListingAttributes">ListingAttributes method&lt;/a>.
 * @param {string=} sellerAddress - Filter by a specific seller
 * @param {string=} contractAddress - Filter results by the address of the NFT contract
 * @param {string=} tokenId - Filter by token ID (if filtering by contract address)
 * @param {string=} currency - Filter results by purchase currency. Available options: `usdc`
 * @param {Object=} marketplaceParams - Filter results by marketplace
 * @param {integer=} collectionIndex - If filtering by marketplace, filter by collection. The index refers to the index in the array `marketplace.collections`
 * @param {integer=} lastNDays - Filter by results listed in the past N days
 *
 * @returns {Promise&lt;Object>} - Results of the query and pagination info
 */
exports.Sales = async function() {
  return this.FilteredQuery({mode: "sales", ...(arguments[0] || {})});
};

/**
 * Retrieve stats for listings matching the specified parameters.
 *
 * @methodGroup Listings
 * @namedParams
 * @param {integer=} start=0 - PAGINATION: Index from which the results should start
 * @param {integer=} limit=50 - PAGINATION: Maximum number of results to return
 * @param {string=} sortBy="created" -
 * @param {boolean=} sortDesc=false - Sort results descending instead of ascending
 * @param {string=} filter - Filter results by item name.
 *  &lt;br />&lt;br />
 *  NOTE: This string must be an &lt;b>exact match&lt;/b> on the item name.
 * You can retrieve all available item names from the &lt;a href="#.ListingNames">ListingNames method&lt;/a>.
 *  @param {string=} editionFilter - Filter results by item edition.
 *  &lt;br />&lt;br />
 *  NOTE: This string must be an &lt;b>exact match&lt;/b> on the edition name.
 * You can retrieve all available item edition names from the &lt;a href="#.ListingEditionNames">ListingEditionNames method&lt;/a>.
 *  @param {Array&lt;Object>} attributeFilters - Filter results by item attributes. Each entry should include name and value (e.g. `[{name: "attribute-name", value: "attribute-value"}]`)
 *  &lt;br />&lt;br />
 *  NOTE: These filters must be an &lt;b>exact match&lt;/b> on the attribute name and value.
 * You can retrieve all available item attributes from the &lt;a href="#.ListingAttributes">ListingAttributes method&lt;/a>.
 * @param {string=} sellerAddress - Filter by a specific seller
 * @param {string=} contractAddress - Filter results by the address of the NFT contract
 * @param {string=} tokenId - Filter by token ID (if filtering by contract address)
 * @param {string=} currency - Filter results by purchase currency. Available options: `usdc`
 * @param {Object=} marketplaceParams - Filter results by marketplace
 * @param {integer=} collectionIndex - If filtering by marketplace, filter by collection. The index refers to the index in the array `marketplace.collections`
 * @param {integer=} lastNDays - Filter by results listed in the past N days
 *
 * @returns {Promise&lt;Object>} - Statistics about sales. All prices in USD.
 */
exports.SalesStats = async function() {
  return this.FilteredQuery({mode: "sales-stats", ...(arguments[0] || {})});
};


/**
 * &lt;b>&lt;i>Requires login&lt;/i>&lt;/b>
 *
 * Create or update a listing for the specified item
 *
 * @methodGroup Listings
 * @namedParams
 * @param {string} contractAddress - The NFT contract address of the item
 * @param {string} tokenId - The token ID of the item
 * @param {number} price - The price of the listing, in USD
 * @param {string=} listingId - (When editing a listing) The ID of the existing listing
 *
 * @returns {Promise&lt;string>} - The listing ID of the created listing
 */
exports.CreateListing = async function({contractAddress, tokenId, price, listingId}) {
  contractAddress = Utils.FormatAddress(contractAddress);

  if(listingId) {
    // Update
    return await Utils.ResponseToFormat(
      "text",
      await this.client.authClient.MakeAuthServiceRequest({
        path: UrlJoin("as", "wlt", "mkt"),
        method: "PUT",
        body: {
          id: listingId,
          price: parseFloat(price)
        },
        headers: {
          Authorization: `Bearer ${this.AuthToken()}`
        }
      })
    );
  } else {
    // Create
    return await Utils.ResponseToJson(
      await this.client.authClient.MakeAuthServiceRequest({
        path: UrlJoin("as", "wlt", "mkt"),
        method: "POST",
        body: {
          contract: contractAddress,
          token: tokenId,
          price: parseFloat(price)
        },
        headers: {
          Authorization: `Bearer ${this.AuthToken()}`
        }
      })
    );
  }
};

/**
 * &lt;b>&lt;i>Requires login&lt;/i>&lt;/b>
 *
 * Remove the specified listing
 *
 * @methodGroup Listings
 * @namedParams
 * @param {string} listingId - The ID of the listing to remove
 */
exports.RemoveListing = async function({listingId}) {
  await this.client.authClient.MakeAuthServiceRequest({
    path: UrlJoin("as", "wlt", "mkt", listingId),
    method: "DELETE",
    headers: {
      Authorization: `Bearer ${this.AuthToken()}`
    }
  });
};

/**
 * Retrieve all valid names for filtering listings. Full item names are required for filtering listing results by name.
 *
 * Specify marketplace information to filter the results to only items offered in that marketplace.
 *
 * @methodGroup Listings
 * @namedParams
 * @param {Object} marketplaceParams - Parameters of a marketplace to filter results by
 *
 * @returns {Promise&lt;Array&lt;String>>} - A list of item names
 */
exports.ListingNames = async function({marketplaceParams}) {
  let tenantId;
  if(marketplaceParams) {
    tenantId = (await this.MarketplaceInfo({marketplaceParams})).tenantId;
  }

  return await Utils.ResponseToJson(
    await this.client.authClient.MakeAuthServiceRequest({
      path: UrlJoin("as", "mkt", "names"),
      method: "GET",
      queryParams: tenantId ? { filter: `tenant:eq:${tenantId}` } : {}
    })
  );
};


/**
 * Retrieve all valid edition names of the specified item. Full item edition names are required for filtering listing results by edition.
 *
 * @methodGroup Listings
 * @namedParams
 * @param {string} displayName - Display name of the item from which to request edition names
 *
 * @returns {Promise&lt;Array&lt;String>>} - A list of item editions
 */
exports.ListingEditionNames = async function({displayName}) {
  return await Utils.ResponseToJson(
    await this.client.authClient.MakeAuthServiceRequest({
      path: UrlJoin("as", "mkt", "editions"),
      queryParams: {
        filter: `nft/display_name:eq:${displayName}`
      },
      method: "GET"
    })
  );
};

/**
 * Retrieve names of all valid attributes for listed tiems. Full attribute names and values are required for filtering listing results by attributes.
 *
 * Specify marketplace information to filter the results to only items offered in that marketplace.
 *
 * @methodGroup Listings
 * @namedParams
 * @param {Object=} marketplaceParams - Parameters of a marketplace to filter results by
 * @param {string=} displayName - Display name of the item from which to request attributes
 *
 * @returns {Promise&lt;Array&lt;String>>} - A list of valid attributes
 */
exports.ListingAttributes = async function({marketplaceParams, displayName}={}) {
  let filters = [];

  if(marketplaceParams) {
    filters.push(`tenant:eq:${(await this.MarketplaceInfo({marketplaceParams})).tenantId}`);
  }

  if(displayName) {
    filters.push(`nft/display_name:eq:${displayName}`);
  }

  const attributes = await Utils.ResponseToJson(
    await this.client.authClient.MakeAuthServiceRequest({
      path: UrlJoin("as", "mkt", "attributes"),
      method: "GET",
      queryParams: {
        filter: filters
      }
    })
  );

  return attributes
    .map(({trait_type, values}) => ({ name: trait_type, values }))
    .filter(({name}) =>
      !["Content Fabric Hash", "Total Minted Supply", "Creator"].includes(name)
    );
};

/* MINTING STATUS */

/**
 * Return status of the specified listing purchase
 *
 * @methodGroup Status
 * @namedParams
 * @param {string} listingId - The ID of the listing
 * @param {string} confirmationId - The confirmation ID of the purchase
 *
 * @returns {Promise&lt;Object>} - The status of the purchase
 */
exports.ListingPurchaseStatus = async function({listingId, confirmationId}) {
  try {
    const listingStatus = await this.ListingStatus({listingId});

    if(!listingStatus) {
      throw Error("Unable to find info for listing " + listingId);
    }

    const statuses = await this.MintingStatus({tenantId: listingStatus.tenant});

    return statuses
      .find(status =>
        status.op === "nft-transfer" &amp;&amp;
        status.extra &amp;&amp; status.extra[0] === confirmationId
      ) || { status: "none" };
  } catch(error) {
    this.Log(error, true);
    return { status: "unknown" };
  }
};

/**
 * Return status of the specified marketplace purchase
 *
 * @methodGroup Status
 * @namedParams
 * @param {Object} marketplaceParams - Parameters of the marketplace
 * @param {string} confirmationId - The confirmation ID of the purchase
 *
 * @returns {Promise&lt;Object>} - The minting status of the purchaseed item(s)
 */
exports.PurchaseStatus = async function({marketplaceParams, confirmationId}) {
  try {
    const marketplaceInfo = await this.MarketplaceInfo({marketplaceParams});
    const statuses = await this.MintingStatus({tenantId: marketplaceInfo.tenant_id});

    return statuses.find(status => status.op === "nft-buy" &amp;&amp; status.confirmationId === confirmationId) || { status: "none" };
  } catch(error) {
    this.Log(error, true);
    return { status: "unknown" };
  }
};

/**
 * Return status of the specified item claim
 *
 * @methodGroup Status
 * @namedParams
 * @param {Object} marketplaceParams - Parameters of the marketplace
 * @param {string} sku - The SKU of the item claimed
 *
 * @returns {Promise&lt;Object>} - The minting status of the claim
 */
exports.ClaimStatus = async function({marketplaceParams, sku}) {
  try {
    const marketplaceInfo = await this.MarketplaceInfo({marketplaceParams});
    const statuses = await this.MintingStatus({tenantId: marketplaceInfo.tenantId});

    return statuses.find(status => status.op === "nft-claim" &amp;&amp; status.marketplaceId === marketplaceInfo.marketplaceId &amp;&amp; status.confirmationId === sku) || { status: "none" };
  } catch(error) {
    this.Log(error, true);
    return { status: "unknown" };
  }
};

/**
 * Return status of the specified pack opening
 *
 * @methodGroup Status
 * @namedParams
 * @param {string} contractAddress - The NFT contract address of the opened pack
 * @param {string} tokenId - The token ID of the opened pack
 *
 * @returns {Promise&lt;Object>} - The status of the pack opening
 */
exports.PackOpenStatus = async function({contractAddress, tokenId}) {
  try {
    const tenantConfig = await this.TenantConfiguration({contractAddress});

    const statuses = await this.MintingStatus({tenantId: tenantConfig.tenant});

    return statuses.find(status => status.op === "nft-open" &amp;&amp; Utils.EqualAddress(contractAddress, status.address) &amp;&amp; status.tokenId === tokenId) || { status: "none" };
  } catch(error) {
    this.Log(error, true);
    return { status: "unknown" };
  }
};

/**
 * Return status of the specified collection redemption
 *
 * @methodGroup Status
 * @namedParams
 * @param {Object} marketplaceParams - Parameters of the marketplace
 * @param {string} confirmationId - The confirmation ID of the redemption
 *
 * @returns {Promise&lt;Object>} - The status of the collection redemption
 */
exports.CollectionRedemptionStatus = async function({marketplaceParams, confirmationId}) {
  try {
    const statuses = await this.MintingStatus({marketplaceParams});

    return statuses.find(status => status.op === "nft-redeem" &amp;&amp; status.confirmationId === confirmationId) || { status: "none" };
  } catch(error) {
    this.Log(error, true);
    return { status: "unknown" };
  }
};

/* EVENTS */


exports.LoadDrop = async function({tenantSlug, eventSlug, dropId}) {
  if(!this.drops){
    this.drops = {};
  }

  if(!this.drops[tenantSlug]) {
    this.drops[tenantSlug] = {};
  }

  if(!this.drops[tenantSlug][eventSlug]) {
    this.drops[tenantSlug][eventSlug] = {};
  }

  if(!this.drops[tenantSlug][eventSlug][dropId]) {
    const mainSiteHash = await this.client.LatestVersionHash({objectId: this.mainSiteId});
    const event = (await this.client.ContentObjectMetadata({
      versionHash: mainSiteHash,
      metadataSubtree: UrlJoin("public", "asset_metadata", "tenants", tenantSlug, "sites", eventSlug, "info"),
      resolveLinks: true,
      linkDepthLimit: 2,
      resolveIncludeSource: true,
      produceLinkUrls: true,
      select: [".", "drops"],
      noAuth: true
    })) || [];

    const eventId = Utils.DecodeVersionHash(event["."].source).objectId;

    event.drops.forEach(drop => {
      drop = {
        ...drop,
        eventId
      };

      this.drops[tenantSlug][eventSlug][drop.uuid] = drop;
      this.drops[drop.uuid] = drop;
    });
  }

  return this.drops[dropId];
};

exports.SubmitDropVote = async function({marketplaceParams, eventId, dropId, sku}) {
  const marketplaceInfo = await this.MarketplaceInfo({marketplaceParams});
  await this.client.authClient.MakeAuthServiceRequest({
    path: UrlJoin("as", "wlt", "act", marketplaceInfo.tenant_id),
    method: "POST",
    body: {
      op: "vote-drop",
      evt: eventId,
      id: dropId,
      itm: sku
    },
    headers: {
      Authorization: `Bearer ${this.AuthToken()}`
    }
  });
};

exports.DropStatus = async function({marketplace, eventId, dropId}) {
  try {
    const response = await Utils.ResponseToJson(
      this.client.authClient.MakeAuthServiceRequest({
        path: UrlJoin("as", "wlt", "act", marketplace.tenant_id, eventId, dropId),
        method: "GET",
        headers: {
          Authorization: `Bearer ${this.AuthToken()}`
        }
      })
    );

    return response.sort((a, b) => a.ts > b.ts ? 1 : -1)[0] || { status: "none" };
  } catch(error) {
    this.Log(error, true);
    return "";
  }
};
</code></pre>
</div>

    



        <footer class="footer">
          Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.10</a>
        </footer>
      </div>
    </div>
  </div>

  <script>
    // Format and add line numbers to code
    prettyPrint();
  </script>

  <script type="text/javascript" src="scripts/utils.js"></script>

  </body>
</html>
