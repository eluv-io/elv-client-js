

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="shortcut icon" href="images/favicon.png" >

  <title>
    client/LiveStream.js - Documentation
  </title>

  <script src="scripts/prettify/prettify.js"></script>
  <script src="scripts/prettify/lang-css.js"></script>

  <link type="text/css" rel="stylesheet" href="styles/elv-jsdoc.css">
  <link type="text/css" rel="stylesheet" href="styles/elv-prettify-jsdoc.css">
</head>

<body>
  <div class="layout-container">
    <nav class="nav-container">
      <div class="header">
        <a href="index.html">
          <img class="logo" src="images/logo-dark.png" />
        </a>
        <div class="title">
          Eluvio Javascript Client
        </div>
      </div>
      <div class="nav-content">
        <h3>Classes</h3><ul><li id="ElvClient-nav">
          <div data-name="ElvClient" class="class-link-container"><a class="class-link">ElvClient</a></div><ul class='methods'><h4 class="methodGroupHeader">Constructor</h4><li data-type="method" id="ElvClient-ElvClient-nav"><a href="ElvClient.html" class="method-link">ElvClient</a></li><li data-type="method" id="ElvClient-Configuration-nav"><a href="ElvClient.html#.Configuration" class="method-link">Configuration</a></li><li data-type="method" id="ElvClient-FromConfigurationUrl-nav"><a href="ElvClient.html#.FromConfigurationUrl" class="method-link">FromConfigurationUrl</a></li><li data-type="method" id="ElvClient-FromNetworkName-nav"><a href="ElvClient.html#.FromNetworkName" class="method-link">FromNetworkName</a></li><h4 class="methodGroupHeader">Access Requests</h4><li data-type="method" id="ElvClient-ClearCache-nav"><a href="ElvClient.html#ClearCache" class="method-link">ClearCache</a></li><h4 class="methodGroupHeader">Authorization</h4><li data-type="method" id="ElvClient-CreateFabricToken-nav"><a href="ElvClient.html#CreateFabricToken" class="method-link">CreateFabricToken</a></li><li data-type="method" id="ElvClient-CreateSignedMessageJSON-nav"><a href="ElvClient.html#CreateSignedMessageJSON" class="method-link">CreateSignedMessageJSON</a></li><li data-type="method" id="ElvClient-CreateSignedToken-nav"><a href="ElvClient.html#CreateSignedToken" class="method-link">CreateSignedToken</a></li><li data-type="method" id="ElvClient-CreateStaticToken-nav"><a href="ElvClient.html#CreateStaticToken" class="method-link">CreateStaticToken</a></li><li data-type="method" id="ElvClient-DecodeSignedMessageJSON-nav"><a href="ElvClient.html#DecodeSignedMessageJSON" class="method-link">DecodeSignedMessageJSON</a></li><li data-type="method" id="ElvClient-SetOauthToken-nav"><a href="ElvClient.html#SetOauthToken" class="method-link">SetOauthToken</a></li><li data-type="method" id="ElvClient-SetPolicyAuthorization-nav"><a href="ElvClient.html#SetPolicyAuthorization" class="method-link">SetPolicyAuthorization</a></li><li data-type="method" id="ElvClient-SetSignerFromOauthToken-nav"><a href="ElvClient.html#SetSignerFromOauthToken" class="method-link">SetSignerFromOauthToken</a></li><li data-type="method" id="ElvClient-SetStaticToken-nav"><a href="ElvClient.html#SetStaticToken" class="method-link">SetStaticToken</a></li><h4 class="methodGroupHeader">Miscellaneous</h4><li data-type="method" id="ElvClient-ToggleLogging-nav"><a href="ElvClient.html#ToggleLogging" class="method-link">ToggleLogging</a></li><li data-type="method" id="ElvClient-Networks-nav"><a href="ElvClient.html#.Networks" class="method-link">Networks</a></li><h4 class="methodGroupHeader">Nodes</h4><li data-type="method" id="ElvClient-NetworkInfo-nav"><a href="ElvClient.html#NetworkInfo" class="method-link">NetworkInfo</a></li><li data-type="method" id="ElvClient-NodeId-nav"><a href="ElvClient.html#NodeId" class="method-link">NodeId</a></li><li data-type="method" id="ElvClient-Nodes-nav"><a href="ElvClient.html#Nodes" class="method-link">Nodes</a></li><li data-type="method" id="ElvClient-ResetRegion-nav"><a href="ElvClient.html#ResetRegion" class="method-link">ResetRegion</a></li><li data-type="method" id="ElvClient-SetNodes-nav"><a href="ElvClient.html#SetNodes" class="method-link">SetNodes</a></li><li data-type="method" id="ElvClient-SpaceNodes-nav"><a href="ElvClient.html#SpaceNodes" class="method-link">SpaceNodes</a></li><li data-type="method" id="ElvClient-UseRegion-nav"><a href="ElvClient.html#UseRegion" class="method-link">UseRegion</a></li><h4 class="methodGroupHeader">Signers</h4><li data-type="method" id="ElvClient-ClearSigner-nav"><a href="ElvClient.html#ClearSigner" class="method-link">ClearSigner</a></li><li data-type="method" id="ElvClient-CreateAccount-nav"><a href="ElvClient.html#CreateAccount" class="method-link">CreateAccount</a></li><li data-type="method" id="ElvClient-CurrentAccountAddress-nav"><a href="ElvClient.html#CurrentAccountAddress" class="method-link">CurrentAccountAddress</a></li><li data-type="method" id="ElvClient-GenerateWallet-nav"><a href="ElvClient.html#GenerateWallet" class="method-link">GenerateWallet</a></li><li data-type="method" id="ElvClient-SetRemoteSigner-nav"><a href="ElvClient.html#SetRemoteSigner" class="method-link">SetRemoteSigner</a></li><li data-type="method" id="ElvClient-SetSigner-nav"><a href="ElvClient.html#SetSigner" class="method-link">SetSigner</a></li><li data-type="method" id="ElvClient-SetSignerFromWeb3Provider-nav"><a href="ElvClient.html#SetSignerFromWeb3Provider" class="method-link">SetSignerFromWeb3Provider</a></li><h4 class="methodGroupHeader">Methods</h4><li data-type="method" id="ElvClient-ClearStaticToken-nav"><a href="ElvClient.html#ClearStaticToken" class="method-link">ClearStaticToken</a></li><li data-type="method" id="ElvClient-DecryptECIES-nav"><a href="ElvClient.html#DecryptECIES" class="method-link">DecryptECIES</a></li><li data-type="method" id="ElvClient-EncryptECIES-nav"><a href="ElvClient.html#EncryptECIES" class="method-link">EncryptECIES</a></li><li data-type="method" id="ElvClient-Request-nav"><a href="ElvClient.html#Request" class="method-link">Request</a></li><li data-type="method" id="ElvClient-Sign-nav"><a href="ElvClient.html#Sign" class="method-link">Sign</a></li></ul></li><li id="ElvWallet-nav">
          <div data-name="ElvWallet" class="class-link-container"><a class="class-link">ElvWallet</a></div><ul class='methods'><h4 class="methodGroupHeader">Constructor</h4><li data-type="method" id="ElvWallet-ElvWallet-nav"><a href="ElvWallet.html" class="method-link">ElvWallet</a></li><h4 class="methodGroupHeader">Methods</h4><li data-type="method" id="ElvWallet-AddAccount-nav"><a href="ElvWallet.html#AddAccount" class="method-link">AddAccount</a></li><li data-type="method" id="ElvWallet-AddAccountFromEncryptedPK-nav"><a href="ElvWallet.html#AddAccountFromEncryptedPK" class="method-link">AddAccountFromEncryptedPK</a></li><li data-type="method" id="ElvWallet-AddAccountFromMnemonic-nav"><a href="ElvWallet.html#AddAccountFromMnemonic" class="method-link">AddAccountFromMnemonic</a></li><li data-type="method" id="ElvWallet-GenerateEncryptedPrivateKey-nav"><a href="ElvWallet.html#GenerateEncryptedPrivateKey" class="method-link">GenerateEncryptedPrivateKey</a></li><li data-type="method" id="ElvWallet-GenerateMnemonic-nav"><a href="ElvWallet.html#GenerateMnemonic" class="method-link">GenerateMnemonic</a></li><li data-type="method" id="ElvWallet-GetAccount-nav"><a href="ElvWallet.html#GetAccount" class="method-link">GetAccount</a></li><li data-type="method" id="ElvWallet-GetAccountBalance-nav"><a href="ElvWallet.html#GetAccountBalance" class="method-link">GetAccountBalance</a></li><li data-type="method" id="ElvWallet-RemoveAccount-nav"><a href="ElvWallet.html#RemoveAccount" class="method-link">RemoveAccount</a></li></ul></li><li id="FrameClient-nav">
          <div data-name="FrameClient" class="class-link-container"><a class="class-link">FrameClient</a></div><ul class='methods'><h4 class="methodGroupHeader">Constructor</h4><li data-type="method" id="FrameClient-FrameClient-nav"><a href="FrameClient.html" class="method-link">FrameClient</a></li><h4 class="methodGroupHeader">Methods</h4><li data-type="method" id="FrameClient-AllowedMethods-nav"><a href="FrameClient.html#AllowedMethods" class="method-link">AllowedMethods</a></li><li data-type="method" id="FrameClient-PassRequest-nav"><a href="FrameClient.html#PassRequest" class="method-link">PassRequest</a></li></ul></li><li id="PermissionsClient-nav">
          <div data-name="PermissionsClient" class="class-link-container"><a class="class-link">PermissionsClient</a></div><ul class='methods'><h4 class="methodGroupHeader">Constructor</h4><li data-type="method" id="PermissionsClient-PermissionsClient-nav"><a href="PermissionsClient.html" class="method-link">PermissionsClient</a></li><h4 class="methodGroupHeader">OfflineDraft</h4><li data-type="method" id="PermissionsClient-CloseOfflineDraft-nav"><a href="PermissionsClient.html#CloseOfflineDraft" class="method-link">CloseOfflineDraft</a></li><li data-type="method" id="PermissionsClient-OpenOfflineDraft-nav"><a href="PermissionsClient.html#OpenOfflineDraft" class="method-link">OpenOfflineDraft</a></li><h4 class="methodGroupHeader">Permissions</h4><li data-type="method" id="PermissionsClient-ItemPermissions-nav"><a href="PermissionsClient.html#ItemPermissions" class="method-link">ItemPermissions</a></li><li data-type="method" id="PermissionsClient-RemovePermission-nav"><a href="PermissionsClient.html#RemovePermission" class="method-link">RemovePermission</a></li><li data-type="method" id="PermissionsClient-RemoveSubjectPermissions-nav"><a href="PermissionsClient.html#RemoveSubjectPermissions" class="method-link">RemoveSubjectPermissions</a></li><li data-type="method" id="PermissionsClient-SetPermission-nav"><a href="PermissionsClient.html#SetPermission" class="method-link">SetPermission</a></li><li data-type="method" id="PermissionsClient-SubjectPermissions-nav"><a href="PermissionsClient.html#SubjectPermissions" class="method-link">SubjectPermissions</a></li><h4 class="methodGroupHeader">Policies</h4><li data-type="method" id="PermissionsClient-CreateItemPolicy-nav"><a href="PermissionsClient.html#CreateItemPolicy" class="method-link">CreateItemPolicy</a></li><li data-type="method" id="PermissionsClient-ItemPolicy-nav"><a href="PermissionsClient.html#ItemPolicy" class="method-link">ItemPolicy</a></li><li data-type="method" id="PermissionsClient-PolicyItems-nav"><a href="PermissionsClient.html#PolicyItems" class="method-link">PolicyItems</a></li><li data-type="method" id="PermissionsClient-RemoveItemPolicy-nav"><a href="PermissionsClient.html#RemoveItemPolicy" class="method-link">RemoveItemPolicy</a></li><h4 class="methodGroupHeader">Profiles</h4><li data-type="method" id="PermissionsClient-ItemProfiles-nav"><a href="PermissionsClient.html#ItemProfiles" class="method-link">ItemProfiles</a></li><li data-type="method" id="PermissionsClient-RemoveProfile-nav"><a href="PermissionsClient.html#RemoveProfile" class="method-link">RemoveProfile</a></li><li data-type="method" id="PermissionsClient-SetProfile-nav"><a href="PermissionsClient.html#SetProfile" class="method-link">SetProfile</a></li></ul></li><li id="UserProfileClient-nav">
          <div data-name="UserProfileClient" class="class-link-container"><a class="class-link">UserProfileClient</a></div><ul class='methods'><h4 class="methodGroupHeader">Constructor</h4><li data-type="method" id="UserProfileClient-UserProfileClient-nav"><a href="UserProfileClient.html" class="method-link">UserProfileClient</a></li><h4 class="methodGroupHeader">Methods</h4><li data-type="method" id="UserProfileClient-AccessLevel-nav"><a href="UserProfileClient.html#AccessLevel" class="method-link">AccessLevel</a></li><li data-type="method" id="UserProfileClient-CollectedTags-nav"><a href="UserProfileClient.html#CollectedTags" class="method-link">CollectedTags</a></li><li data-type="method" id="UserProfileClient-DeleteUserMetadata-nav"><a href="UserProfileClient.html#DeleteUserMetadata" class="method-link">DeleteUserMetadata</a></li><li data-type="method" id="UserProfileClient-MergeUserMetadata-nav"><a href="UserProfileClient.html#MergeUserMetadata" class="method-link">MergeUserMetadata</a></li><li data-type="method" id="UserProfileClient-PublicUserMetadata-nav"><a href="UserProfileClient.html#PublicUserMetadata" class="method-link">PublicUserMetadata</a></li><li data-type="method" id="UserProfileClient-ReplaceUserMetadata-nav"><a href="UserProfileClient.html#ReplaceUserMetadata" class="method-link">ReplaceUserMetadata</a></li><li data-type="method" id="UserProfileClient-SetAccessLevel-nav"><a href="UserProfileClient.html#SetAccessLevel" class="method-link">SetAccessLevel</a></li><li data-type="method" id="UserProfileClient-SetTenantContractId-nav"><a href="UserProfileClient.html#SetTenantContractId" class="method-link">SetTenantContractId</a></li><li data-type="method" id="UserProfileClient-SetTenantId-nav"><a href="UserProfileClient.html#SetTenantId" class="method-link">SetTenantId</a></li><li data-type="method" id="UserProfileClient-SetUserProfileImage-nav"><a href="UserProfileClient.html#SetUserProfileImage" class="method-link">SetUserProfileImage</a></li><li data-type="method" id="UserProfileClient-TenantContractId-nav"><a href="UserProfileClient.html#TenantContractId" class="method-link">TenantContractId</a></li><li data-type="method" id="UserProfileClient-TenantId-nav"><a href="UserProfileClient.html#TenantId" class="method-link">TenantId</a></li><li data-type="method" id="UserProfileClient-UserMetadata-nav"><a href="UserProfileClient.html#UserMetadata" class="method-link">UserMetadata</a></li><li data-type="method" id="UserProfileClient-UserProfileImage-nav"><a href="UserProfileClient.html#UserProfileImage" class="method-link">UserProfileImage</a></li><li data-type="method" id="UserProfileClient-UserWalletAddress-nav"><a href="UserProfileClient.html#UserWalletAddress" class="method-link">UserWalletAddress</a></li><li data-type="method" id="UserProfileClient-UserWalletObjectInfo-nav"><a href="UserProfileClient.html#UserWalletObjectInfo" class="method-link">UserWalletObjectInfo</a></li><li data-type="method" id="UserProfileClient-WalletAddress-nav"><a href="UserProfileClient.html#WalletAddress" class="method-link">WalletAddress</a></li></ul></li></ul><h3>Modules</h3><ul><li id="ElvClient_ABRPublishing-nav">
          <div data-name="ElvClient/ABRPublishing" class="class-link-container"><a class="class-link">ElvClient/ABRPublishing</a></div><ul class='methods'><li data-type="method" id="ElvClient_ABRPublishing-ElvClient/ABRPublishing-nav"><a href="module-ElvClient_ABRPublishing.html" class="method-link">ElvClient/ABRPublishing</a></li><h4 class="methodGroupHeader">ABR Publishing</h4><li data-type="method" id="ElvClient_ABRPublishing-CreateABRMezzanine-nav"><a href="module-ElvClient_ABRPublishing.html#.CreateABRMezzanine" class="method-link">CreateABRMezzanine</a></li><li data-type="method" id="ElvClient_ABRPublishing-CreateProductionMaster-nav"><a href="module-ElvClient_ABRPublishing.html#.CreateProductionMaster" class="method-link">CreateProductionMaster</a></li><li data-type="method" id="ElvClient_ABRPublishing-FinalizeABRMezzanine-nav"><a href="module-ElvClient_ABRPublishing.html#.FinalizeABRMezzanine" class="method-link">FinalizeABRMezzanine</a></li><li data-type="method" id="ElvClient_ABRPublishing-LRODraftInfo-nav"><a href="module-ElvClient_ABRPublishing.html#.LRODraftInfo" class="method-link">LRODraftInfo</a></li><li data-type="method" id="ElvClient_ABRPublishing-LROStatus-nav"><a href="module-ElvClient_ABRPublishing.html#.LROStatus" class="method-link">LROStatus</a></li><li data-type="method" id="ElvClient_ABRPublishing-StartABRMezzanineJobs-nav"><a href="module-ElvClient_ABRPublishing.html#.StartABRMezzanineJobs" class="method-link">StartABRMezzanineJobs</a></li></ul></li><li id="ElvClient_AccessGroups-nav">
          <div data-name="ElvClient/AccessGroups" class="class-link-container"><a class="class-link">ElvClient/AccessGroups</a></div><ul class='methods'><li data-type="method" id="ElvClient_AccessGroups-ElvClient/AccessGroups-nav"><a href="module-ElvClient_AccessGroups.html" class="method-link">ElvClient/AccessGroups</a></li><h4 class="methodGroupHeader">Access Groups</h4><li data-type="method" id="ElvClient_AccessGroups-ListAccessGroups-nav"><a href="module-ElvClient_AccessGroups.html#.ListAccessGroups" class="method-link">ListAccessGroups</a></li><li data-type="method" id="ElvClient_AccessGroups-AccessGroupManagers-nav"><a href="module-ElvClient_AccessGroups.html#.exports.AccessGroupManagers" class="method-link">AccessGroupManagers</a></li><li data-type="method" id="ElvClient_AccessGroups-AccessGroupMembers-nav"><a href="module-ElvClient_AccessGroups.html#.exports.AccessGroupMembers" class="method-link">AccessGroupMembers</a></li><li data-type="method" id="ElvClient_AccessGroups-AccessGroupOwner-nav"><a href="module-ElvClient_AccessGroups.html#.exports.AccessGroupOwner" class="method-link">AccessGroupOwner</a></li><li data-type="method" id="ElvClient_AccessGroups-AddAccessGroupManager-nav"><a href="module-ElvClient_AccessGroups.html#.exports.AddAccessGroupManager" class="method-link">AddAccessGroupManager</a></li><li data-type="method" id="ElvClient_AccessGroups-AddAccessGroupMember-nav"><a href="module-ElvClient_AccessGroups.html#.exports.AddAccessGroupMember" class="method-link">AddAccessGroupMember</a></li><li data-type="method" id="ElvClient_AccessGroups-CreateAccessGroup-nav"><a href="module-ElvClient_AccessGroups.html#.exports.CreateAccessGroup" class="method-link">CreateAccessGroup</a></li><li data-type="method" id="ElvClient_AccessGroups-DeleteAccessGroup-nav"><a href="module-ElvClient_AccessGroups.html#.exports.DeleteAccessGroup" class="method-link">DeleteAccessGroup</a></li><li data-type="method" id="ElvClient_AccessGroups-RemoveAccessGroupManager-nav"><a href="module-ElvClient_AccessGroups.html#.exports.RemoveAccessGroupManager" class="method-link">RemoveAccessGroupManager</a></li><li data-type="method" id="ElvClient_AccessGroups-RemoveAccessGroupMember-nav"><a href="module-ElvClient_AccessGroups.html#.exports.RemoveAccessGroupMember" class="method-link">RemoveAccessGroupMember</a></li><h4 class="methodGroupHeader">Library Access Groups</h4><li data-type="method" id="ElvClient_AccessGroups-AddContentLibraryGroup-nav"><a href="module-ElvClient_AccessGroups.html#.exports.AddContentLibraryGroup" class="method-link">AddContentLibraryGroup</a></li><li data-type="method" id="ElvClient_AccessGroups-ContentLibraryGroupPermissions-nav"><a href="module-ElvClient_AccessGroups.html#.exports.ContentLibraryGroupPermissions" class="method-link">ContentLibraryGroupPermissions</a></li><li data-type="method" id="ElvClient_AccessGroups-RemoveContentLibraryGroup-nav"><a href="module-ElvClient_AccessGroups.html#.exports.RemoveContentLibraryGroup" class="method-link">RemoveContentLibraryGroup</a></li><h4 class="methodGroupHeader">Object Access Groups</h4><li data-type="method" id="ElvClient_AccessGroups-AddContentObjectGroupPermission-nav"><a href="module-ElvClient_AccessGroups.html#.exports.AddContentObjectGroupPermission" class="method-link">AddContentObjectGroupPermission</a></li><li data-type="method" id="ElvClient_AccessGroups-ContentObjectGroupPermissions-nav"><a href="module-ElvClient_AccessGroups.html#.exports.ContentObjectGroupPermissions" class="method-link">ContentObjectGroupPermissions</a></li><li data-type="method" id="ElvClient_AccessGroups-RemoveContentObjectGroupPermission-nav"><a href="module-ElvClient_AccessGroups.html#.exports.RemoveContentObjectGroupPermission" class="method-link">RemoveContentObjectGroupPermission</a></li><h4 class="methodGroupHeader">Methods</h4><li data-type="method" id="ElvClient_AccessGroups-LinkAccessGroupToOauth-nav"><a href="module-ElvClient_AccessGroups.html#.LinkAccessGroupToOauth" class="method-link">LinkAccessGroupToOauth</a></li><li data-type="method" id="ElvClient_AccessGroups-UnlinkAccessGroupFromOauth-nav"><a href="module-ElvClient_AccessGroups.html#.UnlinkAccessGroupFromOauth" class="method-link">UnlinkAccessGroupFromOauth</a></li></ul></li><li id="ElvClient_ContentAccess-nav">
          <div data-name="ElvClient/ContentAccess" class="class-link-container"><a class="class-link">ElvClient/ContentAccess</a></div><ul class='methods'><li data-type="method" id="ElvClient_ContentAccess-ElvClient/ContentAccess-nav"><a href="module-ElvClient_ContentAccess.html" class="method-link">ElvClient/ContentAccess</a></li><h4 class="methodGroupHeader">Access Requests</h4><li data-type="method" id="ElvClient_ContentAccess-AccessInfo-nav"><a href="module-ElvClient_ContentAccess.html#.AccessInfo" class="method-link">AccessInfo</a></li><li data-type="method" id="ElvClient_ContentAccess-AccessRequest-nav"><a href="module-ElvClient_ContentAccess.html#.AccessRequest" class="method-link">AccessRequest</a></li><li data-type="method" id="ElvClient_ContentAccess-AccessType-nav"><a href="module-ElvClient_ContentAccess.html#.AccessType" class="method-link">AccessType</a></li><li data-type="method" id="ElvClient_ContentAccess-ContentObjectAccessComplete-nav"><a href="module-ElvClient_ContentAccess.html#.ContentObjectAccessComplete" class="method-link">ContentObjectAccessComplete</a></li><li data-type="method" id="ElvClient_ContentAccess-FinalizeStateChannelAccess-nav"><a href="module-ElvClient_ContentAccess.html#.FinalizeStateChannelAccess" class="method-link">FinalizeStateChannelAccess</a></li><li data-type="method" id="ElvClient_ContentAccess-GenerateStateChannelToken-nav"><a href="module-ElvClient_ContentAccess.html#.GenerateStateChannelToken" class="method-link">GenerateStateChannelToken</a></li><li data-type="method" id="ElvClient_ContentAccess-SetAuthContext-nav"><a href="module-ElvClient_ContentAccess.html#.SetAuthContext" class="method-link">SetAuthContext</a></li><h4 class="methodGroupHeader">Collections</h4><li data-type="method" id="ElvClient_ContentAccess-Collection-nav"><a href="module-ElvClient_ContentAccess.html#.Collection" class="method-link">Collection</a></li><h4 class="methodGroupHeader">Content Libraries</h4><li data-type="method" id="ElvClient_ContentAccess-ContentLibraries-nav"><a href="module-ElvClient_ContentAccess.html#.ContentLibraries" class="method-link">ContentLibraries</a></li><li data-type="method" id="ElvClient_ContentAccess-ContentLibrary-nav"><a href="module-ElvClient_ContentAccess.html#.ContentLibrary" class="method-link">ContentLibrary</a></li><li data-type="method" id="ElvClient_ContentAccess-ContentLibraryOwner-nav"><a href="module-ElvClient_ContentAccess.html#.ContentLibraryOwner" class="method-link">ContentLibraryOwner</a></li><li data-type="method" id="ElvClient_ContentAccess-LibraryContentTypes-nav"><a href="module-ElvClient_ContentAccess.html#.LibraryContentTypes" class="method-link">LibraryContentTypes</a></li><h4 class="methodGroupHeader">Content Objects</h4><li data-type="method" id="ElvClient_ContentAccess-AssetMetadata-nav"><a href="module-ElvClient_ContentAccess.html#.AssetMetadata" class="method-link">AssetMetadata</a></li><li data-type="method" id="ElvClient_ContentAccess-AuditContentObject-nav"><a href="module-ElvClient_ContentAccess.html#.AuditContentObject" class="method-link">AuditContentObject</a></li><li data-type="method" id="ElvClient_ContentAccess-ContentObject-nav"><a href="module-ElvClient_ContentAccess.html#.ContentObject" class="method-link">ContentObject</a></li><li data-type="method" id="ElvClient_ContentAccess-ContentObjectLibraryId-nav"><a href="module-ElvClient_ContentAccess.html#.ContentObjectLibraryId" class="method-link">ContentObjectLibraryId</a></li><li data-type="method" id="ElvClient_ContentAccess-ContentObjectOwner-nav"><a href="module-ElvClient_ContentAccess.html#.ContentObjectOwner" class="method-link">ContentObjectOwner</a></li><li data-type="method" id="ElvClient_ContentAccess-ContentObjectTenantId-nav"><a href="module-ElvClient_ContentAccess.html#.ContentObjectTenantId" class="method-link">ContentObjectTenantId</a></li><li data-type="method" id="ElvClient_ContentAccess-ContentObjectVersions-nav"><a href="module-ElvClient_ContentAccess.html#.ContentObjectVersions" class="method-link">ContentObjectVersions</a></li><li data-type="method" id="ElvClient_ContentAccess-ContentObjects-nav"><a href="module-ElvClient_ContentAccess.html#.ContentObjects" class="method-link">ContentObjects</a></li><li data-type="method" id="ElvClient_ContentAccess-LatestVersionHash-nav"><a href="module-ElvClient_ContentAccess.html#.LatestVersionHash" class="method-link">LatestVersionHash</a></li><li data-type="method" id="ElvClient_ContentAccess-LatestVersionHashV2-nav"><a href="module-ElvClient_ContentAccess.html#.LatestVersionHashV2" class="method-link">LatestVersionHashV2</a></li><li data-type="method" id="ElvClient_ContentAccess-Permission-nav"><a href="module-ElvClient_ContentAccess.html#.Permission" class="method-link">Permission</a></li><li data-type="method" id="ElvClient_ContentAccess-Proofs-nav"><a href="module-ElvClient_ContentAccess.html#.Proofs" class="method-link">Proofs</a></li><li data-type="method" id="ElvClient_ContentAccess-QParts-nav"><a href="module-ElvClient_ContentAccess.html#.QParts" class="method-link">QParts</a></li><h4 class="methodGroupHeader">Content Space</h4><li data-type="method" id="ElvClient_ContentAccess-ContentSpaceId-nav"><a href="module-ElvClient_ContentAccess.html#.ContentSpaceId" class="method-link">ContentSpaceId</a></li><li data-type="method" id="ElvClient_ContentAccess-DefaultKMSAddress-nav"><a href="module-ElvClient_ContentAccess.html#.DefaultKMSAddress" class="method-link">DefaultKMSAddress</a></li><h4 class="methodGroupHeader">Content Types</h4><li data-type="method" id="ElvClient_ContentAccess-ContentType-nav"><a href="module-ElvClient_ContentAccess.html#.ContentType" class="method-link">ContentType</a></li><li data-type="method" id="ElvClient_ContentAccess-ContentTypeOwner-nav"><a href="module-ElvClient_ContentAccess.html#.ContentTypeOwner" class="method-link">ContentTypeOwner</a></li><li data-type="method" id="ElvClient_ContentAccess-ContentTypes-nav"><a href="module-ElvClient_ContentAccess.html#.ContentTypes" class="method-link">ContentTypes</a></li><h4 class="methodGroupHeader">Encryption</h4><li data-type="method" id="ElvClient_ContentAccess-Decrypt-nav"><a href="module-ElvClient_ContentAccess.html#.Decrypt" class="method-link">Decrypt</a></li><li data-type="method" id="ElvClient_ContentAccess-Encrypt-nav"><a href="module-ElvClient_ContentAccess.html#.Encrypt" class="method-link">Encrypt</a></li><li data-type="method" id="ElvClient_ContentAccess-EncryptionConk-nav"><a href="module-ElvClient_ContentAccess.html#.EncryptionConk" class="method-link">EncryptionConk</a></li><h4 class="methodGroupHeader">Links</h4><li data-type="method" id="ElvClient_ContentAccess-ContentObjectGraph-nav"><a href="module-ElvClient_ContentAccess.html#.ContentObjectGraph" class="method-link">ContentObjectGraph</a></li><li data-type="method" id="ElvClient_ContentAccess-LinkData-nav"><a href="module-ElvClient_ContentAccess.html#.LinkData" class="method-link">LinkData</a></li><li data-type="method" id="ElvClient_ContentAccess-LinkTarget-nav"><a href="module-ElvClient_ContentAccess.html#.LinkTarget" class="method-link">LinkTarget</a></li><li data-type="method" id="ElvClient_ContentAccess-LinkUrl-nav"><a href="module-ElvClient_ContentAccess.html#.LinkUrl" class="method-link">LinkUrl</a></li><h4 class="methodGroupHeader">Media</h4><li data-type="method" id="ElvClient_ContentAccess-AvailableDRMs-nav"><a href="module-ElvClient_ContentAccess.html#.AvailableDRMs" class="method-link">AvailableDRMs</a></li><li data-type="method" id="ElvClient_ContentAccess-AvailableOfferings-nav"><a href="module-ElvClient_ContentAccess.html#.AvailableOfferings" class="method-link">AvailableOfferings</a></li><li data-type="method" id="ElvClient_ContentAccess-BitmovinPlayoutOptions-nav"><a href="module-ElvClient_ContentAccess.html#.BitmovinPlayoutOptions" class="method-link">BitmovinPlayoutOptions</a></li><li data-type="method" id="ElvClient_ContentAccess-PlayoutOptions-nav"><a href="module-ElvClient_ContentAccess.html#.PlayoutOptions" class="method-link">PlayoutOptions</a></li><h4 class="methodGroupHeader">Metadata</h4><li data-type="method" id="ElvClient_ContentAccess-ContentObjectMetadata-nav"><a href="module-ElvClient_ContentAccess.html#.ContentObjectMetadata" class="method-link">ContentObjectMetadata</a></li><h4 class="methodGroupHeader">URL Generation</h4><li data-type="method" id="ElvClient_ContentAccess-CallBitcodeMethod-nav"><a href="module-ElvClient_ContentAccess.html#.CallBitcodeMethod" class="method-link">CallBitcodeMethod</a></li><li data-type="method" id="ElvClient_ContentAccess-ContentObjectImageUrl-nav"><a href="module-ElvClient_ContentAccess.html#.ContentObjectImageUrl" class="method-link">ContentObjectImageUrl</a></li><li data-type="method" id="ElvClient_ContentAccess-EmbedUrl-nav"><a href="module-ElvClient_ContentAccess.html#.EmbedUrl" class="method-link">EmbedUrl</a></li><li data-type="method" id="ElvClient_ContentAccess-FabricUrl-nav"><a href="module-ElvClient_ContentAccess.html#.FabricUrl" class="method-link">FabricUrl</a></li><li data-type="method" id="ElvClient_ContentAccess-FileUrl-nav"><a href="module-ElvClient_ContentAccess.html#.FileUrl" class="method-link">FileUrl</a></li><li data-type="method" id="ElvClient_ContentAccess-GlobalUrl-nav"><a href="module-ElvClient_ContentAccess.html#.GlobalUrl" class="method-link">GlobalUrl</a></li><li data-type="method" id="ElvClient_ContentAccess-PublicRep-nav"><a href="module-ElvClient_ContentAccess.html#.PublicRep" class="method-link">PublicRep</a></li><li data-type="method" id="ElvClient_ContentAccess-Rep-nav"><a href="module-ElvClient_ContentAccess.html#.Rep" class="method-link">Rep</a></li></ul></li><li id="ElvClient_ContentManagement-nav">
          <div data-name="ElvClient/ContentManagement" class="class-link-container"><a class="class-link">ElvClient/ContentManagement</a></div><ul class='methods'><li data-type="method" id="ElvClient_ContentManagement-ElvClient/ContentManagement-nav"><a href="module-ElvClient_ContentManagement.html" class="method-link">ElvClient/ContentManagement</a></li><h4 class="methodGroupHeader">Access Requests</h4><li data-type="method" id="ElvClient_ContentManagement-CreateNonOwnerCap-nav"><a href="module-ElvClient_ContentManagement.html#.CreateNonOwnerCap" class="method-link">CreateNonOwnerCap</a></li><li data-type="method" id="ElvClient_ContentManagement-SetAccessCharge-nav"><a href="module-ElvClient_ContentManagement.html#.SetAccessCharge" class="method-link">SetAccessCharge</a></li><h4 class="methodGroupHeader">Auth Policies</h4><li data-type="method" id="ElvClient_ContentManagement-InitializeAuthPolicy-nav"><a href="module-ElvClient_ContentManagement.html#.InitializeAuthPolicy" class="method-link">InitializeAuthPolicy</a></li><li data-type="method" id="ElvClient_ContentManagement-SetAuthPolicy-nav"><a href="module-ElvClient_ContentManagement.html#.SetAuthPolicy" class="method-link">SetAuthPolicy</a></li><h4 class="methodGroupHeader">Content Libraries</h4><li data-type="method" id="ElvClient_ContentManagement-AddLibraryContentType-nav"><a href="module-ElvClient_ContentManagement.html#.AddLibraryContentType" class="method-link">AddLibraryContentType</a></li><li data-type="method" id="ElvClient_ContentManagement-CreateContentLibrary-nav"><a href="module-ElvClient_ContentManagement.html#.CreateContentLibrary" class="method-link">CreateContentLibrary</a></li><li data-type="method" id="ElvClient_ContentManagement-DeleteContentLibrary-nav"><a href="module-ElvClient_ContentManagement.html#.DeleteContentLibrary" class="method-link">DeleteContentLibrary</a></li><li data-type="method" id="ElvClient_ContentManagement-RemoveLibraryContentType-nav"><a href="module-ElvClient_ContentManagement.html#.RemoveLibraryContentType" class="method-link">RemoveLibraryContentType</a></li><li data-type="method" id="ElvClient_ContentManagement-SetContentLibraryImage-nav"><a href="module-ElvClient_ContentManagement.html#.SetContentLibraryImage" class="method-link">SetContentLibraryImage</a></li><h4 class="methodGroupHeader">Content Objects</h4><li data-type="method" id="ElvClient_ContentManagement-CopyContentObject-nav"><a href="module-ElvClient_ContentManagement.html#.CopyContentObject" class="method-link">CopyContentObject</a></li><li data-type="method" id="ElvClient_ContentManagement-CreateAndFinalizeContentObject-nav"><a href="module-ElvClient_ContentManagement.html#.CreateAndFinalizeContentObject" class="method-link">CreateAndFinalizeContentObject</a></li><li data-type="method" id="ElvClient_ContentManagement-CreateContentObject-nav"><a href="module-ElvClient_ContentManagement.html#.CreateContentObject" class="method-link">CreateContentObject</a></li><li data-type="method" id="ElvClient_ContentManagement-DeleteContentObject-nav"><a href="module-ElvClient_ContentManagement.html#.DeleteContentObject" class="method-link">DeleteContentObject</a></li><li data-type="method" id="ElvClient_ContentManagement-DeleteContentVersion-nav"><a href="module-ElvClient_ContentManagement.html#.DeleteContentVersion" class="method-link">DeleteContentVersion</a></li><li data-type="method" id="ElvClient_ContentManagement-DeleteWriteToken-nav"><a href="module-ElvClient_ContentManagement.html#.DeleteWriteToken" class="method-link">DeleteWriteToken</a></li><li data-type="method" id="ElvClient_ContentManagement-EditAndFinalizeContentObject-nav"><a href="module-ElvClient_ContentManagement.html#.EditAndFinalizeContentObject" class="method-link">EditAndFinalizeContentObject</a></li><li data-type="method" id="ElvClient_ContentManagement-EditContentObject-nav"><a href="module-ElvClient_ContentManagement.html#.EditContentObject" class="method-link">EditContentObject</a></li><li data-type="method" id="ElvClient_ContentManagement-FinalizeContentObject-nav"><a href="module-ElvClient_ContentManagement.html#.FinalizeContentObject" class="method-link">FinalizeContentObject</a></li><li data-type="method" id="ElvClient_ContentManagement-PublishContentVersion-nav"><a href="module-ElvClient_ContentManagement.html#.PublishContentVersion" class="method-link">PublishContentVersion</a></li><li data-type="method" id="ElvClient_ContentManagement-SetContentObjectImage-nav"><a href="module-ElvClient_ContentManagement.html#.SetContentObjectImage" class="method-link">SetContentObjectImage</a></li><li data-type="method" id="ElvClient_ContentManagement-SetPermission-nav"><a href="module-ElvClient_ContentManagement.html#.SetPermission" class="method-link">SetPermission</a></li><h4 class="methodGroupHeader">Content Types</h4><li data-type="method" id="ElvClient_ContentManagement-CreateContentType-nav"><a href="module-ElvClient_ContentManagement.html#.CreateContentType" class="method-link">CreateContentType</a></li><h4 class="methodGroupHeader">Links</h4><li data-type="method" id="ElvClient_ContentManagement-CreateLinks-nav"><a href="module-ElvClient_ContentManagement.html#.CreateLinks" class="method-link">CreateLinks</a></li><li data-type="method" id="ElvClient_ContentManagement-GenerateSignedLinkToken-nav"><a href="module-ElvClient_ContentManagement.html#.GenerateSignedLinkToken" class="method-link">GenerateSignedLinkToken</a></li><li data-type="method" id="ElvClient_ContentManagement-UpdateContentObjectGraph-nav"><a href="module-ElvClient_ContentManagement.html#.UpdateContentObjectGraph" class="method-link">UpdateContentObjectGraph</a></li><h4 class="methodGroupHeader">Metadata</h4><li data-type="method" id="ElvClient_ContentManagement-DeleteMetadata-nav"><a href="module-ElvClient_ContentManagement.html#.DeleteMetadata" class="method-link">DeleteMetadata</a></li><li data-type="method" id="ElvClient_ContentManagement-MergeMetadata-nav"><a href="module-ElvClient_ContentManagement.html#.MergeMetadata" class="method-link">MergeMetadata</a></li><li data-type="method" id="ElvClient_ContentManagement-ReplaceMetadata-nav"><a href="module-ElvClient_ContentManagement.html#.ReplaceMetadata" class="method-link">ReplaceMetadata</a></li></ul></li><li id="ElvClient_Contracts-nav">
          <div data-name="ElvClient/Contracts" class="class-link-container"><a class="class-link">ElvClient/Contracts</a></div><ul class='methods'><li data-type="method" id="ElvClient_Contracts-ElvClient/Contracts-nav"><a href="module-ElvClient_Contracts.html" class="method-link">ElvClient/Contracts</a></li><h4 class="methodGroupHeader">Blockchain</h4><li data-type="method" id="ElvClient_Contracts-BlockNumber-nav"><a href="module-ElvClient_Contracts.html#.BlockNumber" class="method-link">BlockNumber</a></li><li data-type="method" id="ElvClient_Contracts-Events-nav"><a href="module-ElvClient_Contracts.html#.Events" class="method-link">Events</a></li><li data-type="method" id="ElvClient_Contracts-GetBalance-nav"><a href="module-ElvClient_Contracts.html#.GetBalance" class="method-link">GetBalance</a></li><li data-type="method" id="ElvClient_Contracts-SendFunds-nav"><a href="module-ElvClient_Contracts.html#.SendFunds" class="method-link">SendFunds</a></li><h4 class="methodGroupHeader">Contracts</h4><li data-type="method" id="ElvClient_Contracts-CallContractMethod-nav"><a href="module-ElvClient_Contracts.html#.CallContractMethod" class="method-link">CallContractMethod</a></li><li data-type="method" id="ElvClient_Contracts-CallContractMethodAndWait-nav"><a href="module-ElvClient_Contracts.html#.CallContractMethodAndWait" class="method-link">CallContractMethodAndWait</a></li><li data-type="method" id="ElvClient_Contracts-ContractAbi-nav"><a href="module-ElvClient_Contracts.html#.ContractAbi" class="method-link">ContractAbi</a></li><li data-type="method" id="ElvClient_Contracts-ContractEvents-nav"><a href="module-ElvClient_Contracts.html#.ContractEvents" class="method-link">ContractEvents</a></li><li data-type="method" id="ElvClient_Contracts-ContractInfo-nav"><a href="module-ElvClient_Contracts.html#.ContractInfo" class="method-link">ContractInfo</a></li><li data-type="method" id="ElvClient_Contracts-ContractMetadata-nav"><a href="module-ElvClient_Contracts.html#.ContractMetadata" class="method-link">ContractMetadata</a></li><li data-type="method" id="ElvClient_Contracts-ContractName-nav"><a href="module-ElvClient_Contracts.html#.ContractName" class="method-link">ContractName</a></li><li data-type="method" id="ElvClient_Contracts-CustomContractAddress-nav"><a href="module-ElvClient_Contracts.html#.CustomContractAddress" class="method-link">CustomContractAddress</a></li><li data-type="method" id="ElvClient_Contracts-DeployContract-nav"><a href="module-ElvClient_Contracts.html#.DeployContract" class="method-link">DeployContract</a></li><li data-type="method" id="ElvClient_Contracts-ExtractEventFromLogs-nav"><a href="module-ElvClient_Contracts.html#.ExtractEventFromLogs" class="method-link">ExtractEventFromLogs</a></li><li data-type="method" id="ElvClient_Contracts-ExtractValueFromEvent-nav"><a href="module-ElvClient_Contracts.html#.ExtractValueFromEvent" class="method-link">ExtractValueFromEvent</a></li><li data-type="method" id="ElvClient_Contracts-FormatContractArguments-nav"><a href="module-ElvClient_Contracts.html#.FormatContractArguments" class="method-link">FormatContractArguments</a></li><li data-type="method" id="ElvClient_Contracts-MergeContractMetadata-nav"><a href="module-ElvClient_Contracts.html#.MergeContractMetadata" class="method-link">MergeContractMetadata</a></li><li data-type="method" id="ElvClient_Contracts-ReplaceContractMetadata-nav"><a href="module-ElvClient_Contracts.html#.ReplaceContractMetadata" class="method-link">ReplaceContractMetadata</a></li><li data-type="method" id="ElvClient_Contracts-SetCustomContentContract-nav"><a href="module-ElvClient_Contracts.html#.SetCustomContentContract" class="method-link">SetCustomContentContract</a></li><h4 class="methodGroupHeader">Tenant</h4><li data-type="method" id="ElvClient_Contracts-ResetTenantId-nav"><a href="module-ElvClient_Contracts.html#.ResetTenantId" class="method-link">ResetTenantId</a></li><li data-type="method" id="ElvClient_Contracts-SetTenantContractId-nav"><a href="module-ElvClient_Contracts.html#.SetTenantContractId" class="method-link">SetTenantContractId</a></li><li data-type="method" id="ElvClient_Contracts-SetTenantId-nav"><a href="module-ElvClient_Contracts.html#.SetTenantId" class="method-link">SetTenantId</a></li><li data-type="method" id="ElvClient_Contracts-TenantContractId-nav"><a href="module-ElvClient_Contracts.html#.TenantContractId" class="method-link">TenantContractId</a></li><li data-type="method" id="ElvClient_Contracts-TenantId-nav"><a href="module-ElvClient_Contracts.html#.TenantId" class="method-link">TenantId</a></li></ul></li><li id="ElvClient_Files+Parts-nav">
          <div data-name="ElvClient/Files+Parts" class="class-link-container"><a class="class-link">ElvClient/Files+Parts</a></div><ul class='methods'><li data-type="method" id="ElvClient_Files+Parts-ElvClient/Files+Parts-nav"><a href="module-ElvClient_Files+Parts.html" class="method-link">ElvClient/Files+Parts</a></li><h4 class="methodGroupHeader">Files</h4><li data-type="method" id="ElvClient_Files+Parts-CreateFileDirectories-nav"><a href="module-ElvClient_Files+Parts.html#.exports.CreateFileDirectories" class="method-link">CreateFileDirectories</a></li><li data-type="method" id="ElvClient_Files+Parts-DeleteFiles-nav"><a href="module-ElvClient_Files+Parts.html#.exports.DeleteFiles" class="method-link">DeleteFiles</a></li><li data-type="method" id="ElvClient_Files+Parts-DownloadFile-nav"><a href="module-ElvClient_Files+Parts.html#.exports.DownloadFile" class="method-link">DownloadFile</a></li><li data-type="method" id="ElvClient_Files+Parts-ListFiles-nav"><a href="module-ElvClient_Files+Parts.html#.exports.ListFiles" class="method-link">ListFiles</a></li><li data-type="method" id="ElvClient_Files+Parts-MoveFiles-nav"><a href="module-ElvClient_Files+Parts.html#.exports.MoveFiles" class="method-link">MoveFiles</a></li><li data-type="method" id="ElvClient_Files+Parts-UploadFiles-nav"><a href="module-ElvClient_Files+Parts.html#.exports.UploadFiles" class="method-link">UploadFiles</a></li><li data-type="method" id="ElvClient_Files+Parts-UploadFilesFromS3-nav"><a href="module-ElvClient_Files+Parts.html#.exports.UploadFilesFromS3" class="method-link">UploadFilesFromS3</a></li><h4 class="methodGroupHeader">Parts</h4><li data-type="method" id="ElvClient_Files+Parts-ContentPart-nav"><a href="module-ElvClient_Files+Parts.html#.exports.ContentPart" class="method-link">ContentPart</a></li><li data-type="method" id="ElvClient_Files+Parts-ContentParts-nav"><a href="module-ElvClient_Files+Parts.html#.exports.ContentParts" class="method-link">ContentParts</a></li><li data-type="method" id="ElvClient_Files+Parts-CreatePart-nav"><a href="module-ElvClient_Files+Parts.html#.exports.CreatePart" class="method-link">CreatePart</a></li><li data-type="method" id="ElvClient_Files+Parts-DeletePart-nav"><a href="module-ElvClient_Files+Parts.html#.exports.DeletePart" class="method-link">DeletePart</a></li><li data-type="method" id="ElvClient_Files+Parts-DownloadPart-nav"><a href="module-ElvClient_Files+Parts.html#.exports.DownloadPart" class="method-link">DownloadPart</a></li><li data-type="method" id="ElvClient_Files+Parts-FinalizePart-nav"><a href="module-ElvClient_Files+Parts.html#.exports.FinalizePart" class="method-link">FinalizePart</a></li><li data-type="method" id="ElvClient_Files+Parts-UploadPart-nav"><a href="module-ElvClient_Files+Parts.html#.exports.UploadPart" class="method-link">UploadPart</a></li><li data-type="method" id="ElvClient_Files+Parts-UploadPartChunk-nav"><a href="module-ElvClient_Files+Parts.html#.exports.UploadPartChunk" class="method-link">UploadPartChunk</a></li></ul></li><li id="ElvClient_LiveStream-nav">
          <div data-name="ElvClient/LiveStream" class="class-link-container"><a class="class-link">ElvClient/LiveStream</a></div><ul class='methods'><li data-type="method" id="ElvClient_LiveStream-ElvClient/LiveStream-nav"><a href="module-ElvClient_LiveStream.html" class="method-link">ElvClient/LiveStream</a></li><h4 class="methodGroupHeader">Live Stream</h4><li data-type="method" id="ElvClient_LiveStream-AuditStream-nav"><a href="module-ElvClient_LiveStream.html#.AuditStream" class="method-link">AuditStream</a></li><li data-type="method" id="ElvClient_LiveStream-StreamAddWatermark-nav"><a href="module-ElvClient_LiveStream.html#.StreamAddWatermark" class="method-link">StreamAddWatermark</a></li><li data-type="method" id="ElvClient_LiveStream-StreamConfig-nav"><a href="module-ElvClient_LiveStream.html#.StreamConfig" class="method-link">StreamConfig</a></li><li data-type="method" id="ElvClient_LiveStream-StreamCreate-nav"><a href="module-ElvClient_LiveStream.html#.StreamCreate" class="method-link">StreamCreate</a></li><li data-type="method" id="ElvClient_LiveStream-StreamInitialize-nav"><a href="module-ElvClient_LiveStream.html#.StreamInitialize" class="method-link">StreamInitialize</a></li><li data-type="method" id="ElvClient_LiveStream-StreamInsertion-nav"><a href="module-ElvClient_LiveStream.html#.StreamInsertion" class="method-link">StreamInsertion</a></li><li data-type="method" id="ElvClient_LiveStream-StreamListUrls-nav"><a href="module-ElvClient_LiveStream.html#.StreamListUrls" class="method-link">StreamListUrls</a></li><li data-type="method" id="ElvClient_LiveStream-StreamRemoveWatermark-nav"><a href="module-ElvClient_LiveStream.html#.StreamRemoveWatermark" class="method-link">StreamRemoveWatermark</a></li><li data-type="method" id="ElvClient_LiveStream-StreamSetOfferingAndDRM-nav"><a href="module-ElvClient_LiveStream.html#.StreamSetOfferingAndDRM" class="method-link">StreamSetOfferingAndDRM</a></li><li data-type="method" id="ElvClient_LiveStream-StreamStartOrStopOrReset-nav"><a href="module-ElvClient_LiveStream.html#.StreamStartOrStopOrReset" class="method-link">StreamStartOrStopOrReset</a></li><li data-type="method" id="ElvClient_LiveStream-StreamStatus-nav"><a href="module-ElvClient_LiveStream.html#.StreamStatus" class="method-link">StreamStatus</a></li><li data-type="method" id="ElvClient_LiveStream-StreamStopSession-nav"><a href="module-ElvClient_LiveStream.html#.StreamStopSession" class="method-link">StreamStopSession</a></li><li data-type="method" id="ElvClient_LiveStream-StreamGenerateOffering-nav"><a href="module-ElvClient_LiveStream.html#~StreamGenerateOffering" class="method-link">StreamGenerateOffering</a></li></ul></li><li id="ElvClient_NFT-nav">
          <div data-name="ElvClient/NFT" class="class-link-container"><a class="class-link">ElvClient/NFT</a></div><ul class='methods'><li data-type="method" id="ElvClient_NFT-ElvClient/NFT-nav"><a href="module-ElvClient_NFT.html" class="method-link">ElvClient/NFT</a></li><h4 class="methodGroupHeader">Minting</h4><li data-type="method" id="ElvClient_NFT-MintNFT-nav"><a href="module-ElvClient_NFT.html#.MintNFT" class="method-link">MintNFT</a></li><h4 class="methodGroupHeader">Transactions</h4><li data-type="method" id="ElvClient_NFT-CollectionTransactions-nav"><a href="module-ElvClient_NFT.html#.CollectionTransactions" class="method-link">CollectionTransactions</a></li></ul></li><li id="ElvClient_NTP-nav">
          <div data-name="ElvClient/NTP" class="class-link-container"><a class="class-link">ElvClient/NTP</a></div><ul class='methods'><li data-type="method" id="ElvClient_NTP-ElvClient/NTP-nav"><a href="module-ElvClient_NTP.html" class="method-link">ElvClient/NTP</a></li><h4 class="methodGroupHeader">NTP Instances</h4><li data-type="method" id="ElvClient_NTP-CreateNTPInstance-nav"><a href="module-ElvClient_NTP.html#.CreateNTPInstance" class="method-link">CreateNTPInstance</a></li><li data-type="method" id="ElvClient_NTP-DeleteNTPInstance-nav"><a href="module-ElvClient_NTP.html#.DeleteNTPInstance" class="method-link">DeleteNTPInstance</a></li><li data-type="method" id="ElvClient_NTP-ListNTPInstances-nav"><a href="module-ElvClient_NTP.html#.ListNTPInstances" class="method-link">ListNTPInstances</a></li><li data-type="method" id="ElvClient_NTP-NTPInstance-nav"><a href="module-ElvClient_NTP.html#.NTPInstance" class="method-link">NTPInstance</a></li><li data-type="method" id="ElvClient_NTP-SuspendNTPInstance-nav"><a href="module-ElvClient_NTP.html#.SuspendNTPInstance" class="method-link">SuspendNTPInstance</a></li><li data-type="method" id="ElvClient_NTP-UpdateNTPInstance-nav"><a href="module-ElvClient_NTP.html#.UpdateNTPInstance" class="method-link">UpdateNTPInstance</a></li><h4 class="methodGroupHeader">Tickets</h4><li data-type="method" id="ElvClient_NTP-IssueNTPCode-nav"><a href="module-ElvClient_NTP.html#.IssueNTPCode" class="method-link">IssueNTPCode</a></li><li data-type="method" id="ElvClient_NTP-IssueSignedNTPCode-nav"><a href="module-ElvClient_NTP.html#.IssueSignedNTPCode" class="method-link">IssueSignedNTPCode</a></li><li data-type="method" id="ElvClient_NTP-RedeemCode-nav"><a href="module-ElvClient_NTP.html#.RedeemCode" class="method-link">RedeemCode</a></li></ul></li></ul><h3>Namespaces</h3><ul><li id="Crypto-nav">
          <div data-name="Crypto" class="class-link-container"><a class="class-link">Crypto</a></div><ul class='methods'><li data-type="method" id="Crypto-Crypto-nav"><a href="Crypto.html" class="method-link">Crypto</a></li><h4 class="methodGroupHeader">Methods</h4><li data-type="method" id="Crypto-Decrypt-nav"><a href="Crypto.html#.Decrypt" class="method-link">Decrypt</a></li><li data-type="method" id="Crypto-Encrypt-nav"><a href="Crypto.html#.Encrypt" class="method-link">Encrypt</a></li></ul></li><li id="Utils-nav">
          <div data-name="Utils" class="class-link-container"><a class="class-link">Utils</a></div><ul class='methods'><li data-type="method" id="Utils-Utils-nav"><a href="Utils.html" class="method-link">Utils</a></li><h4 class="methodGroupHeader">Methods</h4><li data-type="method" id="Utils-AddressToHash-nav"><a href="Utils.html#.AddressToHash" class="method-link">AddressToHash</a></li><li data-type="method" id="Utils-AddressToLibraryId-nav"><a href="Utils.html#.AddressToLibraryId" class="method-link">AddressToLibraryId</a></li><li data-type="method" id="Utils-AddressToNodeId-nav"><a href="Utils.html#.AddressToNodeId" class="method-link">AddressToNodeId</a></li><li data-type="method" id="Utils-AddressToObjectId-nav"><a href="Utils.html#.AddressToObjectId" class="method-link">AddressToObjectId</a></li><li data-type="method" id="Utils-AddressToSpaceId-nav"><a href="Utils.html#.AddressToSpaceId" class="method-link">AddressToSpaceId</a></li><li data-type="method" id="Utils-DecodeAuthorizationToken-nav"><a href="Utils.html#.DecodeAuthorizationToken" class="method-link">DecodeAuthorizationToken</a></li><li data-type="method" id="Utils-DecodeSignedToken-nav"><a href="Utils.html#.DecodeSignedToken" class="method-link">DecodeSignedToken</a></li><li data-type="method" id="Utils-DecodeVersionHash-nav"><a href="Utils.html#.DecodeVersionHash" class="method-link">DecodeVersionHash</a></li><li data-type="method" id="Utils-DecodeWriteToken-nav"><a href="Utils.html#.DecodeWriteToken" class="method-link">DecodeWriteToken</a></li><li data-type="method" id="Utils-EqualAddress-nav"><a href="Utils.html#.EqualAddress" class="method-link">EqualAddress</a></li><li data-type="method" id="Utils-EqualHash-nav"><a href="Utils.html#.EqualHash" class="method-link">EqualHash</a></li><li data-type="method" id="Utils-EtherToWei-nav"><a href="Utils.html#.EtherToWei" class="method-link">EtherToWei</a></li><li data-type="method" id="Utils-FormatAddress-nav"><a href="Utils.html#.FormatAddress" class="method-link">FormatAddress</a></li><li data-type="method" id="Utils-FormatSignature-nav"><a href="Utils.html#.FormatSignature" class="method-link">FormatSignature</a></li><li data-type="method" id="Utils-HashToAddress-nav"><a href="Utils.html#.HashToAddress" class="method-link">HashToAddress</a></li><li data-type="method" id="Utils-IsCloneable-nav"><a href="Utils.html#.IsCloneable" class="method-link">IsCloneable</a></li><li data-type="method" id="Utils-MakeClonable-nav"><a href="Utils.html#.MakeClonable" class="method-link">MakeClonable</a></li><li data-type="method" id="Utils-PublicKeyToAddress-nav"><a href="Utils.html#.PublicKeyToAddress" class="method-link">PublicKeyToAddress</a></li><li data-type="method" id="Utils-ResizeImage-nav"><a href="Utils.html#.ResizeImage" class="method-link">ResizeImage</a></li><li data-type="method" id="Utils-ResponseToFormat-nav"><a href="Utils.html#.ResponseToFormat" class="method-link">ResponseToFormat</a></li><li data-type="method" id="Utils-ResponseToJson-nav"><a href="Utils.html#.ResponseToJson" class="method-link">ResponseToJson</a></li><li data-type="method" id="Utils-ToBigNumber-nav"><a href="Utils.html#.ToBigNumber" class="method-link">ToBigNumber</a></li><li data-type="method" id="Utils-ToBytes32-nav"><a href="Utils.html#.ToBytes32" class="method-link">ToBytes32</a></li><li data-type="method" id="Utils-ValidAddress-nav"><a href="Utils.html#.ValidAddress" class="method-link">ValidAddress</a></li><li data-type="method" id="Utils-ValidHash-nav"><a href="Utils.html#.ValidHash" class="method-link">ValidHash</a></li><li data-type="method" id="Utils-WeiToEther-nav"><a href="Utils.html#.WeiToEther" class="method-link">WeiToEther</a></li></ul></li></ul>
      </div>
    </nav>

    <div class="main">
      <div class="header"></div>
      <div class="main-content">
        
        <h1 class="page-title">
          client/LiveStream.js
        </h1>
        

        
      

<a class="button" href="client_LiveStream.html">Back</a>
<div class="source-container">
  <pre class="prettyprint source linenums"><code>/* eslint no-console: 0 */

/**
 * Methods for Live Stream creation and management
 *
 * @module ElvClient/LiveStream
 */

const {LiveConf} = require("./LiveConf");
const path = require("path");
const fs = require("fs");
const HttpClient = require("../HttpClient");
const Fraction = require("fraction.js");
const {ValidateObject, ValidatePresence} = require("../Validation");
const ContentObjectAudit = require("../ContentObjectAudit");

const MakeTxLessToken = async({client, libraryId, objectId, versionHash}) => {
  const tok = await client.authClient.AuthorizationToken({libraryId, objectId,
    versionHash, channelAuth: false, noCache: true,
    noAuth: true});

  return tok;
};

const Sleep = (ms) => {
  return new Promise(resolve => setTimeout(resolve, ms));
};

const CueInfo = async ({eventId, status}) => {
  let cues;
  try {
    const lroStatusResponse = await this.utils.ResponseToJson(
      await HttpClient.Fetch(status.lro_status_url)
    );
    console.log("lroStatusResponse", lroStatusResponse);
    cues = lroStatusResponse.custom.cues;
  } catch(error) {
    console.log("LRO status failed", error);
    return {error: "failed to retrieve status", eventId};
  }

  let eventStart, eventEnd;
  for(const value of Object.values(cues)) {
    for(const event of Object.values(value.descriptors)) {
      if(event.id == eventId) {
        switch(event.type_id) {
          case 32:
          case 16:
            eventStart = value.insertion_time;
            break;
          case 33:
          case 17:
            eventEnd = value.insertion_time;
            break;

        }
      }
    }
  }

  return {eventStart, eventEnd, eventId};
};

/**
 * Set the offering for the live stream
 *
 * @methodGroup Live Stream
 * @namedParams
 * @param {Object} client - The client object
 * @param {string} libraryId - ID of the library for the new live stream object
 * @param {string} objectId - ID of the new live stream object
 * @param {string=} typeAbrMaster - Content type hash
 * @param {string=} typeLiveStream - Content type hash
 * @param {string} streamUrl - Live source URL
 * @param {object} abrProfile - ABR Profile for the offering
 * @param {number} aBitRate - Audio bitrate
 * @param {number} aChannels - Audio channels
 * @param {number} aSampleRate - Audio sample rate
 * @param {number} aStreamIndex - Audio stream index
 * @param {string} aTimeBase - Audio time base as a fraction, e.g. "1/48000" (usually equal to 1/aSampleRate)
 * @param {string} aChannelLayout - Channel layout, e.g. "stereo"
 * @param {number} vBitRate - Video bitrate
 * @param {number} vHeight - Video height
 * @param {number} vStreamIndex - Video stream index
 * @param {number} vWidth - Video width
 * @param {string} vDisplayAspectRatio - Display aspect ratio as a fraction, e.g. "16/9"
 * @param {string} vFrameRate - Frame rate as an integer, e.g. "30"
 * @param {string} vTimeBase - Time base as a fraction, e.g. "1/30000"
 *
 * @return {Promise&lt;string>} - Final hash of the live stream object
 */
const StreamGenerateOffering = async({
  client,
  libraryId,
  objectId,
  typeAbrMaster,
  typeLiveStream,
  streamUrl,
  abrProfile,
  aBitRate,
  aChannels,
  aSampleRate,
  aStreamIndex,
  aTimeBase,
  aChannelLayout,
  vBitRate,
  vHeight,
  vStreamIndex,
  vWidth,
  vDisplayAspectRatio,
  vFrameRate,
  vTimeBase
}) => {
  // compute duration_ts
  const DUMMY_DURATION = 1001; // should result in integer duration_ts values for both audio and video
  const aDurationTs = Fraction(aTimeBase).inverse().mul(DUMMY_DURATION).valueOf();
  const vDurationTs = Fraction(vTimeBase).inverse().mul(DUMMY_DURATION).valueOf();

  // construct /production_master/sources/STREAM_URL/streams

  const sourceAudioStream = {
    "bit_rate": aBitRate,
    "channel_layout": aChannelLayout,
    "channels": aChannels,
    "codec_name": "aac",
    "duration": DUMMY_DURATION,
    "duration_ts": aDurationTs,
    "frame_count": 0,
    "language": "",
    "max_bit_rate": aBitRate,
    "sample_rate": aSampleRate,
    "start_pts": 0,
    "start_time": 0,
    "time_base": aTimeBase,
    "type": "StreamAudio"
  };

  const sourceVideoStream = {
    "bit_rate": vBitRate,
    "codec_name": "h264",
    "display_aspect_ratio": vDisplayAspectRatio,
    "duration": DUMMY_DURATION,
    "duration_ts": vDurationTs,
    "field_order": "progressive",
    "frame_count": 0,
    "frame_rate": vFrameRate,
    "hdr": null,
    "height": vHeight,
    "language": "",
    "max_bit_rate": vBitRate,
    "sample_aspect_ratio": "1",
    "start_pts": 0,
    "start_time": 0,
    "time_base": vTimeBase,
    "type": "StreamVideo",
    "width": vWidth
  };

  // placeholder stream to use if [aStreamIndex, vStreamIndex].sort() is not [0,1]
  const DUMMY_STREAM = {
    "bit_rate": 0,
    "codec_name": "",
    "duration": DUMMY_DURATION,
    "duration_ts": 2500 * DUMMY_DURATION,
    "frame_count": 1,
    "language": "",
    "max_bit_rate": 0,
    "start_pts": 0,
    "start_time": 0,
    "time_base": "1/2500",
    "type": "StreamData"
  };

  const sourceStreams = [];
  const maxStreamIndex = Math.max(aStreamIndex, vStreamIndex);

  for(let i = 0; i &lt;= maxStreamIndex; i++) {
    if(i === aStreamIndex) {
      sourceStreams.push(sourceAudioStream);
    } else if(i === vStreamIndex) {
      sourceStreams.push(sourceVideoStream);
    } else {
      sourceStreams.push(DUMMY_STREAM);
    }
  }

  // construct /production_master/sources
  const sources = {
    [streamUrl]: {
      "container_format": {
        "duration": DUMMY_DURATION,
        "filename": streamUrl,
        "format_name": "mov,mp4,m4a,3gp,3g2,mj2",
        "start_time": 0
      },
      "streams": sourceStreams
    }
  };

  // construct /production_master/variants
  const variants = {
    "default": {
      "streams": {
        "audio": {
          "default_for_media_type": false,
          "label": "",
          "language": "",
          "mapping_info": "",
          "sources": [
            {
              "files_api_path": streamUrl,
              "stream_index": aStreamIndex
            }
          ]
        },
        "video": {
          "default_for_media_type": false,
          "label": "",
          "language": "",
          "mapping_info": "",
          "sources": [
            {
              "files_api_path": streamUrl,
              "stream_index": vStreamIndex
            }
          ]
        }
      }
    }
  };

  // construct /production_master
  const production_master = {sources, variants};

  // get existing metadata
  console.log("Retrieving current metadata...");
  let metadata = await client.ContentObjectMetadata({
    libraryId,
    objectId
  });

  // add /production_master to metadata
  metadata.production_master = production_master;

  // write back to object
  console.log("Getting write token...");
  let editResponse = await client.EditContentObject({
    libraryId,
    objectId,
    options: {
      type: typeAbrMaster
    }
  });
  let writeToken = editResponse.write_token;
  console.log(`New write token: ${writeToken}`);

  console.log("Writing back metadata with /production_master added...");
  await client.ReplaceMetadata({
    libraryId,
    metadata,
    objectId,
    writeToken
  });

  console.log("Finalizing...");
  let finalizeResponse = await client.FinalizeContentObject({
    libraryId,
    objectId,
    writeToken
  });
  let masterVersionHash = finalizeResponse.hash;
  console.log(`Finalized, new version hash: ${masterVersionHash}`);

  // Generate offering
  const createResponse = await client.CreateABRMezzanine({
    libraryId,
    objectId,
    masterVersionHash,
    variant: "default",
    offeringKey: "default",
    abrProfile
  });

  if(createResponse.warnings.length > 0) {
    console.log("WARNINGS:");
    console.log(JSON.stringify(createResponse.warnings, null, 2));
  }

  if(createResponse.errors.length > 0) {
    console.log("ERRORS:");
    console.log(JSON.stringify(createResponse.errors, null, 2));
  }

  let versionHash = createResponse.hash;
  console.log(`New version hash: ${versionHash}`);

  // get new metadata
  console.log("Retrieving revised metadata with offering...");
  metadata = await client.ContentObjectMetadata({
    libraryId,
    versionHash
  });

  console.log("Moving /abr_mezzanine/offerings to /offerings and removing /abr_mezzanine...");
  metadata.offerings = metadata.abr_mezzanine.offerings;
  delete metadata.abr_mezzanine;

  // add items to media_struct needed to use options.json handler
  metadata.offerings.default.media_struct.duration_rat = `${DUMMY_DURATION}`;

  // write back to object
  console.log("Getting write token...");
  editResponse = await client.EditContentObject({
    libraryId,
    objectId,
    options: {
      type: typeLiveStream
    }
  });
  writeToken = editResponse.write_token;
  console.log(`New write token: ${writeToken}`);

  console.log("Writing back metadata with /offerings...");
  await client.ReplaceMetadata({
    libraryId,
    metadata,
    objectId,
    writeToken
  });

  console.log("Finalizing...");
  finalizeResponse = await client.FinalizeContentObject({
    libraryId,
    objectId,
    writeToken
  });

  const finalHash = finalizeResponse.hash;
  console.log(`Finalized, new version hash: ${finalHash}`);

  return finalHash;
};

/**
 * Retrieve the status of the current live stream session
 *
 * @methodGroup Live Stream
 * @namedParams
 * @param {string} name - Object ID or name of the live stream object
 * @param {boolean=} stopLro - If specified, will stop LRO
 * @param {boolean=} showParams - If specified, will return recording_params with status
 * States:
 * unconfigured    - no live_recording_config
 * uninitialized   - no live_recording config generated
 * inactive        - live_recording config initialized but no 'edge write token'
 * stopped         - edge-write-token but not started
 * starting        - LRO running but no source data yet
 * running         - stream is running and producing output
 * stalled         - LRO running but no source data (so not producing output)
 *
 * @return {Promise&lt;Object>} - The status response for the object, as well as logs, warnings and errors from the master initialization
 */
exports.StreamStatus = async function({name, stopLro=false, showParams=false}) {
  let objectId = name;
  let status = {name: name};

  try {
    let libraryId = await this.ContentObjectLibraryId({objectId});
    status.library_id = libraryId;
    status.object_id = objectId;

    let mainMeta = await this.ContentObjectMetadata({
      libraryId,
      objectId,
      select: [
        "live_recording_config",
        "live_recording"
      ]
    });

    status.reference_url = mainMeta.live_recording_config.reference_url;

    if(mainMeta.live_recording_config == undefined || mainMeta.live_recording_config.url == undefined) {
      status.state = "unconfigured";
      return status;
    }

    if(mainMeta.live_recording == undefined || mainMeta.live_recording.fabric_config == undefined ||
      mainMeta.live_recording.playout_config == undefined || mainMeta.live_recording.recording_config == undefined) {
      status.state = "uninitialized";
      return status;
    }

    let fabURI = mainMeta.live_recording.fabric_config.ingress_node_api;
    if(fabURI === undefined) {
      console.log("bad fabric config - missing ingress node API");
      status.state = "uninitialized";
      return status;
    }

    // Support both hostname and URL ingress_node_api
    if(!fabURI.startsWith("http")) {
      // Assume https
      fabURI = "https://" + fabURI;
    }

    status.fabric_api = fabURI;
    status.url = mainMeta.live_recording.recording_config.recording_params.origin_url;

    let edgeWriteToken = mainMeta.live_recording.fabric_config.edge_write_token;
    if(!edgeWriteToken) {
      status.state = "inactive";
      return status;
    }

    this.RecordWriteToken({writeToken: edgeWriteToken, fabricNodeUrl: fabURI});

    status.edge_write_token = edgeWriteToken;
    status.stream_id = edgeWriteToken; // By convention the stream ID is its write token
    let edgeMeta;
    try {
      edgeMeta = await this.ContentObjectMetadata({
        libraryId: libraryId,
        objectId: objectId,
        writeToken: edgeWriteToken,
        select: [
          "live_recording"
        ]
      });
    } catch(error) {
      console.error("Unable to read edge write token metadata. Has token been deleted?", error);
      status.state = "inactive";
      return status;
    }

    status.edge_meta_size = JSON.stringify(edgeMeta || "").length;

    // If a stream has never been started return state 'inactive'
    if(edgeMeta.live_recording === undefined ||
      edgeMeta.live_recording.recordings === undefined ||
      edgeMeta.live_recording.recordings.recording_sequence === undefined) {
      status.state = "stopped";
      return status;
    }

    let recordings = edgeMeta.live_recording.recordings;
    status.recording_period_sequence = recordings.recording_sequence;

    let sequence = recordings.recording_sequence;
    let period = recordings.live_offering[sequence - 1];

    let tlro = period.live_recording_handle;
    status.tlro = tlro;

    let videoLastFinalizationTimeEpochSec = -1;
    let videoFinalizedParts = 0;
    let sinceLastFinalize = -1;
    if(period.finalized_parts_info &amp;&amp; period.finalized_parts_info.video &amp;&amp; period.finalized_parts_info.video.last_finalization_time) {
      videoLastFinalizationTimeEpochSec = period.finalized_parts_info.video.last_finalization_time / 1000000;
      videoFinalizedParts = period.finalized_parts_info.video.n_parts;
      sinceLastFinalize = Math.floor(new Date().getTime() / 1000) - videoLastFinalizationTimeEpochSec;
    }

    let recording_period = {
      activation_time_epoch_sec: period.recording_start_time_epoch_sec,
      start_time_epoch_sec: period.start_time_epoch_sec,
      start_time_text: new Date(period.start_time_epoch_sec * 1000).toLocaleString(),
      end_time_epoch_sec: period.end_time_epoch_sec,
      end_time_text:  period.end_time_epoch_sec === 0 ? null : new Date(period.end_time_epoch_sec * 1000).toLocaleString(),
      video_parts: videoFinalizedParts,
      video_last_part_finalized_epoch_sec: videoLastFinalizationTimeEpochSec,
      video_since_last_finalize_sec : sinceLastFinalize
    };
    status.recording_period = recording_period;

    status.lro_status_url = await this.FabricUrl({
      libraryId: libraryId,
      objectId: objectId,
      writeToken: edgeWriteToken,
      call: "live/status/" + tlro
    });

    status.insertions = [];
    if((edgeMeta.live_recording.playout_config.interleaves != undefined) &amp;&amp;
      (edgeMeta.live_recording.playout_config.interleaves[sequence] != undefined)) {
      let insertions = edgeMeta.live_recording.playout_config.interleaves[sequence];
      for(let i = 0; i &lt; insertions.length; i ++) {
        let insertionTimeSinceEpoch = recording_period.start_time_epoch_sec + insertions[i].insertion_time;
        status.insertions[i] = {
          insertion_time_since_start: insertions[i].insertion_time,
          insertion_time: new Date(insertionTimeSinceEpoch * 1000).toISOString(),
          insertion_time_local: new Date(insertionTimeSinceEpoch * 1000).toLocaleString(),
          target: insertions[i].playout};
      }
    }

    if(showParams) {
      status.recording_params = edgeMeta.live_recording.recording_config.recording_params;
    }

    let state = "stopped";
    let lroStatus = "";
    try {
      lroStatus = await this.utils.ResponseToJson(
        await HttpClient.Fetch(status.lro_status_url)
      );
      state = lroStatus.state;
      status.warnings = lroStatus.custom &amp;&amp; lroStatus.custom.warnings;
      status.quality = lroStatus.custom &amp;&amp; lroStatus.custom.quality;
      if(lroStatus.custom &amp;&amp; lroStatus.custom.status) {
        status.recording_status = lroStatus.custom.status;
      }
    } catch(error) {
      console.log("LRO Status (failed): ", error.response.statusCode);
      status.state = "stopped";
      status.error = error.response;
      return status;
    }

    const segDurationMeta = edgeMeta.live_recording.recording_config.recording_params.xc_params.seg_duration;

    // Convert LRO 'state' to desired 'state'
    if(state === "running" &amp;&amp; videoLastFinalizationTimeEpochSec &lt;= 0) {
      state = "starting";
    } else if(state === "running" &amp;&amp; segDurationMeta !== undefined &amp;&amp; sinceLastFinalize > (parseInt(segDurationMeta) + 5)) {
      state = "stalled";
    } else if(state == "terminated") {
      state = "stopped";
    }
    status.state = state;

    if((state === "running" || state === "stalled" || state === "starting") &amp;&amp; stopLro) {
      lroStopUrl = await this.FabricUrl({
        libraryId,
        objectId,
        writeToken: edgeWriteToken,
        call: "live/stop/" + tlro
      });

      try {
        await this.utils.ResponseToJson(
          await HttpClient.Fetch(lroStopUrl)
        );

        console.log("LRO Stop: ", lroStatus.body);
      } catch(error) {
        console.log("LRO Stop (failed): ", error.response.statusCode);
      }

      state = "stopped";
      status.state = state;
    }

    if(state === "running") {
      let playout_urls = {};
      let playout_options = await this.PlayoutOptions({
        objectId,
        linkPath: "public/asset_metadata/sources/default"
      });

      let hls_clear_enabled = (
        playout_options &amp;&amp;
        playout_options.hls &amp;&amp;
        playout_options.hls.playoutMethods &amp;&amp;
        playout_options.hls.playoutMethods.clear !== undefined
      );
      if(hls_clear_enabled) {
        playout_urls.hls_clear = await this.FabricUrl({
          libraryId: libraryId,
          objectId: objectId,
          rep: "playout/default/hls-clear/playlist.m3u8",
        });
      }

      let hls_aes128_enabled = (
        playout_options &amp;&amp;
        playout_options.hls &amp;&amp;
        playout_options.hls.playoutMethods &amp;&amp;
        playout_options.hls.playoutMethods["aes-128"] !== undefined
      );
      if(hls_aes128_enabled) {
        playout_urls.hls_aes128 = await this.FabricUrl({
          libraryId: libraryId,
          objectId: objectId,
          rep: "playout/default/hls-aes128/playlist.m3u8",
        });
      }

      let hls_sample_aes_enabled = (
        playout_options &amp;&amp;
        playout_options.hls &amp;&amp;
        playout_options.hls.playoutMethods &amp;&amp;
        playout_options.hls.playoutMethods["sample-aes"] !== undefined
      );
      if(hls_sample_aes_enabled) {
        playout_urls.hls_sample_aes = await this.FabricUrl({
          libraryId: libraryId,
          objectId: objectId,
          rep: "playout/default/hls-sample-aes/playlist.m3u8",
        });
      }

      const networkInfo = await this.NetworkInfo();
      let token = await this.authClient.AuthorizationToken({
        libraryId,
        objectId,
        channelAuth: false,
        noCache: true,
        noAuth: true
      });

      let embed_net = "main";
      if(networkInfo.name.includes("demo")) {
        embed_net = "demo";
      }
      let embed_url = `https://embed.v3.contentfabric.io/?net=${embed_net}&amp;p&amp;ct=h&amp;oid=${objectId}&amp;mt=lv&amp;ath=${token}`;
      playout_urls.embed_url = embed_url;

      status.playout_urls = playout_urls;
    }
  } catch(error) {
    console.error(error);
  }

  return status;
};

/**
 * Create a new edge write token
 *
 * @methodGroup Live Stream
 * @namedParams
 * @param {string} name - Object ID or name of the live stream object
 * @param {boolean=} start - If specified, will start the stream after creation
 *
 * @return {Promise&lt;Object>} - The status response for the object
 *
*/
exports.StreamCreate = async function({name, start=false}) {
  let status = await this.StreamStatus({name});
  if(status.state != "uninitialized" &amp;&amp; status.state !== "inactive" &amp;&amp; status.state !== "terminated" &amp;&amp; status.state !== "stopped") {
    return {
      state: status.state,
      error: "stream still active - must terminate first"
    };
  }

  let objectId = status.object_id;
  console.log("START: ", name, "start", start);

  let libraryId = await this.ContentObjectLibraryId({objectId: objectId});

  // Read live recording parameters - determine ingest node
  let liveRecording = await this.ContentObjectMetadata({
    libraryId: libraryId,
    objectId: objectId,
    metadataSubtree: "/live_recording"
  });

  let fabURI = liveRecording.fabric_config.ingress_node_api;
  // Support both hostname and URL ingress_node_api
  if(!fabURI.startsWith("http")) {
    // Assume https
    fabURI = "https://" + fabURI;
  }

  this.SetNodes({fabricURIs: [fabURI]});

  console.log("Node URI", fabURI, "ID", liveRecording.fabric_config.ingress_node_id);

  let response = await this.EditContentObject({
    libraryId: libraryId,
    objectId: objectId
  });
  const edgeToken = response.write_token;
  console.log("Edge token:", edgeToken);

  /*
  * Set the metadata, including the edge token.
  */
  response = await this.EditContentObject({
    libraryId: libraryId,
    objectId: objectId
  });
  let writeToken = response.write_token;

  this.Log("Merging metadata: ", libraryId, objectId, writeToken);
  await this.MergeMetadata({
    libraryId: libraryId,
    objectId: objectId,
    writeToken: writeToken,
    metadata: {
      live_recording: {
        status: {
          edge_write_token: edgeToken,
          state: "active"  // indicates there is an active session (set to 'closed' when done)
        },
        fabric_config: {
          edge_write_token: edgeToken
        }
      }
    }
  });

  this.Log("Finalizing content draft: ", libraryId, objectId, writeToken);
  response = await this.FinalizeContentObject({
    libraryId: libraryId,
    objectId: objectId,
    writeToken: writeToken,
    commitMessage: "Create stream edge write token " + edgeToken
  });

  const objectHash = response.hash;
  this.Log("Finalized object: ", objectHash);

  status = {
    object_id: objectId,
    hash: objectHash,
    library_id: libraryId,
    stream_id: edgeToken,
    edge_write_token: edgeToken,
    fabric_api: fabURI,
    state: "stopped"
  };

  if(start) {
    status = this.StreamStartOrStopOrReset({name, op: start});
  }

  return status;
};

/**
 * Start, stop or reset a stream within the current session (current edge write token)
 *
 * @methodGroup Live Stream
 * @namedParams
 * @param {string} name - Object ID or name of the live stream object
 * @param {string} op - The operation to perform. Possible values:
 * 'start'
 * 'reset' - Stops current LRO recording and starts a new one.  Does
 * not create a new edge write token (just creates a new recording
 * period in the existing edge write token)
 * - 'stop'
 *
 * @return {Promise&lt;Object>} - The status response for the stream
 *
*/
exports.StreamStartOrStopOrReset = async function({name, op}) {
  try {
    let status = await this.StreamStatus({name});
    if(status.state != "stopped") {
      if(op === "start") {
        status.error = "Unable to start stream - state: " + status.state;
        return status;
      }
    }

    if(status.state == "running" || status.state == "starting" || status.state == "stalled") {
      try {
        await this.CallBitcodeMethod({
          libraryId: status.library_id,
          objectId: status.object_id,
          writeToken: status.edge_write_token,
          method: "/live/stop/" + status.tlro,
          constant: false
        });
      } catch(error) {
        // The /call/lro/stop API returns empty response
        // console.log("LRO Stop (failed): ", error);
      }

      // Wait until LRO is terminated
      let tries = 10;
      while(status.state != "stopped" &amp;&amp; tries-- > 0) {
        console.log("Wait to terminate - ", status.state);
        await Sleep(1000);
        status = await this.StreamStatus({name});
      }

      console.log("Status after stop - ", status.state);

      if(tries &lt;= 0) {
        console.log("Failed to stop");
        return status;
      }
    }

    if(op === "stop") {
      return status;
    }

    console.log("STARTING", "edge_write_token", status.edge_write_token);

    try {
      await this.CallBitcodeMethod({
        libraryId: status.library_id,
        objectId: status.object_id,
        writeToken: status.edge_write_token,
        method: "/live/start",
        constant: false
      });
    } catch(error) {
      console.log("LRO Start (failed): ", error);
      return {
        state: status.state,
        error: "LRO start failed - must create a stream first"
      };
    }

    // Wait until LRO is 'starting'
    let tries = 10;
    while(status.state != "starting" &amp;&amp; tries-- > 0) {
      console.log("Wait to start - ", status.state);
      await Sleep(1000);
      status = await this.StreamStatus({name});
    }

    console.log("Status after restart - ", status.state);
    return status;

  } catch(error) {
    console.error(error);
  }
};

/**
 * Close the edge write token and make the stream object inactive.
 *
 * @methodGroup Live Stream
 * @namedParams
 * @param {string} name - Object ID or name of the live stream object
 *
 * @return {Promise&lt;Object>} - The finalize response for the stream object
 */
exports.StreamStopSession = async function({name}) {
  try {
    this.Log(`Terminating stream session for: ${name}`);
    let objectId = name;
    let libraryId = await this.ContentObjectLibraryId({objectId});

    let mainMeta = await this.ContentObjectMetadata({
      libraryId,
      objectId
    });

    let fabURI = mainMeta.live_recording.fabric_config.ingress_node_api;
    // Support both hostname and URL ingress_node_api
    if(!fabURI.startsWith("http")) {
      // Assume https
      fabURI = "https://" + fabURI;
    }

    this.SetNodes({fabricURIs: [fabURI]});

    const metaEdgeWriteToken = mainMeta.live_recording.fabric_config.edge_write_token;

    if(!metaEdgeWriteToken) {
      return {
        state: "inactive",
        error: "The stream is not active"
      };
    }

    try {
      const streamMetadata = await this.ContentObjectMetadata({
        libraryId,
        objectId,
        writeToken: metaEdgeWriteToken
      });

      const status = await this.StreamStatus({name});

      if(status.state !== "stopped") {
        return {
          state: status.state,
          error: "The stream must be stopped before terminating"
        };
      }

      await this.DeleteWriteToken({
        libraryId,
        writeToken: metaEdgeWriteToken
      });
    } catch(error) {
      this.Log("Unable to retrieve metadata for edge write token");
    }

    const {writeToken} = await this.EditContentObject({
      libraryId: libraryId,
      objectId: objectId
    });

    // Set stop time and inactive state
    const newState = "inactive";
    const stopTime = Math.floor(new Date().getTime() / 1000);

    const finalizeMetadata = {
      live_recording: {
        status: {
          edge_write_token: "",
          state: newState,
          recording_stop_time: stopTime
        },
        fabric_config: {
          edge_write_token: ""
        }
      }
    };

    await this.MergeMetadata({
      libraryId,
      objectId,
      writeToken,
      metadata: finalizeMetadata
    });

    let fin = await this.FinalizeContentObject({
      libraryId,
      objectId,
      writeToken,
      commitMessage: `Deactivate live stream - stop time ${stopTime}`
    });

    return {
      fin,
      name,
      state: newState
    };
  } catch(error) {
    console.error(error);
  }
};

/**
 * Initialize the stream object
 *
 * @methodGroup Live Stream
 * @namedParams
 * @param {string} name - Object ID or name of the live stream object
 * @param {boolean=} drm - If specified, playout will be DRM protected
 * @param {string=} format - Specify the list of playout formats and DRM to support,
 comma-separated (hls-clear, hls-aes128, hls-sample-aes,
 hls-fairplay)
 *
 * @return {Promise&lt;Object>} - The name, object ID, and state of the stream
 */
exports.StreamInitialize = async function({name, drm=false, format}) {
  let typeAbrMaster;
  let typeLiveStream;

  // Fetch Title and Live Stream content types from tenant meta
  const tenantContractId = await this.userProfileClient.TenantContractId();
  const {live_stream, title} = await this.ContentObjectMetadata({
    libraryId: tenantContractId.replace("iten", "ilib"),
    objectId: tenantContractId.replace("iten", "iq__"),
    metadataSubtree: "public/content_types",
    select: [
      "live_stream",
      "title"
    ]
  });

  if(live_stream) {
    typeLiveStream = live_stream;
  }

  if(title) {
    typeAbrMaster = title;
  }

  if(typeAbrMaster === undefined || typeLiveStream === undefined) {
    console.log("ERROR - unable to find content types", "ABR Master", typeAbrMaster, "Live Stream", typeLiveStream);
    return {};
  }

  const res = await this.StreamSetOfferingAndDRM({name, typeAbrMaster, typeLiveStream, drm, format});

  return res;
};

/**
 * Create a dummy VoD offering and initialize DRM keys.
 *
 * @methodGroup Live Stream
 * @namedParams
 * @param {string} name - Object ID or name of the live stream object
 * @param {string=} typeAbrMaster - Content type hash
 * @param {string=} typeLiveStream - Content type hash
 * @param {boolean=} drm - If specified, DRM will be applied to the stream
 * @param {string=} format - A list of playout formats and DRM to support, comma-separated
 * (hls-clear, hls-aes128, hls-sample-aes, hls-fairplay). If specified,
 * this will take precedence over the drm value
 *
 * @return {Promise&lt;Object>} - The name, object ID, and state of the stream
 */
exports.StreamSetOfferingAndDRM = async function({name, typeAbrMaster, typeLiveStream, drm=false, format}) {
  let status = await this.StreamStatus({name});
  if(status.state != "uninitialized" &amp;&amp; status.state != "inactive" &amp;&amp; status.state != "stopped") {
    return {
      state: status.state,
      error: "stream still active - must terminate first"
    };
  }

  let objectId = status.object_id;

  console.log("INIT: ", name, objectId);

  const aBitRate = 128000;
  const aChannels = 2;
  const aSampleRate = 48000;
  const aStreamIndex = 1;
  const aTimeBase = "1/48000";
  const aChannelLayout = "stereo";

  const vBitRate = 14000000;
  const vHeight = 720;
  const vStreamIndex = 0;
  const vWidth = 1280;
  const vDisplayAspectRatio = "16/9";
  const vFrameRate = "30000/1001";
  const vTimeBase = "1/30000"; // "1/16000";

  const abrProfileDefault = require("../abr_profiles/abr_profile_live_drm.js");

  let playoutFormats;
  let abrProfile = JSON.parse(JSON.stringify(abrProfileDefault));
  if(format) {
    drm = true; // Override DRM parameter
    playoutFormats = {};
    let formats = format.split(",");
    for(let i = 0; i &lt; formats.length; i++) {
      if(formats[i] === "hls-clear") {
        abrProfile.drm_optional = true;
        playoutFormats["hls-clear"] = {
          "drm": null,
          "protocol": {
            "type": "ProtoHls"
          }
        };
        continue;
      }
      if(formats[i] === "dash-clear") {
        abrProfile.drm_optional = true;
        playoutFormats["dash-clear"] = {
          "drm": null,
          "protocol": {
            "min_buffer_length": 2,
            "type": "ProtoDash"
          }
        };
        continue;
      }

      playoutFormats[formats[i]] = abrProfile.playout_formats[formats[i]];
    }
  } else if(!drm) {
    abrProfile.drm_optional = true;
    playoutFormats = {
      "hls-clear": {
        "drm": null,
        "protocol": {
          "type": "ProtoHls"
        }
      },
      "dash-clear": {
        "drm": null,
        "protocol": {
          "min_buffer_length": 2,
          "type": "ProtoDash"
        }
      }
    };
  } else {
    playoutFormats = Object.assign({}, abrProfile.playout_formats);
  }

  abrProfile.playout_formats = playoutFormats;

  let libraryId = await this.ContentObjectLibraryId({objectId});

  try {
    let mainMeta = await this.ContentObjectMetadata({
      libraryId,
      objectId
    });

    let fabURI = mainMeta.live_recording.fabric_config.ingress_node_api;
    // Support both hostname and URL ingress_node_api
    if(!fabURI.startsWith("http")) {
      // Assume https
      fabURI = "https://" + fabURI;
    }

    this.SetNodes({fabricURIs: [fabURI]});

    let streamUrl = mainMeta.live_recording.recording_config.recording_params.origin_url;

    await StreamGenerateOffering({
      client: this,
      libraryId,
      objectId,
      typeAbrMaster,
      typeLiveStream,
      streamUrl,
      abrProfile,
      aBitRate,
      aChannels,
      aSampleRate,
      aStreamIndex,
      aTimeBase,
      aChannelLayout,
      vBitRate,
      vHeight,
      vStreamIndex,
      vWidth,
      vDisplayAspectRatio,
      vFrameRate,
      vTimeBase
    });

    console.log("Finished generating offering");

    return {
      name,
      object_id: objectId,
      state: "initialized"
    };
  } catch(error) {
    console.error(error);
  }
};

/**
 * Add a content insertion entry
 *
 * @methodGroup Live Stream
 * @namedParams
 * @param {string} name - Object ID or name of the live stream object
 * @param {number} insertionTime - Time in seconds (float)
 * @param {boolean=} sinceStart - If specified, time specified will be elapsed seconds
 * since stream start, otherwise, time will be elapsed since epoch
 * @param {number=} duration - Time in seconds (float). Default: 20.0
 * @param {string} targetHash - The target content object hash (playable)
 * @param {boolean=} remove - If specified, will remove the inseration at the exact 'time' (instead of adding)
 *
 * @return {Promise&lt;Object>} - Insertions, as well as any errors from bad insertions
 */
exports.StreamInsertion = async function({name, insertionTime, sinceStart=false, duration, targetHash, remove=false}) {
  // Determine audio and video parameters of the insertion

  // Content Type check is currently disabled due to permissions
  /*
  let ct = await this.client.ContentObject({versionHash});
  if(ct.type != undefined &amp;&amp; ct.type != "") {
    let typeMeta = await this.client.ContentObjectMetadata({
      versionHash: ct.type
    });
    if(typeMeta.bitcode_flags != "abrmaster") {
      throw new Error("Not a playable VoD object " + versionHash);
    }
  }
  */
  let offeringMeta = await this.ContentObjectMetadata({
    versionHash: targetHash,
    metadataSubtree: "/offerings/default"
  });

  var insertionInfo = {
    duration_sec: 0 // Minimum of video and audio duration
  };
  ["video", "audio"].forEach(mt =>  {
    const stream = offeringMeta.media_struct.streams[mt];
    insertionInfo[mt] = {
      seg_duration_sec: stream.optimum_seg_dur.float,
      duration_sec: stream.duration.float,
      frame_rate_rat: stream.rate,
    };
    if(insertionInfo.duration_sec === 0 || stream.duration.float &lt; insertionInfo.duration_sec) {
      insertionInfo.duration_sec = stream.duration.float;
    }
  });

  const audioAbrDuration = insertionInfo.audio.seg_duration_sec;
  const videoAbrDuration = insertionInfo.video.seg_duration_sec;

  if(audioAbrDuration === 0 || videoAbrDuration === 0) {
    throw new Error("Bad segment duration hash:", targetHash);
  }

  if(duration === undefined) {
    duration = insertionInfo.duration_sec;  // Use full duration of the insertion
  } else {
    if(duration > insertionInfo.duration_sec) {
      throw new Error("Bad duration - larger than insertion object duration", insertionInfo.duration_sec);
    }
  }

  let objectId = name;
  let libraryId = await this.ContentObjectLibraryId({objectId});

  let mainMeta = await this.ContentObjectMetadata({
    libraryId,
    objectId
  });

  let fabURI = mainMeta.live_recording.fabric_config.ingress_node_api;

  // Support both hostname and URL ingress_node_api
  if(!fabURI.startsWith("http")) {
    // Assume https
    fabURI = "https://" + fabURI;
  }
  this.SetNodes({fabricURIs: [fabURI]});
  let edgeWriteToken = mainMeta.live_recording.fabric_config.edge_write_token;

  let edgeMeta = await this.ContentObjectMetadata({
    libraryId,
    objectId,
    writeToken: edgeWriteToken
  });

  // Find stream start time (from the most recent recording section)
  let recordings = edgeMeta.live_recording.recordings;
  let sequence = 1;
  let streamStartTime = 0;
  if(recordings != undefined &amp;&amp; recordings.recording_sequence != undefined) {
    // We have at least one recording - check if still active
    sequence = recordings.recording_sequence;
    let period = recordings.live_offering[sequence - 1];

    if(period.end_time_epoch_sec > 0) {
      // The last period is closed - apply insertions to the next period
      sequence ++;
    } else {
      // The period is active
      streamStartTime = period.start_time_epoch_sec;
    }
  }

  if(streamStartTime === 0) {
    // There is no active period - must use absolute time
    if(sinceStart === false) {
      throw new Error("Stream not running - must use 'time since start'");
    }
  }

  // Find the current period playout configuration
  if(edgeMeta.live_recording.playout_config.interleaves === undefined) {
    edgeMeta.live_recording.playout_config.interleaves = {};
  }
  if(edgeMeta.live_recording.playout_config.interleaves[sequence] === undefined) {
    edgeMeta.live_recording.playout_config.interleaves[sequence] = [];
  }

  let playoutConfig = edgeMeta.live_recording.playout_config;
  let insertions = playoutConfig.interleaves[sequence];

  let res = {};

  if(!sinceStart) {
    insertionTime = insertionTime - streamStartTime;
  }

  // Assume insertions are sorted by insertion time
  let errs = [];
  let currentTime = -1;
  let insertionDone = false;
  let newInsertion = {
    insertion_time: insertionTime,
    duration: duration,
    audio_abr_duration: audioAbrDuration,
    video_abr_duration: videoAbrDuration,
    playout: "/qfab/" + targetHash + "/rep/playout"  // TO FIX - should be a link
  };

  for(let i = 0; i &lt; insertions.length; i ++) {
    if(insertions[i].insertion_time &lt;= currentTime) {
      // Bad insertion - must be later than current time
      append(errs, "Bad insertion - time:", insertions[i].insertion_time);
    }
    if(remove) {
      if(insertions[i].insertion_time === insertionTime) {
        insertions.splice(i, 1);
        break;
      }
    } else {
      if(insertions[i].insertion_time > insertionTime) {
        if(i > 0) {
          insertions = [
            ...insertions.splice(0, i),
            newInsertion,
            ...insertions.splice(i)
          ];
        } else {
          insertions = [
            newInsertion,
            ...insertions.splice(i)
          ];
        }
        insertionDone = true;
        break;
      }
    }
  }

  if(!remove &amp;&amp; !insertionDone) {
    // Add to the end of the insertions list
    console.log("Add insertion at the end");
    insertions = [
      ...insertions,
      newInsertion
    ];
  }

  playoutConfig.interleaves[sequence] = insertions;

  // Store the new insertions in the write token
  await this.ReplaceMetadata({
    libraryId: libraryId,
    objectId: objectId,
    writeToken: edgeWriteToken,
    metadataSubtree: "/live_recording/playout_config",
    metadata: edgeMeta.live_recording.playout_config
  });

  res.errors = errs;
  res.insertions = insertions;

  return res;
};

/**
 * Configure the stream based on built-in logic and optional custom settings.
 *
 * Custom settings format:
 *    {
 *      "audio" {
 *        "1" : {  // This is the stream index
 *          "tags" : "language: english",
 *          "codec" : "aac",
 *          "bitrate": 204000,
 *          "record":  true,
 *          "recording_bitrate" : 192000,
 *          "recording_channels" : 2,
 *          "playout": bool
 *          "playout_label": "English (Stereo)"
 *        },
 *        "3": {
 *          ...
 *        }
 *      }
 *    }
 *
 * @methodGroup Live Stream
 * @namedParams
 * @param {string} name - Object ID or name of the live stream object
 * @param {Object=} customSettings - Additional options to customize configuration settings
 * @param {Object=} probeMetadata - Metadata for the probe. If not specified, a new probe will be configured
 * @return {Promise&lt;Object>} - The status response for the stream
 *
 */
exports.StreamConfig = async function({name, customSettings={}, probeMetadata}) {
  let objectId = name;
  let status = {name};

  let libraryId = await this.ContentObjectLibraryId({objectId});
  status.library_id = libraryId;
  status.object_id = objectId;

  let probe = probeMetadata;

  let mainMeta = await this.ContentObjectMetadata({
    libraryId: libraryId,
    objectId: objectId
  });

  let userConfig = mainMeta.live_recording_config;
  status.user_config = userConfig;

  // Get node URI from user config
  const parsedName = userConfig.url
    .replace("udp://", "https://")
    .replace("rtmp://", "https://")
    .replace("srt://", "https://");
  const hostName = new URL(parsedName).hostname;
  const streamUrl = new URL(userConfig.url);

  this.Log(`Retrieving nodes - matching: ${hostName}`);
  let nodes = await this.SpaceNodes({matchEndpoint: hostName});
  if(nodes.length &lt; 1) {
    status.error = "No node matching stream URL " + streamUrl.href;
    return status;
  }
  const node = {
    endpoints: nodes[0].services.fabric_api.urls,
    id: nodes[0].id
  };
  status.node = node;
  let endpoint = node.endpoints[0];

  if(!probe) {
    this.SetNodes({fabricURIs: [endpoint]});

    // Probe the stream
    probe = {};
    try {
      let probeUrl = await this.Rep({
        libraryId,
        objectId,
        rep: "probe"
      });

      probe = await this.utils.ResponseToJson(
        await HttpClient.Fetch(probeUrl, {
          body: JSON.stringify({
            "filename": streamUrl.href,
            "listen": true
          }),
          method: "POST"
        })
      );

      if(probe.errors) {
        throw probe.errors[0];
      }
    } catch(error) {
      if(error.code === "ETIMEDOUT") {
        throw "Stream probe time out - make sure the stream source is available";
      } else {
        throw error;
      }
    }

    probe.format.filename = streamUrl.href;
  }

  // Create live recording config
  let lc = new LiveConf(probe, node.id, endpoint, false, false, true);

  const liveRecordingConfig = lc.generateLiveConf({
    customSettings
  });

  // Store live recording config into the stream object
  let e = await this.EditContentObject({
    libraryId,
    objectId: objectId
  });
  let writeToken = e.write_token;

  await this.ReplaceMetadata({
    libraryId,
    objectId,
    writeToken,
    metadataSubtree: "live_recording",
    metadata: liveRecordingConfig.live_recording
  });

  await this.ReplaceMetadata({
    libraryId,
    objectId,
    writeToken,
    metadataSubtree: "live_recording_config/probe_info",
    metadata: probe
  });

  status.fin = await this.FinalizeContentObject({
    libraryId,
    objectId,
    writeToken,
    commitMessage: "Apply live stream configuration"
  });

  return status;
};

/**
 * List the pre-allocated URLs for a site
 *
 * @methodGroup Live Stream
 * @namedParams
 * @param {string=} siteId - ID of the live stream site object
 *
 * @return {Promise&lt;Object>} - The list of stream URLs
 */
exports.StreamListUrls = async function({siteId}={}) {
  try {
    const STATUS_MAP = {
      UNCONFIGURED: "unconfigured",
      UNINITIALIZED: "uninitialized",
      INACTIVE: "inactive",
      STOPPED: "stopped",
      STARTING: "starting",
      RUNNING: "running",
      STALLED: "stalled",
    };

    if(!siteId) {
      const tenantContractId = await this.userProfileClient.TenantContractId();

      if(!tenantContractId) {
        throw Error("No tenant contract ID configured");
      }

      siteId = await this.ContentObjectMetadata({
        libraryId: tenantContractId.replace("iten", "ilib"),
        objectId: tenantContractId.replace("iten", "iq__"),
        metadataSubtree: "public/sites/live_streams",
      });
    }

    const streamMetadata = await this.ContentObjectMetadata({
      libraryId: await this.ContentObjectLibraryId({objectId: siteId}),
      objectId: siteId,
      metadataSubtree: "public/asset_metadata/live_streams",
      resolveLinks: true,
      resolveIgnoreErrors: true,
      resolveIncludeSource: true
    });

    const activeUrlMap = {};
    await this.utils.LimitedMap(
      10,
      Object.keys(streamMetadata || {}),
      async slug => {
        const stream = streamMetadata[slug];
        let versionHash;

        if(stream &amp;&amp; stream["."] &amp;&amp; stream["."].source) {
          versionHash = stream["."].source;
        }

        if(versionHash) {
          const objectId = this.utils.DecodeVersionHash(versionHash).objectId;
          const libraryId = await this.ContentObjectLibraryId({objectId});

          const status = await this.StreamStatus({
            name: objectId
          });

          const streamMeta = await this.ContentObjectMetadata({
            objectId,
            libraryId,
            select: [
              "live_recording_config/reference_url",
              // live_recording_config/url is the old path
              "live_recording_config/url"
            ]
          });

          const url = streamMeta.live_recording_config.reference_url || streamMeta.live_recording_config.url;
          const isActive = [STATUS_MAP.STARTING, STATUS_MAP.RUNNING, STATUS_MAP.STALLED, STATUS_MAP.STOPPED].includes(status.state);

          if(url &amp;&amp; isActive) {
            activeUrlMap[url] = true;
          }
        }
      }
    );

    const streamUrlStatus = {};

    const streamUrls = await this.ContentObjectMetadata({
      libraryId: await this.ContentObjectLibraryId({objectId: siteId}),
      objectId: siteId,
      metadataSubtree: "/live_stream_urls",
      resolveLinks: true,
      resolveIgnoreErrors: true
    });

    if(!streamUrls) {
      throw Error("No pre-allocated URLs configured");
    }

    Object.keys(streamUrls || {}).forEach(protocol => {
      streamUrlStatus[protocol] = streamUrls[protocol].map(url => {
        return {
          url,
          active: activeUrlMap[url] || false
        };
      });
    });

    return streamUrlStatus;
  } catch(error) {
    console.error(error);
  }
};

/**
 * Copy a portion of a live stream recording into a standard VoD object using the zero-copy content fabric API
 *
 * Limitations:
 * - currently requires the target object to be pre-created and have content encryption keys (CAPS)
 * - for audio and video to be sync'd, the live stream needs to have the beginning of the desired recording period
 * - for an event stream, make sure the TTL is long enough to allow running the live-to-vod command before the beginning of the recording expires
 * - for 24/7 streams, make sure to reset the stream before the desired recording (as to create a new recording period) and have the TTL long enough
 *  to allow running the live-to-vod command before the beginning of the recording expires.
 * - startTime and endTime are not currently implemented by this method
 *
 *
 * @methodGroup Live Stream
 * @namedParams
 * @param {string} name - Object ID or name of the live stream
 * @param {string} targetObjectId - Object ID of the target VOD object
 * @param {string=} eventId -
 * @param {boolean=} finalize - If enabled, target object will be finalized after copy to vod operations
 * @param {number=} recordingPeriod - Determines which recording period to copy, which are 0-based. -1 copies the current (or last) period
 *
 * @return {Promise&lt;Object>} - The status response for the stream
 */

/*
   Example fabric API flow:

     https://host-76-74-34-194.contentfabric.io/qlibs/ilib24CtWSJeVt9DiAzym8jB6THE9e7H/q/$QWT/call/media/live_to_vod/init -d @r1 -H "Authorization: Bearer $TOK"

     {
       "live_qhash": "hq__5Zk1jSN8vNLUAXjQwMJV8F8J8ESXNvmVKkhaXySmGc1BXnJPG2FvvaXee4CXqvFHuGuU3fqLJc",
       "start_time": "",
       "end_time": "",
       "recording_period": -1,
       "streams": ["video", "audio"],
       "variant_key": "default"
     }

     https://host-76-74-34-194.contentfabric.io/qlibs/ilib24CtWSJeVt9DiAzym8jB6THE9e7H/q/$QWT/call/media/abr_mezzanine/init  -H "Authorization: Bearer $TOK" -d @r2

     {

       "abr_profile": { ...  },
       "offering_key": "default",
       "prod_master_hash": "tqw__HSQHBt7vYxWfCMPH5yXwKTfhdPcQ4Lcs9WUMUbTtnMbTZPTLo4BfJWPMGpoy1Dpv1wWQVtUtAtAr429TnVs",
       "variant_key": "default",
       "keep_other_streams": false
     }

     https://host-76-74-34-194.contentfabric.io/qlibs/ilib24CtWSJeVt9DiAzym8jB6THE9e7H/q/$QWT/call/media/live_to_vod/copy -d '{"variant_key":"","offering_key":""}' -H "Authorization: Bearer $TOK"


     https://host-76-74-34-194.contentfabric.io/qlibs/ilib24CtWSJeVt9DiAzym8jB6THE9e7H/q/$QWT/call/media/abr_mezzanine/offerings/default/finalize -d '{}' -H "Authorization: Bearer $TOK"

 */

exports.StreamCopyToVod = async function({
  name,
  targetObjectId,
  eventId,
  streams=null,
  finalize=true,
  recordingPeriod=-1,
  startTime="",
  endTime=""
}) {
  const objectId = name;
  const abrProfile = require("../abr_profiles/abr_profile_live_to_vod.js");

  const status = await this.StreamStatus({name});
  const libraryId = status.library_id;

  this.Log(`Copying stream ${name} to target ${targetObjectId}`);

  ValidateObject(targetObjectId);

  const targetLibraryId = await this.ContentObjectLibraryId({objectId: targetObjectId});

  // Validation - ensure target object has content encryption keys
  const kmsAddress = await this.authClient.KMSAddress({objectId: targetObjectId});
  const kmsCapId = `eluv.caps.ikms${this.utils.AddressToHash(kmsAddress)}`;
  const kmsCap = await this.ContentObjectMetadata({
    libraryId: targetLibraryId,
    objectId: targetObjectId,
    metadataSubtree: kmsCapId
  });

  if(!kmsCap) {
    throw Error(`No content encryption key set for object ${targetObjectId}`);
  }

  try {
    status.live_object_id = objectId;

    const liveHash = await this.LatestVersionHash({objectId, libraryId});
    status.live_hash = liveHash;

    if(eventId) {
      // Retrieve start and end times for the event
      let event = await this.CueInfo({eventId, status});
      if(event.eventStart &amp;&amp; event.eventEnd) {
        startTime = event.eventStart;
        endTime = event.eventEnd;
      }
    }

    const {writeToken} = await this.EditContentObject({
      objectId: targetObjectId,
      libraryId: targetLibraryId
    });

    status.target_object_id = targetObjectId;
    status.target_library_id = targetLibraryId;
    status.target_write_token = writeToken;

    this.Log("Process live source (takes around 20 sec per hour of content)");

    await this.CallBitcodeMethod({
      libraryId: targetLibraryId,
      objectId: targetObjectId,
      writeToken,
      method: "/media/live_to_vod/init",
      body: {
        "live_qhash": liveHash,
        "start_time": startTime, // eg. "2023-10-03T02:09:02.00Z",
        "end_time": endTime, // eg. "2023-10-03T02:15:00.00Z",
        "streams": streams,
        "recording_period": recordingPeriod,
        "variant_key": "default"
      },
      constant: false,
      format: "text"
    });

    const abrMezInitBody = {
      abr_profile: abrProfile,
      "offering_key": "default",
      "prod_master_hash": writeToken,
      "variant_key": "default",
      "keep_other_streams": false
    };

    await this.CallBitcodeMethod({
      libraryId: targetLibraryId,
      objectId: targetObjectId,
      writeToken,
      method: "/media/abr_mezzanine/init",
      body: abrMezInitBody,
      constant: false,
      format: "text"
    });

    try {
      await this.CallBitcodeMethod({
        libraryId: targetLibraryId,
        objectId: targetObjectId,
        writeToken,
        method: "/media/live_to_vod/copy",
        body: {},
        constant: false,
        format: "text"
      });
    } catch(error) {
      console.error("Unable to call /media/live_to_vod/copy", error);
      throw error;
    }

    await this.CallBitcodeMethod({
      libraryId: targetLibraryId,
      objectId: targetObjectId,
      writeToken,
      method: "/media/abr_mezzanine/offerings/default/finalize",
      body: abrMezInitBody,
      constant: false,
      format: "text"
    });

    if(finalize) {
      const finalizeResponse = await this.FinalizeContentObject({
        libraryId: targetLibraryId,
        objectId: targetObjectId,
        writeToken,
        commitMessage: "Live Stream to VoD"
      });

      status.target_hash = finalizeResponse.hash;
    }

    // Clean up unnecessary status items
    delete status.playout_urls;
    delete status.lro_status_url;
    delete status.recording_period;
    delete status.recording_period_sequence;
    delete status.edge_meta_size;
    delete status.insertions;

    return status;
  } catch(error) {
    this.Log(error, true);
    throw error;
  }
};

/**
 * Remove a watermark for a live stream
 *
 * @methodGroup Live Stream
 * @namedParams
 * @param {string=} libraryId - Library ID of the live stream
 * @param {string} objectId - Object ID of the live stream
 * @param {string=} writeToken - Write token of the draft
 * @param {Array&lt;string>} types - Specify which type of watermark to remove. Possible values:
 * - "image"
 * - "text"
 * - "forensic"
 * @param {boolean=} finalize - If enabled, target object will be finalized after removing watermark
 *
 * @return {Promise&lt;Object>} - The finalize response
 */
exports.StreamRemoveWatermark = async function({
  libraryId,
  objectId,
  writeToken,
  types,
  finalize=true
}) {
  ValidateObject(objectId);

  if(!libraryId) {
    libraryId = await this.ContentObjectLibraryId({objectId});
  }

  if(!writeToken) {
    ({writeToken} = await this.EditContentObject({
      objectId,
      libraryId
    }));
  }

  this.Log(`Removing watermark types: ${types.join(", ")} ${libraryId} ${objectId}`);

  const edgeWriteToken = await this.ContentObjectMetadata({
    objectId,
    libraryId,
    metadataSubtree: "/live_recording/fabric_config/edge_write_token"
  });

  const metadataPath = "live_recording/playout_config";

  const objectMetadata = await this.ContentObjectMetadata({
    libraryId,
    objectId,
    writeToken,
    metadataSubtree: metadataPath,
    resolveLinks: false
  });

  if(!objectMetadata) {
    throw Error("Stream object must be configured before removing a watermark");
  }

  types.forEach(type => {
    if(type === "text") {
      delete objectMetadata.simple_watermark;
    } else if(type === "image") {
      delete objectMetadata.image_watermark;
    } else if(type === "forensic") {
      delete objectMetadata.forensic_watermark;
    }
  });

  await this.ReplaceMetadata({
    libraryId,
    objectId,
    writeToken,
    metadataSubtree: metadataPath,
    metadata: objectMetadata
  });

  if(edgeWriteToken) {
    await this.ReplaceMetadata({
      libraryId,
      objectId,
      writeToken: edgeWriteToken,
      metadataSubtree: metadataPath,
      metadata: objectMetadata
    });
  }

  if(finalize) {
    const finalizeResponse = await this.FinalizeContentObject({
      libraryId,
      objectId,
      writeToken,
      commitMessage: "Watermark removed"
    });

    return finalizeResponse;
  }
};

/**
 * Create a watermark for a live stream
 *
 * @methodGroup Live Stream
 * @namedParams
 * @param {string=} libraryId - Library ID of the live stream
 * @param {string} objectId - Object ID of the live stream
 * @param {string=} writeToken - Write token of the draft
 * @param {Object} simpleWatermark - Text watermark
 * @param {Object} imageWatermark - Image watermark
 * @param {Object} forensicWatermark - Forensic watermark
 * @param {boolean=} finalize - If enabled, target object will be finalized after adding watermark
 * Watermark examples:
 *
 * Simple Watermark:
   {
     "font_color": "",
     "font_relative_height": 0,
     "shadow": false,
     "template": "",
     "timecode": "",
     "timecode_rate": 0,
     "x": "",
     "y": ""
   }
 *
 * Image watermark:
   {
     "image": "",
     "align_h": "",
     "align_v": "",
     "target_video_height": 0,
     "wm_enabled": false
   }
 *
 * Forensic watermark:
   {
     "algo": 6,
     "forensic_duration": 0,
     "forensic_start": "",
     "image_a": &lt;path_to_image>,
     "image_b": &lt;path_to_image>,
     "is_stub": true,
     "payload_bit_nb": 23,
     "wm_enabled": true
   }
 *
 *
 * @return {Promise&lt;Object>} - The finalize response
 */
exports.StreamAddWatermark = async function({
  libraryId,
  objectId,
  writeToken,
  simpleWatermark,
  imageWatermark,
  forensicWatermark,
  finalize=true
}) {
  ValidateObject(objectId);

  if(!libraryId) {
    libraryId = await this.ContentObjectLibraryId({objectId});
  }

  if(!writeToken) {
    ({writeToken} = await this.EditContentObject({
      objectId,
      libraryId
    }));
  }

  const edgeWriteToken = await this.ContentObjectMetadata({
    objectId,
    libraryId,
    metadataSubtree: "/live_recording/fabric_config/edge_write_token"
  });

  const watermarkType = imageWatermark ? "image" : forensicWatermark ? "forensic" : "text";
  const metadataPath = "live_recording/playout_config";

  this.Log(`Adding watermarking type: ${watermarkType} ${libraryId} ${objectId}`);

  const objectMetadata = await this.ContentObjectMetadata({
    libraryId,
    objectId,
    writeToken,
    metadataSubtree: metadataPath,
    resolveLinks: false
  });

  if(!objectMetadata) {
    throw Error("Stream object must be configured before adding a watermark");
  }

  const watermarkArgCount = [simpleWatermark, imageWatermark, forensicWatermark].filter(i => !!i).length;
  console.log("watermark arg count", watermarkArgCount);

  if(watermarkArgCount === 0) {
    throw Error("No watermark was provided");
  } else if(watermarkArgCount > 1) {
    throw Error("Only one watermark is allowed");
  }

  if(simpleWatermark) {
    objectMetadata.simple_watermark = simpleWatermark;
  } else if(imageWatermark) {
    objectMetadata.image_watermark = imageWatermark;
  } else if(forensicWatermark) {
    objectMetadata.forensic_watermark = forensicWatermark;
  }

  await this.ReplaceMetadata({
    libraryId,
    objectId,
    writeToken,
    metadataSubtree: metadataPath,
    metadata: objectMetadata
  });

  if(edgeWriteToken) {
    await this.ReplaceMetadata({
      libraryId,
      objectId,
      writeToken: edgeWriteToken,
      metadataSubtree: metadataPath,
      metadata: objectMetadata
    });
  }

  const response = {
    "imageWatermark": objectMetadata.image_watermark,
    "textWatermark": objectMetadata.simple_watermark,
    "forensicWatermark": objectMetadata.forensic_watermark
  };

  if(finalize) {
    const finalizeResponse = await this.FinalizeContentObject({
      libraryId,
      objectId,
      writeToken,
      commitMessage: "Watermark set"
    });

    response.hash = finalizeResponse.hash;
  }

  return response;
};

/**
 * Audit the specified live stream against several content fabric nodes
 *
 * @methodGroup Live Stream
 * @namedParams
 * @param {string=} objectId - Object ID of the live stream
 * @param {string=} versionHash - Version hash of the live stream -- if not specified, latest version is returned
 * @param {string=} salt - base64-encoded byte sequence for salting the audit hash
 * @param {Array&lt;number>=} samples - list of percentages (0.0 - &lt;1.0) used for sampling the content part list, up to 3
 * @param {string=} authorizationToken - Additional authorization token for this request
 *
 * @returns {Promise&lt;Object>} - Response describing audit results
 */
exports.AuditStream = async function({objectId, versionHash, salt, samples, authorizationToken}) {
  return await ContentObjectAudit.AuditContentObject({
    client: this,
    objectId,
    versionHash,
    salt,
    samples,
    live: true,
    authorizationToken
  });
};
</code></pre>
</div>

    



        <footer class="footer">
          Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.3</a>
        </footer>
      </div>
    </div>
  </div>

  <script>
    // Format and add line numbers to code
    prettyPrint();
  </script>

  <script type="text/javascript" src="scripts/utils.js"></script>

  </body>
</html>
